<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[putaindecode.io]]></title><description><![CDATA[putaindecode.io]]></description><link>http://putaindecode.io</link><generator>RSS for Node</generator><lastBuildDate>Fri, 16 Feb 2018 08:14:45 GMT</lastBuildDate><atom:link href="http://putaindecode.io/feed.xml" rel="self" type="application/rss+xml"/><item><title><![CDATA[Podcast 9: dotJS, React Native, bien-être au travail (feat. Kevin Deldycke & Freddy Harris)]]></title><description><![CDATA[<p>Un épisode qui arrive non pas avec un, mais deux mois de retard, et avec un son dégueulasse. On a eu un petit accident de prise de son et en dépit des essais de rattrapage, ça n'a pas donné grand chose. On en est vraiment désolé et on va mieux s'équiper pour la suite.</p>
<p>Pour cet épisode, nous sommes en compagnie de:</p>
<ul>
<li>Matthias, <a href="https://twitter.com/bloodyowl">https://twitter.com/bloodyowl</a></li>
<li>Mathieu, <a href="https://twitter.com/Zoontek">https://twitter.com/Zoontek</a></li>
<li>Georges, <a href="https://twitter.com/skinnyfoetusboy">https://twitter.com/skinnyfoetusboy</a></li>
</ul>
<p>et de deux invités:</p>
<ul>
<li>Freddy, <a href="https://twitter.com/HarrisFreddy">https://twitter.com/HarrisFreddy</a></li>
<li>Kevin, <a href="https://twitter.com/kdeldycke">https://twitter.com/kdeldycke</a></li>
</ul>
<p>On fait un petit retour sur l'édition 2017 de dotJS, on parle de ReactNative, et on échange avec beaucoup de digressions sur le bien-être au travail.</p>
<p>Encore désolé pour le son dégueu.</p>
<p>Bisous</p>
<iframe width="100%" height="300" scrolling="no" frameborder="no" allow="autoplay" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/392848578&amp;color=%23ff5500&amp;auto_play=false&amp;hide_related=true&amp;show_comments=true&amp;show_user=true&amp;show_reposts=false&amp;show_teaser=true&amp;visual=true"></iframe>
]]></description><link>http://putaindecode.io/fr/articles/podcast/9/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/podcast/9/</guid><pubDate>Thu, 01 Feb 2018 00:00:00 GMT</pubDate></item><item><title><![CDATA[Flow avancé - Seconde partie: les types opaques]]></title><description><![CDATA[<p>Vous avez digéré le premier article, peut-être même débuté avec <a href="https://flow.org/">flow</a> depuis, mais vous mourez d'envie de découvrir ce que vous pouvez faire de plus avec votre nouvel outil préféré ? Tant mieux, puisque nous sommes là pour parler d'une fonctionnalité assez avancée, apparue avec la version 0.51 et, à l'heure où j'écris ces lignes, indisponible dans TypeScript: les types opaques.</p>
<p>Si vous n'avez pas installé flow au sein de votre projet, je vous renvoie au <a href="/fr/articles/js/flow/advanced-part-1/">premier article</a> qui vous expliquera très bien comment faire.</p>
<h2 id="transparence-de-types"><a href="#transparence-de-types" class="phenomic-HeadingAnchor">#</a>Transparence de types</h2>
<p>Si on parle de types opaques, c'est bien parce que les types transparents existent. D'ailleurs par défaut, tout alias de type défini l'est. Mais que sont-ils ? Simple: ce sont des types compatibles entre eux et donc interchangeables.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

type FirstName = string;
type LastName = string;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">yellFirstName</span>(<span class="hljs-params">firstName: FirstName</span>) </span>{
  <span class="hljs-built_in">console</span>.log(firstName.toUpperCase());
}

<span class="hljs-keyword">const</span> name: LastName = <span class="hljs-string">"Acthernoene"</span>;
yellFirstName(name);</code></pre>
<p>Dans cet exemple, les types <code>FirstName</code> et <code>LastName</code> étant tout deux des alias de <code>string</code>, on peut sans problème utiliser la variable <code>name</code> de type <code>LastName</code> là où la function <code>yellFirstName</code> attend un paramètre de type <code>FirstName</code>. Pas cool.</p>
<h2 id="rendons-tout-cela-opaque"><a href="#rendons-tout-cela-opaque" class="phenomic-HeadingAnchor">#</a>Rendons tout cela opaque</h2>
<p>Nous allons donc modifier l'exemple précédent et…</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

opaque type FirstName = string;
opaque type LastName = string;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">yellFirstName</span>(<span class="hljs-params">firstName: FirstName</span>) </span>{
  <span class="hljs-built_in">console</span>.log(firstName.toUpperCase());
}

<span class="hljs-keyword">const</span> name: LastName = <span class="hljs-string">"Acthernoene"</span>;
yellFirstName(name);</code></pre>
<p>…toujours pas d'erreur ? Du calme, c'est normal. Les types <code>FirstName</code> et <code>LastName</code> étant accessibles car dans le même module JS, flow sait que ceux-ci sont des alias de type <code>string</code>. Modifions l'exemple et créons un deuxième module.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>
<span class="hljs-comment">// module.js</span>

opaque type FirstName = string;
opaque type LastName = string;

type User = {
  <span class="hljs-attr">firstName</span>: FirstName,
  <span class="hljs-attr">lastName</span>: LastName
};

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createUser</span>(<span class="hljs-params">firstName: string, lastName: string</span>): <span class="hljs-title">User</span> </span>{
  <span class="hljs-keyword">return</span> { firstName, lastName };
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">yellFirstName</span>(<span class="hljs-params">firstName: FirstName</span>) </span>{
  <span class="hljs-built_in">console</span>.log(firstName.toUpperCase());
}</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>
<span class="hljs-comment">// usage.js</span>

<span class="hljs-keyword">import</span> { createUser, yellFirstName } <span class="hljs-keyword">from</span> <span class="hljs-string">"./module"</span>;

yellFirstName(<span class="hljs-string">"Mathieu"</span>); <span class="hljs-comment">// ⚠️ Erreur: "string. Ce type est incompatible avec le type de paramètre attendu FirstName"</span>

<span class="hljs-keyword">const</span> user = createUser(<span class="hljs-string">"Acthernoene"</span>, <span class="hljs-string">"Mathieu"</span>);
yellFirstName(user.firstName); <span class="hljs-comment">// Pas d'erreur</span></code></pre>
<p>On voit ici qu'il n'est en fait possible d'utiliser le type <code>FirstName</code> qu'après son assignation au sein du module où celui-ci est défini. Un autre exemple: si l'on venait à rendre le type <code>User</code> opaque, alors nous ne pourrions pas accéder à <code>user.firstName</code>, la propriété étant inaccessible autrement que par une fonction qui manipulera le type <code>User</code>.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>
<span class="hljs-comment">// module.js</span>

opaque type FirstName = string;
opaque type LastName = string;

opaque type User = {
  <span class="hljs-attr">firstName</span>: FirstName,
  <span class="hljs-attr">lastName</span>: LastName
};

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createUser</span>(<span class="hljs-params">firstName: string, lastName: string</span>): <span class="hljs-title">User</span> </span>{
  <span class="hljs-keyword">return</span> { firstName, lastName };
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">yellFirstName</span>(<span class="hljs-params">firstName: FirstName</span>) </span>{
  <span class="hljs-built_in">console</span>.log(firstName.toUpperCase());
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">yellUserFirstName</span>(<span class="hljs-params">user: User</span>) </span>{
  <span class="hljs-built_in">console</span>.log(user.firstName.toUpperCase());
}</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>
<span class="hljs-comment">// usage.js</span>

<span class="hljs-keyword">import</span> { createUser, yellFirstName, yellUserFirstName } <span class="hljs-keyword">from</span> <span class="hljs-string">"./module"</span>;

<span class="hljs-keyword">const</span> user = createUser(<span class="hljs-string">"Acthernoene"</span>, <span class="hljs-string">"Mathieu"</span>);
yellFirstName(user.firstName); <span class="hljs-comment">// ⚠️ Erreur: "Propriété `firstName`. La propriété n'est pas accessible sur le type User"</span>
yellUserFirstName(user); <span class="hljs-comment">// Pas d'erreur</span></code></pre>
<h2 id="tu-naurais-pas-un-exemple-plus-concret-"><a href="#tu-naurais-pas-un-exemple-plus-concret-" class="phenomic-HeadingAnchor">#</a>Tu n'aurais pas un exemple plus concret ?</h2>
<p>Bien sûr que si ! Nous pouvons utiliser les types opaques pour implémenter un type <code>UUID</code> très basique:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>
<span class="hljs-comment">// uuid.js</span>

<span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">import</span> uuidv4 <span class="hljs-keyword">from</span> <span class="hljs-string">"uuid/v4"</span>; <span class="hljs-comment">// On installe 2 packages</span>
<span class="hljs-keyword">import</span> validator <span class="hljs-keyword">from</span> <span class="hljs-string">"validator"</span>;

<span class="hljs-keyword">export</span> opaque type UUID = string;

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params"></span>): <span class="hljs-title">UUID</span> </span>{
  <span class="hljs-keyword">return</span> uuidv4();
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">check</span>(<span class="hljs-params">uuid: UUID</span>): <span class="hljs-title">boolean</span> </span>{
  <span class="hljs-keyword">return</span> validator.isUUID(uuid);
}</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>
<span class="hljs-comment">// usage.js</span>

<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> UUID <span class="hljs-keyword">from</span> <span class="hljs-string">"./uuid"</span>;

UUID.check(<span class="hljs-string">"a duck"</span>); <span class="hljs-comment">// ⚠️ Erreur: "string. Ce type est incompatible avec le type de paramètre attendu UUID"</span>
UUID.check(<span class="hljs-string">"df7cca36-3d7a-40f4-8f06-ae03cc22f045"</span>); <span class="hljs-comment">// ⚠️ Erreur: "string. Ce type est incompatible avec le type de paramètre attendu UUID"</span>

<span class="hljs-keyword">const</span> uuid = UUID.create();
UUID.check(uuid); <span class="hljs-comment">// Pas d'erreur</span>

uuid.toUpperCase(); <span class="hljs-comment">// ⚠️ Erreur: "Appel de méthode `toUpperCase`. La méthode ne peut pas être appelée sur un type UUID"</span></code></pre>
<h1 id="cest-tout-de-même-assez-restrictifje-voudrais-ne-pas-devoir-tout-réimplémenter"><a href="#cest-tout-de-m%C3%AAme-assez-restrictifje-voudrais-ne-pas-devoir-tout-r%C3%A9impl%C3%A9menter" class="phenomic-HeadingAnchor">#</a>C'est tout de même assez restrictif…je voudrais ne pas devoir tout réimplémenter</h1>
<p>Ne vous inquiétez pas, les développeurs à l'origine de flow ont tout prévu et pour remédier à cela il existe ce qu'on appelle le sous-typage (ou <em>SubTyping</em> dans la langue de Shakespeare). Ainsi, nous allons dire à flow que chaque <code>UUID</code> est un <code>string</code> mais que la réciproque ce sera pas vraie pour autant.</p>
<p>Reprenons l'exemple précédent.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">import</span> uuidv4 <span class="hljs-keyword">from</span> <span class="hljs-string">"uuid/v4"</span>;
<span class="hljs-keyword">import</span> validator <span class="hljs-keyword">from</span> <span class="hljs-string">"validator"</span>;

<span class="hljs-keyword">export</span> opaque type UUID: string = string; <span class="hljs-comment">// Seul cette ligne change, on y ajoute un sous-type string</span>

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(<span class="hljs-params"></span>): <span class="hljs-title">UUID</span> </span>{
  <span class="hljs-keyword">return</span> uuidv4();
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">check</span>(<span class="hljs-params">uuid: UUID</span>): <span class="hljs-title">boolean</span> </span>{
  <span class="hljs-keyword">return</span> validator.isUUID(uuid);
}</code></pre>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>
<span class="hljs-comment">// usage.js</span>

<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> UUID <span class="hljs-keyword">from</span> <span class="hljs-string">"./uuid"</span>;

<span class="hljs-keyword">const</span> uuid = UUID.create();
UUID.check(uuid); <span class="hljs-comment">// Pas d'erreur</span>

uuid.toUpperCase(); <span class="hljs-comment">// Pas d'erreur: même si uuid est un UUID, il est utilisable comme un type string</span></code></pre>
<h2 id="que-retenir-de-tout-ça-"><a href="#que-retenir-de-tout-%C3%A7a-" class="phenomic-HeadingAnchor">#</a>Que retenir de tout ça ?</h2>
<p>Comme on a pu le voir, les types opaques élèvent clairement le niveau du type-game dans le milieu du JavaScript. Forcément utiles pour imposer l'utilisation de fonctions pour créer / manipuler certaines données, ils s'avéreront assez vite indispensables pour structurer davantage votre JS et améliorer sa maintenabilité.</p>
<p>Je vous encourage d'ailleurs à vous en servir quasiment partout (ça sera assez chiant au début, mais vous me remercierez plus tard) !</p>
<p>La bise, et rendez-vous pour une troisième partie 😘</p>
]]></description><link>http://putaindecode.io/fr/articles/js/flow/advanced-part-2/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/flow/advanced-part-2/</guid><pubDate>Tue, 02 Jan 2018 00:00:00 GMT</pubDate></item><item><title><![CDATA[Découverte de Preact]]></title><description><![CDATA[<p>Preact est une alternative à React. Plus précisément, voici sa description
officielle :</p>
<blockquote>
<p>Fast 3kB alternative to React with the same ES6 API.</p>
</blockquote>
<p>Cette description semble alléchante au premier coup d'oeil. Si on peut avoir un
React de 3ko, banco, on switch !</p>
<p>Pas si vite. L'API est la même, mais rien n'indique que Preact est un React qui
tient dans 3 petits ko (bien que c'est ce qu'on peut parfois lire). Ça ferait
bien longtemps que les ingénieurs de Facebook auraient réagit s'il était
possible de faire en sorte que React soit si petit. Preact fait donc des
compromis, des choix, et présente donc des différences avec React qu'il faut
connaître et prendre en compte avant d'envisager de switcher.</p>
<p><em>Cet article est destiné aux gens qui connaissent déjà au moins un petit peu
React. Tous les concepts liés à (P)React ne seront pas détaillés. Si vous ne
connaissez rien à React, je vous invite à lire <a href="/fr/articles/js/react/">l'introduction à
React</a>.</em></p>
<h2 id="quelles-sont-les-différences-entre-react-et-preact-"><a href="#quelles-sont-les-diff%C3%A9rences-entre-react-et-preact-" class="phenomic-HeadingAnchor">#</a>Quelles sont les différences entre React et Preact ?</h2>
<p>Les différences entre React et Preact peuvent être rangées dans deux catégories
: ce qu'il "manque" à Preact, et ce qui est là, mais différent.</p>
<h3 id="ce-quil-manque"><a href="#ce-quil-manque" class="phenomic-HeadingAnchor">#</a>Ce qu'il "manque"</h3>
<p>Premièrement, Preact se concentre uniquement sur le DOM. Cela signifie qu'il
n'existe pas d'équivalent à
<a href="https://facebook.github.io/react-native/">react-native</a>,
<a href="https://facebook.github.io/react-vr/">react-vr</a> ou tout autre
<a href="http://iamdustan.com/react-renderers/">renderer</a> du côté de Preact. Celui-ci a
pour but d'afficher du DOM le plus efficacement possible.</p>
<p>Cette spécialisation pour le DOM permet à Preact de ne pas avoir à implémenter
le système de Synthetic Events utilisé par React. Ainsi, Preact peut se
permettre d'utiliser simplement le système d'événements standard du navigateur.
Il faut bien avoir cela en tête lorsqu'on a l'habitude de travailler avec
React, car celui-ci corrige, ou du moins unifie certains comportements entre
les navigateurs (notamment sur <code>onChange</code>). Des différences dans le
comportement de votre app est donc à prévoir en cas de switch.</p>
<p>Preact n'embarque pas de gestion de validation des PropTypes. Partant du
principe que celles-ci ne sont pas utilisées par tout le monde, la décision a
été prise de ne pas les inclure dans le coeur de la bibliothèque.</p>
<p>Pour finir, Preact n'expose pas (encore, tout du moins) les nouvelles APIs de
React 16 telles que <code>React.Fragment</code> (dont <a href="https://github.com/developit/preact/issues/946">le support est
prévu</a>),
<code>ReactDOM.createPortal</code> (la fonctionnalité existe tout de même sous une forme
différente dans <a href="https://github.com/developit/preact-portal">preact-portal</a>) ou
<code>ReactDOM.hydrate</code>.</p>
<h3 id="ce-qui-est-différent"><a href="#ce-qui-est-diff%C3%A9rent" class="phenomic-HeadingAnchor">#</a>Ce qui est différent</h3>
<p>Preact utilise la bibliothèque
<a href="https://github.com/hyperhype/hyperscript">hyperscript</a>, qui est une version
générique de <code>React.createElement</code>. Le résultat est le même, la signature de la
fonction <code>h()</code> exposée par hyperscript étant la même que celle de
<code>React.createElement</code>. Il faudra quand même indiquer au compiler qu'il doit
utiliser cette fonction pour transpiler le JSX.</p>
<p>La méthode <code>render()</code> des composants reçoit toujours <code>this.props</code> et
<code>this.state</code> en paramètres, ce qui permet de les destructurer directement dans
les paramètres de la fonction, et ainsi de les traiter comme s'ils étaient
eux-mêmes des paramètres.</p>
<p>Preact gère l'API <code>context</code>, mais il n'existe pas de <code>contextTypes</code> ni de
<code>childContextTypes</code> (ce qui est raccord avec l'absence de <code>propTypes</code>). Tous
les enfants reçoivent le <code>context</code> définit dans la méthode <code>getChildContext()</code>
de leurs parents. Si plusieurs parents implémentent cette méthode, alors les
descendants recevront un agrégat.</p>
<p>Dans Preact, <code>props.children</code> est un <code>Array</code>. On peut donc utiliser toutes les
méthodes de <code>Array.prototype</code> dessus, sans avoir à passer par un équivalent de
<code>React.Children</code>. Toutefois, certains patterns tels que le <em>function as child</em>
nécessitent un peu de bricolage pour fonctionner.</p>
<p>Enfin, il est possible d'utiliser l'attribut <code>class</code> sur un noeud JSX.
<code>className</code> est aussi supporté, mais vous ne vous prendrez plus d'erreur
lorsque votre esprit se croira dans un fichier HTML et vous fera écrire
<code>class</code>.</p>
<h2 id="comment-démarrer-un-projet-preact-"><a href="#comment-d%C3%A9marrer-un-projet-preact-" class="phenomic-HeadingAnchor">#</a>Comment démarrer un projet Preact ?</h2>
<p>Pour démarrer sur de bonnes bases, le plus simple est d'utiliser
<a href="https://github.com/developit/preact-cli"><code>preact-cli</code></a>. C'est un outil en
ligne de commande qui vous permet de créer toute la structure de base de votre
application. Si vous connaissez <code>create-react-app</code>, alors vous aurez deviné que
<code>preact-cli</code> est l'équivalent pour Preact.</p>
<p>Commençons par l'installer : </p>
<pre><code class="hljs language-console">npm install -g preact-cli</code></pre>
<p>Nous avons maintenant accès à la commande <code>preact</code>. Celle-ci s'utilise de la
manière suivante :</p>
<pre><code class="hljs language-console">preact create &#x3C;template-name> &#x3C;project-name></code></pre>
<p>Où <code>&#x3C;template-name></code> est le nom d'un template officiel (listé sur l'org GitHub
<a href="https://github.com/preactjs-templates"><code>preactjs-template</code></a>) ou un repository
GitHub contenant un dossier <code>template</code> (de la forme <code>&#x3C;username>/&#x3C;repository></code>);
et <code>&#x3C;project-name></code> est le nom du dossier dans lequel la structure du projet
sera créée. Pour notre exemple, nous utiliserons le template <code>default</code>, et le
nom <code>test-preact</code> pour notre projet :</p>
<pre><code class="hljs language-console">preact create default test-preact</code></pre>
<p>En utilisant le template <code>default</code>, nous obtenons une application qui embarque
par défaut :</p>
<ul>
<li>Du code-splitting pour chaque route</li>
<li>Votre page <code>index.html</code> prérendue pour un affichage le plus rapide possible</li>
<li>Un ServiceWorker prêt à l'emploi (score Lighthouse 100/100 à la génération de
l'app, ce score est bien évidemment dépendant de ce que vous faites par la
suite)</li>
<li>Des metas preload en fonction de vos URL</li>
<li>Des polyfills chargés uniquement si nécessaire</li>
</ul>
<p>Il ne vous reste plus qu'à écrire votre app sur ces bases solides ! Pour
information, le routing est géré par
<a href="https://github.com/developit/preact-router"><code>preact-router</code></a>.</p>
<h2 id="jutilise-react-je-peux-switcher-sur-preact-"><a href="#jutilise-react-je-peux-switcher-sur-preact-" class="phenomic-HeadingAnchor">#</a>J'utilise React, je peux switcher sur Preact ?</h2>
<p>Oui, et pour ça il y a deux possibilités : ajouter une couche de compatibilité,
ou passer purement et simplement à Preact. </p>
<h3 id="rendre-preact-quasi-compatible-avec-react-en-utilisant-preact-compat"><a href="#rendre-preact-quasi-compatible-avec-react-en-utilisant-preact-compat" class="phenomic-HeadingAnchor">#</a>Rendre Preact quasi-compatible avec React en utilisant <code>preact-compat</code></h3>
<p>Le plus rapide est d'utiliser
<a href="https://github.com/developit/preact-compat"><code>preact-compat</code></a>. Ce module vient
s'ajouter à Preact pour y ajouter une couche de compatibilité le rendant
compatible avec preque n'importe quel module écrit pour React (tant que
celui-ci n'utilise pas les quelques bouts d'API manquants). Pour cela,
<code>preact-compat</code> expose l'ensemble de l'API de <code>react</code> et <code>react-dom</code>. Cela vous
permettra de continuer à utiliser sereinement tous vos composants écrits
spécifiquement pour React, ainsi que vous son écosystème.</p>
<p>Il faut donc l'installer, ainsi que Preact :</p>
<pre><code class="hljs language-console">npm install --save preact preact-compat</code></pre>
<p>Puis il faut ajouter des alias à votre système de build, afin que tous vos
imports de <code>react</code> et <code>react-dom</code> soient reroutés vers <code>preact-compat</code>. Par
exemple, pour webpack :</p>
<pre><code class="hljs language-javasscript"><span class="hljs-keyword">module</span>.exports = {
    <span class="hljs-comment">//... votre configuration webpack</span>
    resolve: {
        <span class="hljs-keyword">alias</span>: {
            <span class="hljs-string">"react"</span>: <span class="hljs-string">"preact-compat"</span>,
            <span class="hljs-string">"react-dom"</span>: <span class="hljs-string">"preact-compat"</span>
        }
    }
}</code></pre>
<p>Si vous n'utilisez pas webpack, votre système de build est très certainement
listé sur la
<a href="https://github.com/developit/preact-compat#preact-compat">documentation</a>.</p>
<p>Cette solution a l'avantage d'être très rapide à mettre en place. Toutefois, le
principal avantage de Preact est son poids de seulement 3ko. En ajoutant
<code>preact-compat</code>,vous ajouterez environ 2ko supplémentaires. Ce n'est pas
énorme, surtout si on prend en compte les avantages que ce module apporte, mais
il est possible de ne pas avoir à ajouter cette couche de compatibilité.</p>
<h3 id="passer-complètement-à-preact"><a href="#passer-compl%C3%A8tement-%C3%A0-preact" class="phenomic-HeadingAnchor">#</a>Passer complètement à Preact</h3>
<p>Cette solution est un peu plus longue à mettre en place, mais si votre code
n'est pas dépendant d'un module qui utilise des parties de l'API de React qui
ne sont pas prises en compte par Preact, alors elle vous permettra d'obtenir le
bundle le plus léger possible.</p>
<p>Premièrement, il faut installer Preact :</p>
<pre><code class="hljs language-console">npm install --save preact</code></pre>
<p>Puis il faut indiquer à votre compiler le pragma JSX qu'il doit utiliser. Pour
babel, vous pouvez installer le plugin <code>babel-plugin-transform-react-jsx</code> :</p>
<pre><code class="hljs language-console">npm instal --save-dev babel-plugin-transform-react-jsx</code></pre>
<p>Puis indiquer le pragma JSX dans les options de ce plugin dans votre fichier
<code>.babelrc</code> :</p>
<pre><code class="hljs language-js">{
    <span class="hljs-string">"plugins"</span>: [
        [<span class="hljs-string">"transform-react-jsx"</span>, { <span class="hljs-string">"pragma"</span>: <span class="hljs-string">"h"</span> }]
    ]
}</code></pre>
<p><em>Même si vous connaissez React, cette histoire de pragma JSX pourrait ne pas
vous évoquer grand chose. Si vous souhaitez en savoir plus, je vous conseille
de lire l'article suivant : <a href="https://jasonformat.com/wtf-is-jsx/">WTF is JSX</a>.
Si vous utilisez React et n'avez jamais eu à configurer ce pragma, c'est parce
que la plupart des compilers utilisent le pragma <code>@jsx React.createElement</code> par
défaut.</em></p>
<p>Si vous utilisez une version de React qui n'est pas à jour, il est possible que
votre codebase utilise l'ancienne syntaxe <code>React.createClass()</code>. Dans ce cas,
il faut que vous installiez
<a href="https://github.com/laurencedorman/preact-classless-component"><code>preact-classless-component</code></a>,
ou que vous passiez votre codebase dans le
<a href="https://github.com/vutran/preact-codemod"><code>preact-codemod</code></a> qui transformera
vos composants en classes ES6. De même, il se peut que vous utilisiez des
références par chaîne de caractères, qui ne sont pas supportées par Preact.
Dans ce cas, il faudra les transformer en références fonctionnelles.</p>
<p>Il ne vous reste plus qu'à mettre à jour vos imports pour que ceux-ci pointent
vers Preact. Voici un petit exemple :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { h, Component, render } <span class="hljs-keyword">from</span> <span class="hljs-string">"preact"</span>;

<span class="hljs-keyword">const</span> Header = <span class="hljs-function"><span class="hljs-params">()</span> =></span> &#x3C;header>Ma putain d<span class="hljs-string">'app&#x3C;/header>;

class App extends Component {
    render() {
        return (
            &#x3C;div>
                &#x3C;Header />
                &#x3C;main>
                    Hello, world !
                &#x3C;/main>
            &#x3C;/div>
        ); 
    }
}

render(&#x3C;App />, document.getElementById("app"));</span></code></pre>
<p>Voilà, vous avez maintenant une aperçu de ce qu'est Preact et des moyens à
votre disposition pour l'utiliser. Facebook ne vous est plus d'aucune utilité,
vous pouvez fermer votre compte.</p>
<p>Plus sérieusement, nous avons vu que Preact est en grande partie compatible
avec React et peut presque le remplacer sur une app web. Cela nécessite tout de
même un peu de travail et de vigilance, mais le switch est possible et peut
vous permettre de faire économiser à vos utilisateurs le téléchargement de
précieux ko.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/preact/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/preact/</guid><pubDate>Thu, 21 Dec 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Stop aux `npm install -g` sauvages (ou pourquoi vous ne devriez pas installer en global de packages et outils CLI)]]></title><description><![CDATA[<p>À chaque fois qu’un développeur installe un outil globalement, une discussion
tabs vs spaces commence. Et Dieu sait que c’est inutile. Les espaces c’est
mieux. Fin de la discussion.</p>
<p>À chaque fois qu’un développeur utilise un outil de développement global, un
chaton meurt. Et Dieu sait que nous aimons les chats.</p>
<p>Plus sérieusement, c’est une vraie question. Et une bonne question.</p>
<h2 id="pourquoi-installer-un-outil-de-manière-globale-sur-sa-machine-est-une-mauvaise-idée"><a href="#pourquoi-installer-un-outil-de-mani%C3%A8re-globale-sur-sa-machine-est-une-mauvaise-id%C3%A9e" class="phenomic-HeadingAnchor">#</a>Pourquoi installer un outil de manière globale sur sa machine est une mauvaise idée?</h2>
<p>On va tenter de répondre ici de manière constructive.</p>
<p>La raison est simple et c’est la même raison pour laquelle aujourd’hui il y a
Yarn et npm 5 qui utilisent des fichiers <code>lock</code> : parce que vous voulez avoir
l'assurance d'avoir la même version que vos collègues.</p>
<p>Très souvent, dans le fond un outil CLI n’est rien de plus qu’une dépendance à
un projet. Il est tout à fait (voire hautement) probable que sur deux projets
différents développés à deux instants différents dans le temps vous ayez utilisé
deux versions différentes d’un outil.</p>
<p>Le premier exemple de ma vie qui me vient en tête c’est les pré-processeurs CSS.
À l’époque où j’utilisais Sass, il était courant que pour une raison X ou Y (par
exemple une nouvelle fonctionnalité disponible dans une version majeure) que je
dois mettre à jour la version pour le projet en cours. Mais que se passe-t-il
alors pour tous mes anciens projets ? Vont-ils être compatibles ? Vont-ils avoir
des problèmes ? Vais-je devoir mettre mes autres projets à jour ? Cela va-t-il
me faire chier d’une manière hors du commun ?</p>
<p>Vous avez ici des vraies questions d'ordre pratique. Ça a dû arriver à tout le
monde d’avoir ce cas de figure.</p>
<p>Et je vais ajouter à ceci un autre problème.</p>
<h2 id="«-mais-puisse-ke-je-te-di-ke-sa-marche-cez-moi--»"><a href="#%C2%AB-mais-puisse-ke-je-te-di-ke-sa-marche-cez-moi--%C2%BB" class="phenomic-HeadingAnchor">#</a>« mais puisse ke je te di ke sa marche cez moi ! »</h2>
<p>On a tous travaillé à plus de deux développeurs sur un projet (et encore ça peut
nous arriver tout seul au changement de machine)</p>
<p>Le fameux « ça marche sur ma machine ». Celui-là qui prend grâve la tête.
Celui-là qui peut nous faire perdre des heures à comprendre pourquoi ça marche
pas sur le PC des collègues.</p>
<p>Celui-là qui énerve les personnes chez qui ça marche et ceux chez qui cela ne
marche pas. Oui ça fait clairement chier tout le monde.</p>
<p>Du coup pour éviter ce problème, il y a une méthode simple.</p>
<h2 id="ne-jamais-ô-grand-jamais-installer-un-outil-de-développeur-globalement-sur-sa-machine"><a href="#ne-jamais-%C3%B4-grand-jamais-installer-un-outil-de-d%C3%A9veloppeur-globalement-sur-sa-machine" class="phenomic-HeadingAnchor">#</a>Ne jamais (ô grand jamais) installer un outil de développeur globalement sur sa machine.</h2>
<p>De rien. Voilà c’était un conseil gratuit.</p>
<p>(Je détaillerai à la fin de cet article les seules raisons valables pour
utiliser et installer globalement un package ou un outil CLI)</p>
<p>Bon du coup pour éviter ce problème on a une solution extrêmement simple :
installer localement à chaque projet TOUTES les dépendances.</p>
<p>Il y a deux choses que peu de gens savent : la première est que npm et yarn vont
automatiquement ajouter tous les bin disponibles vu tous les node_modules locaux
dans le PATH utilisé via les scripts définis dans votre package.json.</p>
<p>Du coup dans la pratique il vous suffit de vous faire un petit alias pour chaque
outil CLI et le tour est joué.</p>
<pre><code class="hljs language-js">{
  <span class="hljs-string">"scripts"</span>: {
    <span class="hljs-string">"cmd"</span>: <span class="hljs-string">"cmd"</span> <span class="hljs-comment">// on assume qu'on a un outil qui offre le bin `cmd`</span>
  }
}</code></pre>
<pre><code class="hljs language-console">npm run cmd</code></pre>
<p>À savoir avec npm il faudra rajouter des — à la fin d’une commande pour que cela
fonctionne correctement si vous passez des arguments.</p>
<pre><code class="hljs language-console">npm run cmd -- arg</code></pre>
<p>Avec Yarn, cela n’est pas nécessaire. C’est bien plus bref (et pratique)</p>
<pre><code class="hljs language-console">yarn cmd arg</code></pre>
<p>Il faut savoir que pour les développeurs de ce type d’outil c’est aussi un petit
cauchemar à gérer.</p>
<p>Lorsqu’un outil à une package offrant une interface CLI, comment savoir si la
version de la bibliothèque fonctionnera avec ?</p>
<p>De cette problématique est née une solution récurrente : les package qui
ont une CLI et une bibliothèque en parallèle vont très souvent avoir une CLI
très light qui va en général consister à aller chercher dans le dossier de la
bibliothèque où vous vous trouvez le vrai code à exécuter.</p>
<p>Je dirais même que c’est plutôt cool dans un sens.</p>
<p>Mais on voit bien ici qu’on a un petit problème car cela demande du travail
supplémentaire aux développeurs des projets qui sont déjà trop souvent à flirter
avec le burnout.</p>
<h2 id="petite-astuce-bien-stylée"><a href="#petite-astuce-bien-styl%C3%A9e" class="phenomic-HeadingAnchor">#</a>Petite astuce bien stylée</h2>
<p>Vous pouvez ajouter tous les binaires de <code>node_modules/.bin</code> localement à votre
PATH histoire de pouvoir les utiliser en CLI.</p>
<pre><code class="hljs language-sh"><span class="hljs-comment"># to avoid npm install -g / yarn global add</span>
<span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:./node_modules/.bin</code></pre>
<p>Une fois cette astuce réalisée, déposez dans votre <code>.bashrc</code> (ou<code>.zshrc</code>…), vous
pourrez utiliser des bin locaux à votre projet comme si ils avaient été
installés globalement. Sans passer par alias. Mais ça ne marchera bien entendu
qu’à la racine du projet. Ça reste bien pratique n’est-ce pas?</p>
<p>(Et non, si vous faites ça dans l'ordre décrit plus haut, il n'y a pas de soucis
de sécurité genre <em>"un package remplace <code>rm</code> et fait ce qu'il veut avec mes
données"</em> puisque la priorité sera donnée à la première partie du <code>PATH</code>.)</p>
<h2 id="alternative-bien-stylée"><a href="#alternative-bien-styl%C3%A9e" class="phenomic-HeadingAnchor">#</a>Alternative bien stylée</h2>
<p>Si vous n'êtes pas fan de modifier votre <code>PATH</code>,
<a href="https://www.npmjs.com/package/npx"><code>npx</code></a> est un outil qui va justement
permettre d'appeler les <code>node_modules/.bin</code> locaux sans le modifier.</p>
<p>Au mais comment on l'installe? Avec <code>-g</code> pardi ! Je plaisante. Il est inclus
avec <code>npm</code>. Faites un petit <code>which npx</code> pour vérifier!</p>
<p>Dans tous les cas, <code>npx</code> fait partie des rares outils qui méritent d'être
installés en global, ceux qui sont pour l'environnement du développeur,
pas pour un projet.</p>
<p>D'ailleurs parlons en de ces cas où <code>-g</code> est valide.</p>
<h2 id="les-seuls-cas-valides-où-les-outils-globaux-ont-du-sens"><a href="#les-seuls-cas-valides-o%C3%B9-les-outils-globaux-ont-du-sens" class="phenomic-HeadingAnchor">#</a>Les seuls cas valides où les outils globaux ont du sens</h2>
<p>Les seuls cas valides sont pour des outils qui ne sont pas des outils liés à un
projet. C’est pas plus compliqué!</p>
<p>Répétez avec moi: <em>"Installer avec -g c'est pour mon environnement de
développeur, rien qu'à moi. Pas pour un projet".</em></p>
<p>En plus de <code>npx</code>, un très bon exemple serait
<a href="https://www.npmjs.com/package/trash"><code>trash(-cli)</code></a>, que je vous conseille
d’utiliser en place de <code>rm -rf</code> (il va plus vite (déplace dans votre corbeille),
et permet donc la récupération, sait-on jamais). Et encore si vous l’utilisez
sur un projet, pensez à l’ajouter aux dépendances (--dev)!</p>
<p>Il en existera d'autres, mais rappelez-vous que <code>npm install -g</code> est clairement
trop souvent recommandé alors qu'il ne devrait pas l'être!</p>
<p>N’hésitez pas à réagir à ces conseils.</p>
<p>Bisous à tous 😘</p>
<hr>
<h2 id="note-sur-npx-et-sa-magie-intégrée"><a href="#note-sur-npx-et-sa-magie-int%C3%A9gr%C3%A9e" class="phenomic-HeadingAnchor">#</a>Note sur <code>npx</code> et sa magie intégrée</h2>
<p><code>npx</code> permet de télécharger automatiquement les packages.
Par exemple tapez <code>npx mocha</code> et il vous installera le package <code>mocha</code> en global
et ira même jusqu'à s'occuper des mises à jour tout seul (en plus d'exécuter la
commande, puisque c'est son but initial).
Malheureusement, pour les raisons expliquées plus haut,
je ne pense vraiment pas que ça soit une bonne idée.
Que se passe-t-il si vous avez pris l'habitude d'utiliser <code>npx</code> et qu'un beau
jour il vous télécharge (puisque il ne vous demande rien - c'est magique)
une version contenant un bug? Vous aurez l'air malin. Et cela n'empêche en rien
le fameux problème du "ça marche sur ma machine" puisque vous aurez
potentiellement des collègues qui ne l'utiliseront pas. Oui ceux qui ne lisent
jamais les README et n'écoute pas les recommandations...</p>
<p>(Je vois encore trop souvent des gens utiliser <code>npm</code> sur des projets nécessitant
<code>yarn</code> et qui viennent se plaindre de temps en temps que
"ça-marche-plus-j'ai-fait-rm-rf-node_modules-&#x26;&#x26;-npm-install-mais-c-est-pas-mieux")</p>
]]></description><link>http://putaindecode.io/fr/articles/npm/install-g/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/npm/install-g/</guid><pubDate>Thu, 30 Nov 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Podcast 8: Google va t-il tuer le web ? (et Firefox, GitHub, Fastlane)]]></title><description><![CDATA[<p>Le voici le voilà, il est tout frais, l'épisode 8 !</p>
<p>On vous y parle de Reason3, Firefox Quantum, Atom Teletype, GitHub, fastlane, detox et on se posera la question …</p>
<p><strong>… GOOGLE VA T-IL TUER LE WEB ?</strong></p>
<p>À nouveau, je (Matthias, <a href="https://twitter.com/bloodyowl">https://twitter.com/bloodyowl</a>) présente avec mes fidèles comparses :</p>
<ul>
<li>Maxime (<a href="https://twitter.com/MoOx">https://twitter.com/MoOx</a>)</li>
<li>Georges (<a href="https://twitter.com/skinnyfoetusboy">https://twitter.com/skinnyfoetusboy</a>)</li>
</ul>
<p>Les liens:</p>
<ul>
<li>Reason3 : <a href="https://reasonml.github.io/community/blog/#reason-3">https://reasonml.github.io/community/blog/#reason-3</a></li>
<li>Firefox Quantum : <a href="https://blog.mozilla.org/firefox/the-new-firefox-is-here/">https://blog.mozilla.org/firefox/the-new-firefox-is-here/</a></li>
<li>Quelques nombres sur FF : <a href="https://blog.mozilla.org/firefox/the-new-firefox-by-the-numbers/">https://blog.mozilla.org/firefox/the-new-firefox-by-the-numbers/</a></li>
<li>Atom Teletype : <a href="https://teletype.atom.io">https://teletype.atom.io</a></li>
<li>GitHub Security Alerts : <a href="https://github.com/blog/2470-introducing-security-alerts-on-github">https://github.com/blog/2470-introducing-security-alerts-on-github</a></li>
<li>fastlane : <a href="https://fastlane.tools">https://fastlane.tools</a></li>
<li>detox : <a href="https://github.com/wix/detox">https://github.com/wix/detox</a></li>
</ul>
<p>Track du générique : <a href="https://soundcloud.com/matthias-le-brun/sparse">https://soundcloud.com/matthias-le-brun/sparse</a></p>
<iframe width="100%" height="300" scrolling="no" frameborder="no" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/359077001&amp;color=%23ff5500&amp;auto_play=false&amp;hide_related=true&amp;show_comments=true&amp;show_user=true&amp;show_reposts=false&amp;show_teaser=true&amp;visual=true"></iframe>
<ul>
<li>Le
<a href="http://feeds.soundcloud.com/users/soundcloud:users:273901232/sounds.rss">RSS</a></li>
<li>Sur iTunes : <a href="https://itunes.apple.com/fr/podcast/putain-de-code-!/id1185311825?l=en&#x26;mt=2">Putain de
Code</a></li>
</ul>
]]></description><link>http://putaindecode.io/fr/articles/podcast/8/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/podcast/8/</guid><pubDate>Fri, 24 Nov 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Flow avancé - Première partie]]></title><description><![CDATA[<p>Ça y est: vos collègues ont enfin réussi à vous motiver à utiliser <a href="https://flow.org/en/">flow</a>, l'outil de Facebook vous permettant d'ajouter du typage fort au sein de vos fichiers JavaScript. Seulement voilà, vous avez utilisé des langages à typage dynamique faible toute votre vie (PHP, JavaScript, Ruby, Python…), et pour le moment vous vous contentez d'ajouter des annotations de types <code>Object</code>, <code>Function</code> ou encore <code>string</code>. Frustrés, vous ne pouvez vous empêcher de crier sur tous les toits que le typage, c'est quand même chiant et limite une perte de temps puisque flow continue de manquer un tas d'erreurs potentielles au sein de votre code. Cet article est là pour vous aider à comprendre de quoi le bouzin est réellement capable, et même si vous n'utilisez pas flow, il peut servir de chouette introduction un peu poussée à son utilisation.</p>
<p>Nous utiliserons la dernière version en date à l'heure où j'écris ces lignes, c'est à dire la 0.59.
Pour l'ajouter au sein de votre projet, petit rappel:</p>
<pre><code class="hljs language-sh">npm install --save-dev flow-bin
npm install --save-dev flow-remove-types <span class="hljs-comment"># pour les besoin du tuto - vous pouvez également utiliser babel et le couple babel-plugin-syntax-flow / babel-plugin-transform-flow-strip-types</span>
npx flow init <span class="hljs-comment"># pour créer le fichier .flowconfig</span></code></pre>
<p><em>Pour plus d'infos sur npx, c'est <a href="https://www.npmjs.com/package/npx">par ici</a>. À noter que c'est livré de base avec npm maintenant.</em></p>
<h2 id="rappels-sur-linférence-de-type"><a href="#rappels-sur-linf%C3%A9rence-de-type" class="phenomic-HeadingAnchor">#</a>Rappels sur l'inférence de type</h2>
<p>Flow est un outil intelligent: il est inutile de préciser quel type est utilisé si celui-ci est évident à l'usage.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow &#x3C;- le pragma nécessaire pour indiquer à flow d'analyser votre fichier. À noter que si vous l'ajoutez sur un projet tout neuf, vous pouvez le configurer pour que celui-ci ne soit pas nécessaire</span>

<span class="hljs-keyword">const</span> quote = <span class="hljs-string">"Thirouin rouin rouin rouin"</span>;
<span class="hljs-built_in">Math</span>.round(quote); <span class="hljs-comment">// erreur! le type attendu est un number</span>

<span class="hljs-keyword">const</span> sayHello = <span class="hljs-function"><span class="hljs-params">name</span> =></span> <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>`</span>; <span class="hljs-comment">// inféré en (name: any) => string</span>
sayHello(<span class="hljs-string">"Mathieu"</span>); <span class="hljs-comment">// pas d'erreur</span>
sayHello(<span class="hljs-number">42</span>); <span class="hljs-comment">// pas d'erreur</span>
sayHello([<span class="hljs-string">"Mathieu"</span>, <span class="hljs-string">"zoontek"</span>]); <span class="hljs-comment">// erreur: ne peut être un array</span></code></pre>
<p>Attention: En annotant la fonction <code>sayHello</code> du type <code>Function</code>, vous perdez carrément l'inférence. Comme quoi, parfois ne pas préciser le type d'une variable peut se montrer plus efficace que d'utiliser des types "génériques" tels que <code>Object</code> ou <code>Function</code> (d'ailleurs je vous encourage à ne jamais le faire).</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">const</span> sayHello: <span class="hljs-built_in">Function</span> = <span class="hljs-function"><span class="hljs-params">name</span> =></span> <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>`</span>; <span class="hljs-comment">// inféré en (name: any) => any</span></code></pre>
<p>Si vous désirez interpoler un string, la bonne façon de faire est bien sûr la suivante :</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>
<span class="hljs-keyword">const</span> sayHello = <span class="hljs-function">(<span class="hljs-params">name: string</span>) =></span> <span class="hljs-string">`Hello <span class="hljs-subst">${name}</span>`</span>; <span class="hljs-comment">// (name: string) => string</span>
sayHello(<span class="hljs-string">"Mathieu"</span>); <span class="hljs-comment">// pas d'erreur</span>
sayHello(<span class="hljs-number">42</span>); <span class="hljs-comment">// pas d'erreur</span></code></pre>
<h2 id="les-types-primitifs-et-litéraux"><a href="#les-types-primitifs-et-lit%C3%A9raux" class="phenomic-HeadingAnchor">#</a>Les types primitifs et litéraux</h2>
<p>Le nombre de types primitifs existants en JavaScript est assez restreint. Vous avez le nombre (<code>number</code>), la chaine de caractères (<code>string</code>), les booléens (<code>boolean</code>), et bien évidemment les valeurs nulles (<code>null</code>) et inexistantes (<code>void</code>).
À noter que ES2015 a également apporté (<code>Symbol</code>), mais que ce dernier n'est pas encore supporté par flow.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">const</span> a: number = <span class="hljs-number">42</span>;
<span class="hljs-keyword">const</span> b: string = <span class="hljs-string">"Je ne suis pas Coluche, certes"</span>;
<span class="hljs-keyword">const</span> c: boolean = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">const</span> d: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">const</span> e: <span class="hljs-keyword">void</span> = <span class="hljs-literal">undefined</span>;</code></pre>
<p>Afin de vous montrer plus précis encore, vous pouvez également utiliser des valeurs litérales comme type. Après tout <code>string</code>, ça peut être tout et n'importe quoi. Si cela peut vous sembler stupide dans un premier temps, ceux-ci sont <strong>extrêmement</strong> utiles lorsque le système de typage est suffisamment perfectionné, commme vous le verrez par la suite.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">const</span> foo: <span class="hljs-string">"x"</span> = <span class="hljs-string">"x"</span>; <span class="hljs-comment">// pas d'erreur</span>
<span class="hljs-keyword">const</span> bar: <span class="hljs-number">2</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// erreur! n'est pas égal à 2</span></code></pre>
<h2 id="la-différence-entre-any-mixed-et-"><a href="#la-diff%C3%A9rence-entre-any-mixed-et-" class="phenomic-HeadingAnchor">#</a>La différence entre <code>any</code>, <code>mixed</code> et <code>*</code></h2>
<p>Comme expliqué au dessus, utiliser <code>any</code> revient à dire à flow qu'une variable peut être de n'importe quel type et cela est bien sûr extrêmement dangereux. Heureusement, il existe 2 alternatives plus sûres à connaître :</p>
<ul>
<li><code>mixed</code> qui dit que peu importe le type de la variable passée à une fonction, l'appel de celle-ci doit pouvoir se faire correctement: vous ne pourrez donc pas y appeler des méthodes spécifiques à un type de variable en particulier.</li>
<li><code>*</code> qui laisse travailler l'inférence de type de flow.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">arg: mixed</span>) </span>{
  <span class="hljs-built_in">console</span>.log(arg);
} <span class="hljs-comment">// pas d'erreur: peu importe le type réel du paramètre arg, l'appel se fera correctement</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params">arg: mixed</span>) </span>{
  <span class="hljs-built_in">console</span>.log(arg.toUpperCase());
} <span class="hljs-comment">// erreur! arg pourrait ne pas être une string</span>

<span class="hljs-keyword">const</span> baz: <span class="hljs-built_in">Array</span>&#x3C;*> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">// inféré en Array&#x3C;number></span>
baz.push(<span class="hljs-string">"Hello"</span>); <span class="hljs-comment">// "foo" est maintenant inféré en Array&#x3C;number | string> (tableau de string ou de numbers)</span></code></pre>
<h2 id="les-types-optionnels-ou-maybe-types"><a href="#les-types-optionnels-ou-maybe-types" class="phenomic-HeadingAnchor">#</a>Les types optionnels (ou maybe types)</h2>
<p>Si vous avez déjà utilisé un langage qui essaye d'éviter <a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare">l'erreur à un milliard de dollars</a>, vous connaissez sûrement les types <code>Option</code> / <code>Maybe</code>. Ils représentent la possible absence d'une valeur et sont ici symbolisés à l'aide d'un point d'interrogation.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">let</span> foo: ?string; <span class="hljs-comment">// peut-être une string, null ou undefined</span>
foo = <span class="hljs-string">"foo"</span>; <span class="hljs-comment">// pas d'erreur</span>
foo = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// pas d'erreur</span>
foo = <span class="hljs-literal">null</span>; <span class="hljs-comment">// pas d'erreur</span>
foo = <span class="hljs-number">3</span>; <span class="hljs-comment">// erreur - number n'est ni une string, ni null, ni undefined</span>

type Bar = {
  baz?: string; <span class="hljs-comment">// baz sera forcément une string si elle est présente</span>
};

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrongToUpperCase</span>(<span class="hljs-params">str: ?string</span>) </span>{
  <span class="hljs-keyword">return</span> str.toUpperCase(); <span class="hljs-comment">// erreur, str est possiblement nul, vous devez traiter ce cas</span>
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">correctToUpperCase</span>(<span class="hljs-params">str: ?string</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> str === <span class="hljs-string">"string"</span>) {
    <span class="hljs-keyword">return</span> str.toUpperCase(); <span class="hljs-comment">// pas d'erreur</span>
  }
}</code></pre>
<h2 id="les-types-génériques-generics"><a href="#les-types-g%C3%A9n%C3%A9riques-generics" class="phenomic-HeadingAnchor">#</a>Les types génériques (generics)</h2>
<p>Vous souvenez-vous de la syntaxe des tableaux (<code>Array&#x3C;any></code>) croisée plus tôt? Il s'agit de ce qu'on appelle un type générique : un type construit depuis un autre type. Ainsi, si <code>Array&#x3C;any></code> symbolise un tableau de tout et n'importe quoi, <code>Array&#x3C;number></code> symbolisera un tableau de numbers, etc.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-comment">// on crée un type Classement qui prend en "paramètre" un type générique qu'on nomme "T"</span>
type Classement&#x3C;T> = {
  <span class="hljs-attr">first</span>: T,
  <span class="hljs-attr">second</span>: T,
  <span class="hljs-attr">third</span>: T
};

<span class="hljs-keyword">const</span> numberClassement: Classement&#x3C;number> = {
  <span class="hljs-attr">first</span>: <span class="hljs-number">42</span>,
  <span class="hljs-attr">second</span>: <span class="hljs-number">7</span>,
  <span class="hljs-attr">third</span>: <span class="hljs-number">1</span>
};</code></pre>
<p>Voici quelques exemples de types génériques disponibles out-of-the-box :</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">const</span> foo: <span class="hljs-built_in">Array</span>&#x3C;number> = [];

<span class="hljs-keyword">const</span> bar: <span class="hljs-built_in">Map</span>&#x3C;number, string> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
bar.set(<span class="hljs-number">1</span>, <span class="hljs-string">"one"</span>);

<span class="hljs-keyword">const</span> baz: <span class="hljs-built_in">Set</span>&#x3C;number> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
baz.add(<span class="hljs-number">1</span>);

<span class="hljs-keyword">const</span> p: <span class="hljs-built_in">Promise</span>&#x3C;number> = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">42</span>);</code></pre>
<h2 id="la-manipulation-dobjets"><a href="#la-manipulation-dobjets" class="phenomic-HeadingAnchor">#</a>La manipulation d'objets</h2>
<p>Avez vous remarqué que pour le moment, j'ai tenté de ne pas utiliser d'objets au sein de mes exemples (oui, c'était chiant)? C'est tout simplement car les possibilités de manipulation des types de ceux-ci sont très nombreuses. Je vous propose un exemple fleuve histoire d'y voir plus clair.</p>
<p>Un type objet se définit de la sorte :</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

type User = {
  <span class="hljs-attr">name</span>: string,
  <span class="hljs-attr">pseudo</span>: string
};

<span class="hljs-keyword">const</span> user: User = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"Mathieu"</span>,
  <span class="hljs-attr">pseudo</span>: <span class="hljs-string">"zoontek"</span>
};

<span class="hljs-comment">// Ce qui n'exclut pas de faire</span>
<span class="hljs-keyword">const</span> newUser: User = {
  ...user,
  <span class="hljs-attr">age</span>: <span class="hljs-number">26</span>
}; <span class="hljs-comment">// pas d'erreur</span></code></pre>
<p>Pour sceller les propriétés de notre objet, on utilise la notation <code>{||}</code> :</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

type User = {|
  name: string,
  <span class="hljs-attr">pseudo</span>: string
|};

<span class="hljs-keyword">const</span> user: User = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"Mathieu"</span>,
  <span class="hljs-attr">pseudo</span>: <span class="hljs-string">"zoontek"</span>
};

<span class="hljs-keyword">const</span> newUser: User = {
  ...user,
  <span class="hljs-attr">age</span>: <span class="hljs-number">26</span>
}; <span class="hljs-comment">// erreur! la propriété age n'existe pas</span></code></pre>
<p>Pour indiquer qu'une propriété de notre objet est immutable, on utilise la notation <code>+</code>. Un must-have pour vos reducers Redux.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

type User = {
  +name: string,
  <span class="hljs-attr">pseudo</span>: string
};

<span class="hljs-keyword">const</span> user: User = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"Mathieu"</span>,
  <span class="hljs-attr">pseudo</span>: <span class="hljs-string">"zoontek"</span>
};

user.name = <span class="hljs-string">"Jean-Michel"</span>; <span class="hljs-comment">// erreur! la valeur de name ne peut-être modifiée</span>

<span class="hljs-keyword">const</span> newUser: User = {
  ...user,
  <span class="hljs-attr">name</span>: <span class="hljs-string">"Jean-Michel"</span>
}; <span class="hljs-comment">// pas d'erreur</span></code></pre>
<blockquote>
<p>Le spreading c'est vraiment cool! Ça existe aussi pour les types?</p>
</blockquote>
<p>Yep.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

type Foo = {| a: number, <span class="hljs-attr">b</span>: string |};
type Bar = {| a: string |};
type Baz = {| ...Foo, ...Bar |}; <span class="hljs-comment">// {| a: string, b: string |}</span></code></pre>
<p>Un dernier petit trick sur les objets pour la route? Vous pouvez les utiliser comme maps :</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-keyword">const</span> foo: { [key: string]: number } = {
  <span class="hljs-attr">bar</span>: <span class="hljs-number">42</span>,
  <span class="hljs-attr">baz</span>: <span class="hljs-string">"whatever"</span> <span class="hljs-comment">// erreur! les valeurs des propriétés de cet objet doivent être de type number</span>
};</code></pre>
<h2 id="les-unions-et-intersections-de-types"><a href="#les-unions-et-intersections-de-types" class="phenomic-HeadingAnchor">#</a>Les unions et intersections de types</h2>
<p>Si vous avez remarqué la notation avec <code>|</code> plus tôt, vous vous posez sûrement la question de ce que ça représente. Il s'agit d'une union de types : la variable aura une valeur à plusieurs types possibles. Petit conseil : utilisez toujours une union de types litéraux à la place du simple <code>string</code> lorsque vous connaissez à l'avance les possibles valeurs de celui-ci.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHelloOrRound</span>(<span class="hljs-params">arg: string | number</span>) </span>{ <span class="hljs-comment">// arg peut être une string ou un number</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> arg === <span class="hljs-string">"string"</span> ? <span class="hljs-string">`Hello <span class="hljs-subst">${arg}</span>`</span> : <span class="hljs-built_in">Math</span>.round(arg);
} <span class="hljs-comment">// pas d'erreur</span>

type Color =
  | <span class="hljs-string">"red"</span>
  | <span class="hljs-string">"green"</span>
  | <span class="hljs-string">"blue"</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toHexadecimal</span>(<span class="hljs-params">color: Color</span>) </span>{
  <span class="hljs-keyword">switch</span> (color) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"red"</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">"#FF0000"</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">"green"</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">"#00FF00"</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">"blue"</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-string">"#0000FF"</span>;
  }
}

toHexadecimal(<span class="hljs-string">"red"</span>); <span class="hljs-comment">// pas d'erreur</span>
toHexadecimal(<span class="hljs-string">"green"</span>); <span class="hljs-comment">// pas d'erreur</span>
toHexadecimal(<span class="hljs-string">"blue"</span>); <span class="hljs-comment">// pas d'erreur</span>
toHexadecimal(<span class="hljs-string">"pink"</span>); <span class="hljs-comment">// erreur! "pink" n'est pas une valeur possible</span>
toHexadecimal(<span class="hljs-string">"dog"</span>); <span class="hljs-comment">// erreur! "dog" n'est pas une valeur possible</span></code></pre>
<p>Parfois, une union de types se montre également bien plus efficace pour modéliser ce que vous souhaitez, à contrario d'un tas de maybe types.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

type ApiResponseBadlyTyped = {|
  success: boolean,
  value?: string, <span class="hljs-comment">// value peut être présent</span>
  error?: <span class="hljs-built_in">Error</span> <span class="hljs-comment">// error peut être présent</span>
|};

<span class="hljs-keyword">const</span> foo: ApiResponseBadlyTyped = { <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span> }; <span class="hljs-comment">// pas d'erreur alors que j'attends une value</span>
<span class="hljs-keyword">const</span> bar: ApiResponseBadlyTyped = { <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">error</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"oups!"</span>) }; <span class="hljs-comment">// pas d'erreur non plus</span>

type ApiResponseCorrectlyTyped =
  | {| success: <span class="hljs-literal">true</span>, <span class="hljs-attr">value</span>: string |}
  | {| success: <span class="hljs-literal">false</span>, <span class="hljs-attr">error</span>: <span class="hljs-built_in">Error</span> |};

<span class="hljs-keyword">const</span> foo: ApiResponseCorrectlyTyped = { <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span> }; <span class="hljs-comment">// erreur! il manque value</span>
<span class="hljs-keyword">const</span> bar: ApiResponseCorrectlyTyped = { <span class="hljs-attr">success</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">error</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"oups!"</span>) }; <span class="hljs-comment">// erreur! si success est à true, on ne doit pas trouver d'error dans notre objet</span>
<span class="hljs-keyword">const</span> baz: ApiResponseCorrectlyTyped = { <span class="hljs-attr">success</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">error</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"oups!"</span>) }; <span class="hljs-comment">// pas d'erreur</span></code></pre>
<p>Si les unions de types sont le <strong>OU</strong> logique du système de typage, les intersections de types en sont le <strong>ET</strong>. On les symbolise à l'aide d'un <code>&#x26;</code>.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// @flow</span>

type Foo = { <span class="hljs-attr">a</span>: number };
type Bar = { <span class="hljs-attr">b</span>: string };
type Baz = { <span class="hljs-attr">c</span>: boolean };

<span class="hljs-keyword">const</span> test: Foo &#x26; Bar &#x26; Baz = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">42</span>,
  <span class="hljs-attr">b</span>: <span class="hljs-string">"whatever"</span>,
  <span class="hljs-attr">c</span>: <span class="hljs-literal">true</span>
}; <span class="hljs-comment">// pas d'erreur</span>

<span class="hljs-keyword">let</span> impossible: number &#x26; string; <span class="hljs-comment">// sera forcément impossible à initialiser : une valeur ne pourra jamais être un number ET une string</span></code></pre>
<p>C'est tout pour le moment! Vous vous doutez que l'on égratigne à peine la surface de ce qui nous est offert par flow et les systèmes de typage fort en général. Si vous êtes vraiment impatients de découvrir la suite, je vous renvoie vers la <a href="https://flow.org/en/docs/">documentation de flow</a>, très bien foutue. Pour les autres, on devrait sortir très prochainement un article sur le même sujet (on y parlera classes, interfaces et peut être même types opaques si vous êtes sages).</p>
<p>Stay tuned! La bise.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/flow/advanced-part-1/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/flow/advanced-part-1/</guid><pubDate>Thu, 23 Nov 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Respecter SemVer (presque) sans avoir à y penser avec semantic-release]]></title><description><![CDATA[<h2 id="petit-rappel--semver-cest-quoi-déjà-"><a href="#petit-rappel--semver-cest-quoi-d%C3%A9j%C3%A0-" class="phenomic-HeadingAnchor">#</a>Petit rappel : SemVer, c'est quoi déjà ?</h2>
<p>SemVer signifie <strong>Sem</strong>antic <strong>Ver</strong>sionning. C'est une manière de numéroter
les versions succéssives d'un module. Je vous invite à aller lire
<a href="http://putaindecode.io/fr/articles/semver/">l'article sur SemVer</a> avant
de lire la suite si vous n'êtes pas certain de bien comprendre ce que c'est.
Je vais ici citer certaines parties de ce post afin de faire un rapide
résumé :</p>
<blockquote>
<p>Une version s'applique à un produit, une application, une bibliothèque, un OS,
tout ce qui a une progression en informatique. Cela permet de définir
l'avancement du produit. SemVer s'écrit de cette façon : X.Y.Z où X est
"majeur", Y est "mineur", Z est "patch".</p>
</blockquote>
<blockquote>
<p>SemVer est un contrat que vous signez avec vos utilisateurs, une forme de
respect qui leur permet d'adapter leur code ou non en fonction des versions que
vous proposez.</p>
</blockquote>
<blockquote>
<p>Cela veut dire que si vous avez corrigé un bug dans votre lib et que cela
n'affecte en rien le code écrit par votre utilisateur, alors incrémentez Z
(+0.0.1).</p>
</blockquote>
<blockquote>
<p>Si vous avez fait des ajouts dans votre app qui peuvent être intéressants
pour l'utilisateur et mérite une certaine attention afin d'améliorer le code
qui utilise votre lib, alors incrémentez Y (+0.1.0).</p>
</blockquote>
<blockquote>
<p>Si en revanche, vous avez cassé ne serait-ce qu'une partie de l'API
("breaking changes"), que vous avez juste changé des noms de méthodes /
fonctions déjà existantes (et donc sûrement utilisées par quelqu'un d'autre),
que finalement cela nécessite forcément une modification de la part de
l'utilisateur sous peine que sa propre app ne fonctionne plus, alors
incrémentez X (+1.0.0).</p>
</blockquote>
<p>Maintenant que nous sommes au point sur SemVer, passons à la suite.</p>
<h2 id="publier-un-module-sur-npm-manuellement"><a href="#publier-un-module-sur-npm-manuellement" class="phenomic-HeadingAnchor">#</a>Publier un module sur npm manuellement</h2>
<p>Lorsqu'on veut publier un module sur npm, on utilise principalement deux
commandes : <code>npm version</code> et <code>npm publish</code>.</p>
<p><code>npm version</code> nous permet de dire quelle composante de notre numéro de version
on souhaite incrémenter. Ainsi, <code>npm version major</code> augmentera la partie
<code>MAJEUR</code>, <code>npm version minor</code> augmentera la partie <code>MINEUR</code> et <code>npm version patch</code>... je crois que vous l'avez maintenant. La commande crée aussi un tag
git ayant pour nom le numéro de version.</p>
<p>Une fois la nouvelle version prête, <code>npm publish</code> permet, vous l'aurez deviné
(j'espère), de la publier sur npm.</p>
<p>Ce processus semble simple à première vue. Selon les modifications qui ont été
apportées au module depuis la dernière version, on décide de la composante
SemVer à incrémenter, on lance un <code>npm version</code> puis un <code>npm publish</code> et c'est
terminé. Pourtant, une étape du processus implique une décision prise par un
humain, et est donc soumise à interprétation ainsi qu'à de potentielles erreurs
ou oublis.</p>
<p>Imaginons : je travaille sur mon super module au nom extrêmement original
<code>foobar</code>. Celui-ci est actuellement en version <code>1.2.3</code> et plusieurs personnes
ont proposé des pull requests ajoutant des fonctionnalités et corrigeant des
bugs. Il est temps de publier une nouvelle version de <code>foobar</code> afin que tout le
monde puisse bénéficier de ces améliorations. Je passe en revue ce qui a été
ajouté, et je décide d'incrémenter la composante <code>MINEUR</code> de mon numéro de
version. Je publie cette nouvelle version, documente le tout dans une note de
version, je suis heureux.</p>
<p>Manque de chance, quelques temps après la publication, les issues Github de mon
projet s'affolent. J'ai raté une modification non rétrocompatible, les
utilisateurs de mon module (auxquels je promets de respecter SemVer) se sont
joyeusement empressés de faire la mise à jour dans leur application, et
maintenant tout est cassé. Sueurs froides, j'étais pourtant sûr de mon coup, et
maintenant je dois me débrouiller pour régler ce problème dans l'urgence.
"Accessoirement", j'ai aussi perdu la confiance que m'accordaient certains
utilisateurs.</p>
<p>Après avoir réglé le problème, une question se pose : comment éviter cela à
l'avenir ?</p>
<h2 id="semantic-release-pour-ne-plus-se-soucier-de-rien-sauf-de-ce-sur-quoi-on-travaille"><a href="#semantic-release-pour-ne-plus-se-soucier-de-rien-sauf-de-ce-sur-quoi-on-travaille" class="phenomic-HeadingAnchor">#</a>semantic-release, pour ne plus se soucier de rien, sauf de ce sur quoi on travaille</h2>
<p>Eviter ce problème, c'est la promesse de
<a href="https://github.com/semantic-release/semantic-release">semantic-release</a>. Ce
module nous permet de ne plus avoir à décider nous-même du prochain numéro de
version de notre module.</p>
<p>Le principe est simple : à chaque fois que je fais un commit, je décris dans le
message qui l'accompagne ce que j'ai effectué dans celui-ci, dans un format
précis qui pourra être analysé automatiquement afin de calculer le prochain
numéro de version. C'est un deal entre nous et semantic-release : si on
respecte ce format, il nous garantit de correctement incrémenter les
différentes composantes du numéro de version, et de publier automatiquement
chaque nouvelle version de notre module.</p>
<p>Par défaut, semantic-release se base sur la convention de message de commit du
projet AngularJS, qui propose le format suivant :</p>
<pre><code>&#x3C;type>(&#x3C;scope>): &#x3C;subject>
&#x3C;BLANK LINE>
&#x3C;body>
&#x3C;BLANK LINE>
&#x3C;footer>
</code></pre>
<p>Ainsi, si un commit correspond à la correction d'un bug, je peux lui attribuer
un message de la forme (exemples tirés de la documentation) :</p>
<pre><code>fix(pencil): stop graphite breaking when too much pressure applied
</code></pre>
<p>Dans le cas d'un ajout de fonctionnalité :</p>
<pre><code>feat(pencil): add 'graphiteWidth' option
</code></pre>
<p>Et dans le cas d'une modification qui casse la rétrocompatibilité :</p>
<pre><code>perf(pencil): remove graphiteWidth option

BREAKING CHANGE: The graphiteWidth option has been removed. The default
graphite width of 10mm is always used for performance reasons.
</code></pre>
<p>Ainsi, lorsque semantic-release va passer tous les commits en revue, il pourra
analyser le type de chacun d'entre eux, ainsi que rechercher les "BREAKING
CHANGE", afin d'incrémenter le numéro de version comme il se doit.</p>
<p>Petit bonus : semantic-release se charge aussi de vous générer des notes de
version et de les ajouter à votre release sur Github.</p>
<p>Finalement, en écrivant de bons messages de commits (ce qui devrait déjà être
le cas, non ?) qui suivent un formalisme précis, vous vous épargnez d'avoir à
gérer vous-même SemVer pour votre module.</p>
<h2 id="mettre-en-place-semantic-release-sur-son-projet"><a href="#mettre-en-place-semantic-release-sur-son-projet" class="phenomic-HeadingAnchor">#</a>Mettre en place semantic-release sur son projet</h2>
<p>Voyons maintenant comment mettre en place semantic-release sur un projet de
module npm.</p>
<p>La première chose à faire, c'est d'installer la CLI :</p>
<pre><code>npm install -g semantic-release-cli
</code></pre>
<p>Puis de lancer le setup dans le dossier de votre projet :</p>
<pre><code>semantic-release-cli setup
</code></pre>
<p>semantic-release vous pose alors quelques questions :</p>
<ul>
<li><code>What is your npm registry?</code> : appuyez directement sur entrée pour
sélectionner le registry npm par défaut</li>
<li><code>What is your npm username?</code> : entrez votre username npm</li>
<li><code>What is your npm password?</code> : entrez votre mot de passe npm</li>
<li><code>What is your GitHub username?</code> : entrez votre username GitHub</li>
<li><code>What is your GitHub password?</code> : entrez votre mot de passe GitHub</li>
<li><code>What is your GitHub two-factor authentication code?</code> : si vous avez activé
l'authentification à deux facteurs sur GitHub, entrez le code que vous aurez
reçu ici</li>
<li><code>What CI are you using?</code> : nous allons ici utiliser Travis CI, mais vous
pouvez utiliser ce que vous voulez si vous avez un système de CI particulier.
Pour la suite, il n'y a pas besoin de maîtriser Travis CI ni l'intégration
continue en soit. Je vous suggère juste de lire
<a href="http://putaindecode.io/fr/articles/ci/">l'article d'introduction</a> si
le concept d'intégration continue ne vous parle pas du tout</li>
<li><code>Do you want a .travis.yml file with semantic-release setup?</code> : Yes !</li>
</ul>
<p>Voilà, tout est configuré et prêt à être utilisé :</p>
<ul>
<li>Un script npm <code>semantic release</code> a été ajouté à votre <code>package.json</code></li>
<li>Le champs <code>version</code> de votre <code>package.json</code> a été modifié en
<code>0.0.0-development</code>. Vous n'aurez plus jamais à y toucher, c'est
semantic-release qui fera ce travail avant de publier chaque nouvelle version</li>
<li>Un fichier <code>.travis.yml</code> contenant la configuration Travis CI nécessaire a
été créé. Vous pouvez le modifier selon vos besoins. Dans l'immédiat, la chose
urgente est d'adapter la liste des versions de Node sur lesquelles Travis va
lancer vos tests</li>
<li>Votre repository doit être visible sur Travis CI, prêt à lancer un build
lorsque vous ferez un <code>git push</code></li>
<li>Un token npm a été ajouté au repository sur Travis CI, pour que celui-ci
puisse s'authentifier lorsqu'il voudra publier une nouvelle version</li>
</ul>
<p><em>Une petite note concernant Travis CI : le but de semantic-release étant
d'automatiser le processus de publication d'un module npm, celui-ci va tout
bonnement refuser de se lancer en dehors d'un environnement d'intégration
continue. Une configuration de base est fournie, il n'y a donc pas à se
soucier de ça, mais sans intégration continue, pas de semantic-release.
C'est pourquoi l'utilisation d'une plateforme d'intégration continue vous
est imposée.</em></p>
<p>Maintenant que tout est en place, il va falloir travailler un peu, faire
quelques commits afin d'arriver au point où on voudra publier une nouvelle
version. Disons que je travaille sur un module <code>math</code> qui implémente
actuellement les fonctions <code>add</code> et <code>substract</code>. Le module est actuellement en
version 1.0.0 sur npm, et un utilisateur m'a remonté un bug sur la fonction
<code>add</code> lorsqu'on souhaite additionner deux nombres décimaux. Je règle le
problème, et arrive le moment de faire le commit. Selon la convention que nous
avons vu un peu plus tôt, celui-ci devra ressembler à :</p>
<pre><code>fix(add): handle decimal numbers addition
</code></pre>
<p>Semantic-release pourra alors voir que ce commit est une correction de bug, qui
s'applique à la fonction add, et qui règle un problème d'addition sur des
nombres décimaux. Il pourra donc prendre la décision d'incrémenter la
composante <code>MINEUR</code> de la version du module.</p>
<p>Satisfait de mon travail pour aujourd'hui, je décide de m'arrêter là, et je
fais un <code>git push</code>. Travis CI déclenchera un build dès qu'il aura détecté ce
nouveau commit sur mon repository GitHub. Celui-ci va donc lancer mes tests, et
si ceux-ci passent, lancera le script npm créé lors du setup de
semantic-release (<code>npm run semantic-release</code>). Ce script va faire les choses
suivantes :</p>
<ol>
<li>Vérifier que les conditions d'exécution sont bonnes (par défaut, il vérifie
qu'on est bien sur Travis CI, sur la branche master et que tous les autres jobs
Travis CI sont bien terminés)</li>
<li>Récupérer le dernier numéro de version publié</li>
<li>Analyser les commits afin de déterminer le numéro de la nouvelle version</li>
<li>Publier la nouvelle version (mise à jour du champ <code>version</code> du
<code>package.json</code> puis <code>npm publish</code>)</li>
<li>Générer les notes de version</li>
<li>Créer un tag git ainsi que la release associée sur GitHub</li>
</ol>
<p>Une fois le build Travis CI terminé, je verrais donc la version <code>1.0.1</code> de
<code>math</code> publiée sur npm, un nouveau tag et une nouvelle release (avec les notes
qui y sont associées) disponibles sur GitHub.</p>
<p>Si je décide maintenant d'ajouter les fonctions <code>multiply</code> et <code>divide</code> à mon
module, et d'effectuer les deux commits suivants :</p>
<pre><code>feat(multiply): add multiply function
</code></pre>
<pre><code>feat(divide): add divide function
</code></pre>
<p>Semantic-release déterminera que le prochain numéro de version est <code>1.1.0</code>, et
fera le même travail que précédemment.</p>
<p>Enfin, si je décide d'implémenter une fonction spécifique pour l'addition de
deux nombre décimaux, je ferais le commit suivant :</p>
<pre><code>feat(add): split add function into addInts and addFloats

BREAKING CHANGE: add function has been removed. You must replace it with
addInts or addFloats
</code></pre>
<p>Semantic-release publiera dans ce cas la version <code>2.0.0</code>, parce qu'il détectera
(grâce au "BREAKING CHANGE") que ce commit contient des modifications non
rétrocompatibles. Il s'occupera aussi d'ajouter aux notes de version une liste
des changements non rétrocompatibles.</p>
<h2 id="si-vous-voulez-aller-un-peu-plus-loin"><a href="#si-vous-voulez-aller-un-peu-plus-loin" class="phenomic-HeadingAnchor">#</a>Si vous voulez aller un peu plus loin</h2>
<p>Nous avons jusqu'ici utilisé semantic-release avec tout ce qu'il propose par
défaut. Toutefois celui-ci est basé sur un système de plugins et peut donc être
personnalisé quasiment de A à Z. Je ne détaillerais pas tout ici, mais chaque
étape du processus qui se déroule au lancement du script npm <code>semantic-release</code>
ne fait qu'exécuter une liste de plugins qui peuvent tous être remplacés. Vous
pouvez ainsi implémenter votre propre logique pour chaque étape. Un exemple :
écrire un plugin pour la phase d'analyse des commits afin d'utiliser une
convention différente de celle d'Angular JS.</p>
<p><a href="https://github.com/semantic-release/semantic-release#plugins">La documentation</a>
explique bien comment écrire un plugin. Les possibilités sont virtuellement
infinies, libre à vous d'adapter semantic-release à votre façon de travailler et
vos envies.</p>
]]></description><link>http://putaindecode.io/fr/articles/semver/semantic-release/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/semver/semantic-release/</guid><pubDate>Tue, 21 Nov 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[La programmation reactive avec RxJS]]></title><description><![CDATA[<p>La <a href="https://www.reactivemanifesto.org/fr">programmation réactive</a> est un paradigme de programmation dont le concept repose sur l'émission de données depuis une ou plusieurs sources (producteurs) à destinations d'autres éléments appelés <em>consommateurs</em>. Elle repose sur le design pattern <a href="http://design-patterns.fr/observateur">Observable - Observer</a>.</p>
<p>Dans ce paradigme, on traite toutes les données, quelles qu'elles soient, de la même façon: au travers de flux. Un flux, c'est en gros une structure qui balance une ou plusieurs données dans le temps au travers d'observables, comme on l'a vu dans le <a href="/fr/articles/js/observable/">post précédent</a>.</p>
<p><img src="https://i.imgur.com/NLqK4bF.png" alt="Programmation Réactive"></p>
<p>Un flux, pour résumer, c'est simplement de la donnée qui arrive de manière ordonnée dans le temps. Comme expliqué précédemment, trois types de signaux peuvent être émis par un flux : une valeur, une erreur ou un signal de fin indiquant que le flux n'a plus de données à envoyer.</p>
<p>L'idée des flux, c'est cool, mais comment on manipule ça ?</p>
<h2 id="la-bibliothèque-rxjs"><a href="#la-biblioth%C3%A8que-rxjs" class="phenomic-HeadingAnchor">#</a>La bibliothèque RxJS</h2>
<p><a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/libraries/main/rx.md">RxJS</a> est l'implémentation JavaScript de <a href="http://reactivex.io/">ReactiveX</a>, <em>extensions-réactives</em> en français, un projet visant à implémenter sous la forme de bibliothèque les outils nécessaire pour utiliser le paradigme réactif dans de multiples languages.
Aussi appelé le <strong>Lodash</strong> des données asynchrones, il implémente la notion d'observables-observer et fournit tout un panel d'opérateurs pour travailler avec les données qui y passent.</p>
<p>Vous pourrez facilement intégrer progressivement Rx à votre codebase à l'aide d'opérateurs tels que <code>Rx.from</code> (qui crée un observable à partir d'une valeur synchrone), <code>Rx.fromEvent</code> (qui va carrément écouter les évenement DOM d'un élement pour en faire un observable), <code>Rx.fromPromise</code>, <code>Rx.Ajax</code> et bien d'autres.</p>
<p>Exemple tout simple : on va compter le nombre de clics sur un bouton.</p>
<pre><code class="hljs language-JavaScript"><span class="hljs-keyword">const</span> Rx = <span class="hljs-built_in">require</span>(<span class="hljs-string">'rxjs'</span>)

<span class="hljs-comment">// on écoute les clics</span>
<span class="hljs-keyword">const</span> button$ = Rx.Observable.fromEvent(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"button"</span>), <span class="hljs-string">"click"</span>)
  <span class="hljs-comment">// scan est l'équivalent de reduce ; il va garder l'accumulateur et retourner le nouveau à chaque clic</span>
  .scan(<span class="hljs-function"><span class="hljs-params">count</span> =></span> count + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)
  .subscribe(<span class="hljs-function"><span class="hljs-params">clickCount</span> =></span> {
    <span class="hljs-comment">// on met ça dans le DOM à chaque changement</span>
    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"count"</span>).innerHTML = <span class="hljs-string">"You clicked "</span> + clickCount + <span class="hljs-string">" times"</span>
  })</code></pre>
<p>Si vous vous demandez pourquoi <code>button$</code> et pas <code>button</code>, c'est que le suffixe <strong>$</strong> est une convention montrant qu'il s'agit d'un flux.</p>
<p>La programmation réactive peut être compliquée à se représenter, ainsi, pour mieux la visualiser, il existe les <a href="http://rxmarbles.com/"><code>marbles diagrams</code></a> qui vous permettront de mettre en rapport entrée et sortie de chaque transformation de la data avec une idée plus concrète que de simples bouts de code.</p>
<p>Le cœur de la programmation réactive, c'est de concevoir votre programme comme quelque chose qui est valable à n'importe quel point dans le temps, et c'est son avantage principal. Si une donnée change, toutes les parties de votre programme l'utilisant en seront notifiées et pourront agir en conséquence.</p>
<p>Si vos programmes récupèrent des données de manière asynchrone (et il y a de fortes chances pour que ce soit le cas), ça peut valoir le coup de jeter un œil à ce paradigme, vous pourrez peut-être vous enlever un paquet d'épines du pied.</p>
<p>Dans le prochain chapitre, nous verrons les cas d'usages des Observables au sein d'une application React/Redux.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/observable/programmation-reactive/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/observable/programmation-reactive/</guid><pubDate>Thu, 16 Nov 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Top 10 des snippets pour démolir le runtime JavaScript]]></title><description><![CDATA[<p>(ou juste faire une blague à vos collègues)</p>
<h2 id="10-larray-vide-magique"><a href="#10-larray-vide-magique" class="phenomic-HeadingAnchor">#</a>10. L'array vide magique</h2>
<p>Cette technique fonctionne grace à l'héritage prototypal et au fait que pour une obscure raison, <code>Array.prototype</code> est un array (qui hérite de lui même, allez savoir). Il suffit d'appeler une des méthodes mutatives d'<code>Array.prototype</code> sur lui-même :</p>
<pre><code class="hljs language-javascript"><span class="hljs-built_in">Array</span>.prototype.push(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</code></pre>
<p>Puisque dans le corps de <code>Array.prototype.push()</code>, <code>this</code> correspond à <code>Array.prototype</code>, c'est dans celui-ci que seront injectés les éléments.</p>
<pre><code class="hljs language-javascript">[][<span class="hljs-number">0</span>] <span class="hljs-comment">// 1</span></code></pre>
<p>Et hop. À noter que vu l'implémentation de la plupart des fonctions travaillant avec des <em>arrays</em>, ça devrait pas causer grand dommage puisque <code>length</code> est géré au niveau de l'array, et pas de son prototype. Ceci-dit ça peut surprendre en faisant mumuse dans la console.</p>
<h2 id="9-lobjet-magique"><a href="#9-lobjet-magique" class="phenomic-HeadingAnchor">#</a>9. L'objet magique</h2>
<p>Souvent, dans une boucle <code>for(name in object)</code>, on appelle <code>object.hasOwnProperty(name)</code> pour vérifier si la propriété appartient bien à l'objet et qu'il ne s'agit pas juste d'un truc hérité.</p>
<pre><code class="hljs language-javascript"><span class="hljs-built_in">Object</span>.prototype.hasOwnProperty = <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-literal">true</span>;
<span class="hljs-comment">// peut se combiner avec un petit</span>
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &#x3C; <span class="hljs-number">10</span>; index++) {
  <span class="hljs-built_in">Object</span>.prototype[index] = <span class="hljs-literal">undefined</span>;
};</code></pre>
<p>Même concept que pour l'exemple précédent, avec l'héritage prototypal. Le petit côté rigolo ici, c'est que c'est un pattern très courant en JavaScript, notamment dans les bibliothèques que vous utilisez probablement. Et c'est là qu'on se rend compte que de mettre la fonction qui vérifie si une propriété est héritée ou non dans l'héritage, c'est pas forcément l'idée du siècle.</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">let</span> object = {};
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> object) {
  <span class="hljs-keyword">if</span>(object.hasOwnProperty(object)) {
    <span class="hljs-built_in">console</span>.log(key)
  }
}
<span class="hljs-comment">// 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</span></code></pre>
<h2 id="8-le-dom-fou"><a href="#8-le-dom-fou" class="phenomic-HeadingAnchor">#</a>8. Le DOM fou</h2>
<p>Celui-là est plutôt sympa quand vous ou vos bibliothèques DOM de prédilection touchez un peu aux élements. Vu que l'appel à <code>Math.random()</code> rend l'opération aussi déterministe que l'application de styles assignés à des sélecteurs CSS chargés de manière asynchrone, vous risquez de jolies surprises.</p>
<pre><code class="hljs language-javascript">Element.prototype.appendChild = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>) </span>{
  <span class="hljs-keyword">return</span> Element.prototype.insertBefore.call(
    <span class="hljs-keyword">this</span>,
    element,
    <span class="hljs-keyword">this</span>.childNodes[<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-keyword">this</span>.childNodes.length)]
  )
};</code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &#x3C; <span class="hljs-number">10</span>; index++) {
  <span class="hljs-built_in">document</span>.body.appendChild(<span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-built_in">String</span>(index)))
};
<span class="hljs-comment">// "1895234760" (par exemple)</span></code></pre>
<h2 id="7-simple-mais-efficace-faire-de-la-console-une-no-op"><a href="#7-simple-mais-efficace-faire-de-la-console-une-no-op" class="phenomic-HeadingAnchor">#</a>7. Simple mais efficace, faire de la console une no-op</h2>
<p>Bizarrement, j'ai déjà vu des sites qui faisaient ça en production (e.g. Twitter si je me rappelle correctement). Vous rendez inopérable la console, ce qui peut faire une très bonne blague à vos collègues en cachant ça dans un vieux commit avec l'option <code>amend</code>.</p>
<pre><code class="hljs language-javascript"><span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">console</span>).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =></span> {
  <span class="hljs-built_in">console</span>[key] = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {}
});</code></pre>
<h2 id="6-supprimer-les-stack-traces-des-erreurs"><a href="#6-supprimer-les-stack-traces-des-erreurs" class="phenomic-HeadingAnchor">#</a>6. Supprimer les stack traces des erreurs</h2>
<p>Là, on est vraiment sur le petit truc horrible, parce que vous pouvez mettre un petit moment avant de le réaliser. Le constructeur <code>Error</code> vient normalement ajouter une propriété <code>stack</code> qui vous permet de retrouver le chemin qu'a emprunté le code avant de jeter une erreur. Eh ben fini, à vous le debug à l'aveugle !</p>
<pre><code class="hljs language-javascript">(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Error</span>(<span class="hljs-params">message</span>) </span>{
    <span class="hljs-keyword">this</span>.message = message;
  }
  <span class="hljs-built_in">Error</span>.prototype = <span class="hljs-built_in">window</span>.Error.prototype;
  <span class="hljs-built_in">window</span>.Error = <span class="hljs-built_in">Error</span>;
})();</code></pre>
<h2 id="5-rendre-lasynchrone-synchrone"><a href="#5-rendre-lasynchrone-synchrone" class="phenomic-HeadingAnchor">#</a>5. Rendre l'asynchrone synchrone</h2>
<p>Il est assez courrant d'avoir des <code>setTimeout(func)</code> ou <code>setTimeout(func, 0)</code> (les deux sont équivalents). Ça permet s'assurer qu'on décale un peu l'execution d'une fonction, et souvent de s'assurer que si elle jette une erreur, elle n'empêchera pas le reste de s'executer.</p>
<pre><code class="hljs language-javascript">(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {
  <span class="hljs-keyword">let</span> originalTimeout = <span class="hljs-built_in">window</span>.setTimeout;
  <span class="hljs-built_in">window</span>.setTimeout = <span class="hljs-function">(<span class="hljs-params">func, duration, ...args</span>) =></span> !duration ? func(...args) : originalTimeout.call(<span class="hljs-built_in">window</span>, func, duration, ...args);
})()</code></pre>
<p>Avec ce snippet, petites surprises bizarres assurées. Et c'est un bug présent dans quelques bibliothèques implémentant une fonction <code>domReady</code>, et qui font:</p>
<pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">domReady</span>(<span class="hljs-params">func</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.readyState === <span class="hljs-string">"complete"</span>) {
    func()
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">"DOMContentLoaded"</span>, func)
  }
}</code></pre>
<p>Avec une implémentation comme celle qu'on voit au dessus, <code>func</code> aura un comportement différent si le DOM est chargé ou non:</p>
<pre><code class="hljs language-javascript">domReady(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>()
})
<span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)
<span class="hljs-comment">// Logue 1 si le DOM est prêt, parce que l'execution de func par le handler DOMContentLoaded est asynchrone</span>
<span class="hljs-comment">// Logue rien du tout si func() est appelé en synchrone par la première branche de domReady</span></code></pre>
<h2 id="4-le-réseau-qui-ne-répond-jamais"><a href="#4-le-r%C3%A9seau-qui-ne-r%C3%A9pond-jamais" class="phenomic-HeadingAnchor">#</a>4. Le réseau qui ne répond jamais</h2>
<p>Les <code>Promise</code>, c'est bien relou à débugger lorsque ça reste infiniment en "pending": on ne sait pas forcément pourquoi, surtout si c'est derrière une API opaque, comme <code>fetch</code>. Plaisir garanti, parce qu'avec ça sur la page, c'est probablement le dernier endroit où on va intuitivement chercher la source la bug.</p>
<pre><code class="hljs language-javascript"><span class="hljs-built_in">window</span>.fetch = <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {})</code></pre>
<h2 id="3-faire-marcher-les-event-listener-au-hasard"><a href="#3-faire-marcher-les-event-listener-au-hasard" class="phenomic-HeadingAnchor">#</a>3. Faire marcher les event listener au hasard</h2>
<p>C'est particulièrement horrible quand un bug n'est pas reproduit à tous les coups: pourquoi ne pas attacher les évenements au hasard ?</p>
<pre><code class="hljs language-javascript">(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {
  <span class="hljs-keyword">let</span> originalAddEventListener = Element.prototype.addEventListener
  Element.prototype.addEventListener = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Math</span>.random() &#x3C; <span class="hljs-number">0.75</span>) {
      originalAddEventListener.call(<span class="hljs-keyword">this</span>, ...args)
    }
  };
})();</code></pre>
<pre><code class="hljs language-javascript"><span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">"click"</span>, () => <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>));
<span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">"click"</span>, () => <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>));
<span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">"click"</span>, () => <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>));
<span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">"click"</span>, () => <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>));
<span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">"click"</span>, () => <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>));</code></pre>
<h2 id="2-faire-foirer-parseint-de-temps-en-temps"><a href="#2-faire-foirer-parseint-de-temps-en-temps" class="phenomic-HeadingAnchor">#</a>2. Faire foirer parseInt de temps en temps</h2>
<pre><code class="hljs language-javascript">(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {
  <span class="hljs-keyword">let</span> originalParseInt = <span class="hljs-built_in">window</span>.parseInt;
  <span class="hljs-built_in">window</span>.parseInt = <span class="hljs-function">(<span class="hljs-params">n</span>) =></span> <span class="hljs-built_in">Math</span>.random() > <span class="hljs-number">0.9</span> ? originalParseInt(n) : <span class="hljs-literal">NaN</span>;
})()</code></pre>
<p>Pour un bon petit moment à pas comprendre ce qui se passe. Je suis sûr que <code>NaN</code> n'est pas toujours géré dans tous les cas dans la plupart des scripts qui tournent aujourd'hui en prod.</p>
<pre><code class="hljs language-javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"1"</span>) <span class="hljs-comment">// 1</span>
<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">"1"</span>) <span class="hljs-comment">// NaN</span></code></pre>
<h2 id="1-deserialiser-les-url"><a href="#1-deserialiser-les-url" class="phenomic-HeadingAnchor">#</a>1. (De)serialiser les URL</h2>
<p>Pour ce coup, c'est bien de prévoir les deux fonctions utilisées par tout le monde pour encoder et décoder les URLs. Vu que si l'une ne marche pas, le reflexe est souvent de tester la deuxième, bon arrachage de cheveux en perspective.</p>
<pre><code class="hljs language-javascript"><span class="hljs-built_in">window</span>.decodeURIComponent = <span class="hljs-built_in">window</span>.encodeURIComponent = <span class="hljs-built_in">window</span>.escape = <span class="hljs-built_in">window</span>.unescape = <span class="hljs-function">(<span class="hljs-params">a</span>) =></span> <span class="hljs-built_in">String</span>(a)</code></pre>
<h2 id="bonus-pour-rendre-tout-ça-crédible"><a href="#bonus-pour-rendre-tout-%C3%A7a-cr%C3%A9dible" class="phenomic-HeadingAnchor">#</a>Bonus: pour rendre tout ça crédible</h2>
<p>Si dans la console de développement, vous tapez le nom d'une fonction accessible dans le scope, le navigateur va appeler <code>Function.prototype.toString</code> sur cette fonction pour en récupérer l'allure. Couvrez vos arrières en replaçant la méthode :</p>
<pre><code class="hljs language-javascript"><span class="hljs-built_in">Function</span>.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">`function <span class="hljs-subst">${ <span class="hljs-keyword">this</span>.name || <span class="hljs-string">""</span> }</span>() {
    [native code]
}`</span>
}</code></pre>
<pre><code class="hljs language-javascript">(<span class="hljs-function"><span class="hljs-params">()</span> =></span> {})
<span class="hljs-comment">/* function () {
    [native code]
} */</span></code></pre>
<p>Pour faire un peu de zèle, vous pouvez également déclarer ces fonctions dans un <code>eval</code> pour brouiller les pistes sur l'endroit où elles ont été déclarées.</p>
<p>Voilà, vous avez toutes les clés pour faire des petites blagues à vos collègues.</p>
<p>Et n'oubliez pas, JavaScript c'est super, mais faisez gaffe quand même, parce que dans un langage encourageant la mutabilité, qui utilise des globales et de l'héritage par dessus le marché, il suffit d'un petit bout de code innocent pour que plus rien ne marche.</p>
<p>Bisous.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/top-10-snippets-demolir-runtime/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/top-10-snippets-demolir-runtime/</guid><pubDate>Mon, 13 Nov 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[ReasonReact, pour une UI qu'elle est bien typée]]></title><description><![CDATA[<p>Si comme moi, depuis l’apparition de React, vous vous êtes de plus en intéressés au typage pour vos applications front (c'est ça de commencer avec JS…), vous avez certainement utilisé les <code>propTypes</code> au début en vous disant "putain c'est cool de vérifier les types, ça m'évite bien des problèmes". Puis c’était sympa mais bon, faut quand même exécuter le bout de code qui pète et il est peut-être super chiant d'y accéder dans l'app. Du coup, vous vous êtes sûrement tournés vers Flow ou TypeScript.</p>
<p>Dans cet article, on va découvrir la <em>next-step</em> dans ce cheminement : écrire nos composants React dans un langage statiquement et fortement typé: Reason 🚀. Reason, c'est OCaml, avec son type-system puissant et une syntaxe plus simple quand on vient du JS. Si vous n’avez pas lu <a href="/fr/articles/reason/introduction-reason/">l’introduction à ce langage</a>, c’est le moment.</p>
<p>Là, je vais vous présenter <strong>ReasonReact</strong>, des bindings API par dessus React supportés officiellement par l'équipe de Reason. Facebook <em>dogfood</em> la solution puisqu'elle est utilisée sur messenger.com pour la majeure partie de ses composants.</p>
<h2 id="stateless"><a href="#stateless" class="phenomic-HeadingAnchor">#</a>Stateless</h2>
<p>Commençons par le traditionnel HelloWorld™ :</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/* Un composant ReasonReact se crée en deux temps: d'abord on crée le `component`
   à partir d’un appel à `statelessComponent` ou `reducerComponent` (il existe d'autres
   cas plus avancés, mais on s'y attardera pas dans cet article d'introduction). */</span>
<span class="hljs-keyword">let</span> component = ReasonReact.statelessComponent(<span class="hljs-string">"HelloWorld"</span>);

<span class="hljs-comment">/* Ensuite, on déclare une fonction `make` qui prend des arguments nommés
   (qui équivalent aux `props` de React) et un dernier argument non-nommé,
   contenant les `children`. Cette fonction doit retourner un record, dans
   lequel on spread notre `component` et dans lequel on définit une propriété
   `render` qui prend comme paramètre `self` (équivalent du `this`) et qui retourne
   un élément React. Là-dessus ça devrait pas trop vous chambouler de ce que
   vous connaissez de React.
   On peut remarquer que les props sont les arguments de la fonction `make`,
   comme avec les composants fonctionnels de React.*/</span>
<span class="hljs-keyword">let</span> make = <span class="hljs-function">(<span class="hljs-params">~message, _children</span>) =></span> {
  ...component,
  <span class="hljs-attr">render</span>: <span class="hljs-function">(<span class="hljs-params">_self</span>) =></span>
    &#x3C;div>
      (ReasonReact.stringToElement message)
    &#x3C;<span class="hljs-regexp">/div>
};</span></code></pre>
<p>Et pour monter le composant :</p>
<pre><code class="hljs language-js">ReactDOMRe.renderToElementWithId(<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">HelloWorld</span> <span class="hljs-attr">message</span>=<span class="hljs-string">"Helloworld"</span> /></span>, "root");</span></code></pre>
<p>Un des gros avantages à utiliser Reason, c’est que le langage est capable d’inférer la grande majorité des types et sera en mesure de détecter dans toute l’app si quelque chose n’est pas passé correctement : pour le langage, il s‘agit simplement de fonctions qui appellent d’autres fonctions, et les langages fonctionnels statiquement et fortement typés sont plutôt pas dégueulasses pour ça.</p>
<h2 id="stateful"><a href="#stateful" class="phenomic-HeadingAnchor">#</a>Stateful</h2>
<p>La petite particularité de ReasonReact vis à vis des composants stateful, c’est que les mises à jour d'états doivent passer par un reducer, comme si chaque composant embarquait sa petite implémentation de redux.</p>
<p>Maintenant, comment qu'on fait pour créer un composant stateful ?</p>
<p>On commence par définir le type du state : contrairement à JS, il ne s'agit pas forcément d'un objet, ça peut être une chaîne de caractère, un entier, un variant, un boolean, un arbuste, une map, un jus de fruits frais, un tableau, whatever.</p>
<pre><code class="hljs language-js">type state = {
  <span class="hljs-attr">counter</span>: int
};</code></pre>
<p>On va définir notre type action, sous la forme de variants: chaque variant représente un des type d’action possible. Pour bien se représenter ce qu'est une action, c’est un token, contenant possiblement des paramètres, qu’on va envoyer à notre fameux reducer qui, lui, retournera une réaction à cette action.</p>
<pre><code class="hljs language-js">type action =
  | Increment
  | Decrement;</code></pre>
<p>Dans le composant retourné par <code>make</code>, on ajoute une fonction <code>initialState</code> qui retourne… l'état initial (c'est bien, vous suivez), et une fonction <code>reducer</code>, qui effectue un pattern-matching sur l’action et retourne une update.
Cette fonction prend deux paramètres: l'<code>action</code> à traiter et le <code>state</code> à jour (comme lorsque l'on passe un callback à <code>setState</code> dans l'équivalent JavaScript <code>setState(state => newState)</code>).</p>
<p>L’update retournée indique au component comment il doit se mettre à jour (ici sont listés les cas courants) :</p>
<ul>
<li><code>NoUpdate</code>, pour ne rien faire</li>
<li><code>Update</code>, pour mettre à jour l’état et re-rendre le composant</li>
<li><code>SideEffect</code> pour lancer un effet de bord (e.g. une requête réseau)</li>
<li><code>UpdateWithSideEffect</code>, pour changer le state et lancer un effet de bord (e.g. afficher un loader et lancer une requête)</li>
</ul>
<p><em>Wrapping up</em> :</p>
<pre><code class="hljs language-js">type state = {<span class="hljs-attr">counter</span>: int};

type action =
  | Increment
  | Decrement;

<span class="hljs-comment">/* Il faut bien définir le `component` **après** les types `state` et `action`, pour qu'il puisse les lire */</span>
<span class="hljs-keyword">let</span> component = ReasonReact.reducerComponent(<span class="hljs-string">"Count"</span>);

<span class="hljs-keyword">let</span> make = <span class="hljs-function">(<span class="hljs-params">~initialCounter=<span class="hljs-number">0</span>, _</span>) =></span> {
  ...component,
  <span class="hljs-attr">initialState</span>: <span class="hljs-function"><span class="hljs-params">()</span> =></span> {<span class="hljs-attr">counter</span>: initialCounter},
  <span class="hljs-attr">reducer</span>: <span class="hljs-function">(<span class="hljs-params">action, state</span>) =></span>
    <span class="hljs-comment">/* Toutes mes updates passent par là, bien pratique pour qu'une
      personne puisse aborder rapidement le composant */</span>
    <span class="hljs-keyword">switch</span> action {
    | <span class="hljs-function"><span class="hljs-params">Increment</span> =></span> ReasonReact.Update({<span class="hljs-attr">counter</span>: state.counter + <span class="hljs-number">1</span>})
    | <span class="hljs-function"><span class="hljs-params">Decrement</span> =></span> ReasonReact.Update({<span class="hljs-attr">counter</span>: max(<span class="hljs-number">0</span>, state.counter - <span class="hljs-number">1</span>)})
    },
  <span class="hljs-attr">render</span>: <span class="hljs-function">(<span class="hljs-params">{state, reduce}</span>) =></span>
    &#x3C;div>
      (ReasonReact.stringToElement(state.counter |> string_of_int))
      <span class="hljs-comment">/* La fonction reduce prend une fonction qui retourne l'action.
           Il s'agit d'une fonction pour lire les propriétés des
           events (qui sont pooled dans React) de manière synchrone, alors
           que le reducer est appelé de manière asynchrone.
         */</span>
      &#x3C;button onClick=<span class="hljs-function">(<span class="hljs-params">reduce((_event</span>) =></span> Decrement))> (ReasonReact.stringToElement(<span class="hljs-string">"-"</span>)) &#x3C;<span class="hljs-regexp">/button>
      &#x3C;button onClick=(reduce((_event) => Increment))> (ReasonReact.stringToElement("+")) &#x3C;/</span>button>
    <span class="xml"><span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
};</code></pre>
<p>et hop:</p>
<pre><code class="hljs language-js">ReactDOM.renderToElementWithId(<span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">Count</span> <span class="hljs-attr">initialCount</span>=<span class="hljs-string">0</span> /></span>, "App");</span></code></pre>
<h2 id="with-side-effects"><a href="#with-side-effects" class="phenomic-HeadingAnchor">#</a>With side-effects</h2>
<p>Bien que ça puisse paraître un peu lourd de devoir faire un <code>reducer</code> pour gérer ses updates, ça apporte quand même:</p>
<ul>
<li>Un seul endroit par composant où toutes les updates passent</li>
<li>La possibilité pour le compiler de détecter si l'on oublie de gérer des actions</li>
<li>De gérer lisiblement et uniformément les effets de bord</li>
</ul>
<p><img src="./terminal.png" alt="" /></p>
<p>Exemple ici avec un composant où on va faire comme si on récupérait l'utilisateur connecté sur une API.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> resolveAfter = <span class="hljs-function">(<span class="hljs-params">ms</span>) =></span>
  Js.Promise.make(
    <span class="hljs-function">(<span class="hljs-params">~resolve, ~reject <span class="hljs-keyword">as</span> _</span>) =></span> ignore(Js.Global.setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =></span> [@bs] resolve(ms), ms))
  );

<span class="hljs-built_in">module</span> User = {
  type t = {<span class="hljs-attr">username</span>: string};
  <span class="hljs-comment">/* faisons comme si on avait un appel serveur
     (je le fais comme ça pour que vous puissiez copier/coller le code
     pour essayer chez vous) */</span>
  <span class="hljs-keyword">let</span> getUser = <span class="hljs-function">(<span class="hljs-params">_</span>) =></span>
    resolveAfter(<span class="hljs-number">1000</span>)
    |> Js.Promise.then_(
         <span class="hljs-function">(<span class="hljs-params">_</span>) =></span>
           Js.Promise.resolve({
             <span class="hljs-attr">username</span>: <span class="hljs-string">"MyUsername"</span> ++ string_of_int(Js.Math.random_int(<span class="hljs-number">0</span>, <span class="hljs-number">9999</span>))
           })
       );
};

<span class="hljs-comment">/* Le "user" distant peut avoir 4 états possibles ici */</span>
type resource(<span class="hljs-string">'a) =
  | Inactive
  | Loading
  | Idle('</span>a)
  | Errored;

type action =
  | Load
  | Receive(resource(User.t));

type state = {<span class="hljs-attr">user</span>: resource(User.t)};

<span class="hljs-keyword">let</span> component = ReasonReact.reducerComponent(<span class="hljs-string">"User"</span>);

<span class="hljs-keyword">let</span> getUser = <span class="hljs-function">(<span class="hljs-params">credentials, {ReasonReact.reduce}</span>) =></span>
  ignore(
    User.getUser(credentials)
    <span class="hljs-comment">/* Si tout s'est bien passé */</span>
    |> Js.Promise.then_(
         <span class="hljs-comment">/* On peut utiliser les actions en dehors du `make`: c'est juste des variants */</span>
         (payload) => Js.Promise.resolve(reduce(<span class="hljs-function">(<span class="hljs-params">payload</span>) =></span> Receive(Idle(payload)), payload))
       )
    <span class="hljs-comment">/* Si ça a merdé */</span>
    |> Js.Promise.catch(<span class="hljs-function">(<span class="hljs-params">_</span>) =></span> Js.Promise.resolve(reduce(<span class="hljs-function"><span class="hljs-params">()</span> =></span> Receive(Errored), ())))
  );

<span class="hljs-keyword">let</span> make = <span class="hljs-function">(<span class="hljs-params">~credentials, _</span>) =></span> {
  ...component,
  <span class="hljs-attr">initialState</span>: <span class="hljs-function"><span class="hljs-params">()</span> =></span> {<span class="hljs-attr">user</span>: Inactive},
  <span class="hljs-attr">reducer</span>: <span class="hljs-function">(<span class="hljs-params">action, _state</span>) =></span>
    <span class="hljs-keyword">switch</span> action {
    <span class="hljs-comment">/* UpdateWithSideEffects met à jour l'état, puis lance l'effet de bord,
       très pratique pour ce genre de cas */</span>
    | <span class="hljs-function"><span class="hljs-params">Load</span> =></span> ReasonReact.UpdateWithSideEffects({<span class="hljs-attr">user</span>: Loading}, getUser(credentials))
    | Receive(user) => ReasonReact.Update({<span class="hljs-attr">user</span>: user})
    },
  <span class="hljs-attr">didMount</span>: <span class="hljs-function">(<span class="hljs-params">{reduce}</span>) =></span> {
    reduce(<span class="hljs-function"><span class="hljs-params">()</span> =></span> Load, ());
    ReasonReact.NoUpdate
  },
  <span class="hljs-attr">render</span>: <span class="hljs-function">(<span class="hljs-params">{state, reduce}</span>) =></span>
    &#x3C;div>
      (
        ReasonReact.stringToElement(
          <span class="hljs-keyword">switch</span> state.user {
          | Inactive
          | <span class="hljs-function"><span class="hljs-params">Loading</span> =></span> <span class="hljs-string">"Loading ..."</span>
          | Idle(user) => <span class="hljs-string">"Hello "</span> ++ user.username
          | <span class="hljs-function"><span class="hljs-params">Errored</span> =></span> <span class="hljs-string">"An error occured"</span>
          }
        )
      )
      &#x3C;div>
        <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">button</span>
          <span class="hljs-attr">disabled</span>=<span class="hljs-string">(</span>
            <span class="hljs-attr">switch</span> <span class="hljs-attr">state.user</span> {
            | <span class="hljs-attr">Idle</span>(<span class="hljs-attr">_</span>) =></span> Js.false_
            | _ => Js.true_
            }
          )
          onClick=(reduce((_) => Load))>
          (ReasonReact.stringToElement("Reload"))
        <span class="hljs-tag">&#x3C;/<span class="hljs-name">button</span>></span></span>
      &#x3C;<span class="hljs-regexp">/div>
    &#x3C;/</span>div>
};</code></pre>
<h2 id="oui-mais-est-ce-que-je-peux-lutiliser-aujourdhui-alors-que-jai-déjà-une-grosse-codebase-react-"><a href="#oui-mais-est-ce-que-je-peux-lutiliser-aujourdhui-alors-que-jai-d%C3%A9j%C3%A0-une-grosse-codebase-react-" class="phenomic-HeadingAnchor">#</a>Oui mais est-ce que je peux l'utiliser aujourd'hui alors que j'ai déjà une grosse codebase React ?</h2>
<p><img src="./tenor.gif" alt="" /></p>
<p>Pour utiliser des composants ReasonReact avec React</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">let</span> jsComponent =
  ReasonReact.wrapReasonForJs(
    ~component,
    (jsProps) =>
      make(
        ~credentials=jsProps##credentials,
        [||]
      )
  );</code></pre>
<p>et</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> MyComponent = <span class="hljs-built_in">require</span>(<span class="hljs-string">"path/to/reason/output"</span>).jsComponent;</code></pre>
<p>À l'inverse, pour utiliser des composants React avec ReasonReact</p>
<pre><code class="hljs language-js">[@bs.module <span class="hljs-string">"path/to/good/old/reactjs/component"</span>] external myJsComponent : ReasonReact.reactClass = <span class="hljs-string">"default"</span>;

<span class="hljs-keyword">let</span> make = <span class="hljs-function">(<span class="hljs-params">~message: string, _children</span>) =></span>
  ReasonReact.wrapJsForReason(
    ~reactClass=myJsComponent,
    ~props={<span class="hljs-string">"message"</span>: message},
    [||]
  );</code></pre>
<p>Voilà pour les <em>basics</em> de ReasonReact. Pour en savoir plus, y a <a href="https://reasonml.github.io/reason-react/">la petite doc qui va bien</a>, et on vous préparera un petit article sur les aspects un peu plus avancés de l'usage.</p>
<p>Bisous bisous.</p>
]]></description><link>http://putaindecode.io/fr/articles/reason/reasonreact/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/reason/reasonreact/</guid><pubDate>Thu, 09 Nov 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Développer avec Create React App et une API Node.js]]></title><description><![CDATA[<h2 id="tldr"><a href="#tldr" class="phenomic-HeadingAnchor">#</a>tl;dr</h2>
<p>Dans un environnement de développement, pour lancer dans le même temps votre application React et une API basée sur Node.js, vous pouvez imbriquer judicieusement les deux dépôts Git, puis utiliser un script NPM et quelques packages bien pratiques tels que <em>concurrently</em> et <em>nodemon</em> pour lancer les deux serveurs d'une seule commande. Pratique ! D'autant que pour contourner les restrictions d'accès liées à la <a href="https://fr.wikipedia.org/wiki/Same-origin_policy"><em>politique de même origine</em></a>, <strong>create-react-app</strong> permet le paramétrage d'un <em>proxy</em> pour vos requêtes API.</p>
<h2 id="est-ce-que-ça-me-concerne-"><a href="#est-ce-que-%C3%A7a-me-concerne-" class="phenomic-HeadingAnchor">#</a>Est-ce que ça me concerne ?</h2>
<p>La généralisation des architectures dites "API first" répond à des impératifs humains et techniques très divers. En ce qui concerne l'organisation du travail des développeurs, c'est l'assurance de pouvoir scinder l'implémentation de l'accès aux données -aux ressources- d'une part, et le travail sur l'UI/UX, d'autre part. Un premier groupe peut concevoir une API robuste et proposer un "contrat" clair à l'équipe <em>frontend</em> qui accède aux données avec un référentiel unique, que l'application soit web ou mobile.</p>
<p>De cette façon, la conception de l'interface utilisateur est libérée d'une grande partie des contraintes qui régissent les architectures MVC traditionnelles. Le développeur peut ainsi mieux se concentrer sur la qualité de sa réponse aux spécifications fonctionnelles.</p>
<p>Si l'architecture de votre projet est de ce type, et que vous attaquez la conception d'un frontend <a href="https://fr.wikipedia.org/wiki/Application_web_monopage">SPA</a> React avec <a href="https://github.com/facebookincubator/create-react-app">create-react-app</a> (quelle bonne idée !), ce qui suit peut vous éclairer. Nous allons voir comment il est possible d'accéder sans se compliquer la vie à une API RESTful basée sur Node.js, en imbriquant correctement ses dépôts.</p>
<h2 id="deux-dépôts--le-frontend-lapi"><a href="#deux-d%C3%A9p%C3%B4ts--le-frontend-lapi" class="phenomic-HeadingAnchor">#</a>Deux dépôts : le frontend, l’API</h2>
<p>Le principe est le suivant : vous ne souhaitez pas forcément modifier l'API qui est implémentée par une autre équipe, ou par un collègue, mais vous devez y accéder facilement depuis votre application React.</p>
<p>Vous allez pour cela devoir travailler sur deux dépôts Git clonés : celui du <em>frontend</em> React contiendra par exemple celui de l'API, et un <em>script NPM</em> se chargera de lancer les deux applications, sur deux ports différents.</p>
<p><em>Faut-il utiliser un framework en particulier pour le backend ?</em><br>
Absolument pas ! Pour ma part je travaille plus volontiers avec <a href="https://loopback.io/">LoopBack</a>, mais tout ce que qui s'appuie sur Node.js fait l'affaire.</p>
<h2 id="organisation-locale-du-code"><a href="#organisation-locale-du-code" class="phenomic-HeadingAnchor">#</a>Organisation locale du code</h2>
<p>Mettons que votre projet React s'appelle <strong>my-react-frontend</strong> et que l'API qu'il consomme répond au doux nom de <strong>my-node-api</strong>.</p>
<p><strong>my-react-frontend</strong> est cloné à la racine, c'est le projet parent. Il contient au moins les répertoires <code>src/</code>, <code>public/</code> et <code>node_modules/</code> générés par <em>create-react-app</em>.</p>
<p><code>build/</code> peut également être présent si vous avez déjà lancé au moins une fois la commande <code>npm run build</code>.</p>
<p>A la racine de <strong>my-react-frontend</strong>, clonez le dépôt <strong>my-node-api</strong>.</p>
<p>Vous devez obtenir :</p>
<pre><code>my-react-frontend/
-- my-node-api/
-- node_modules/
-- public/
-- src/
...
</code></pre>
<p>Ne nous attardons pas trop sur <code>my-node-api</code>, qui peut être implémenté de très nombreuses manières. Partons du principe qu'une fois lancé, le serveur expose les ressources dont votre application a besoin sur <code>http://localhost:3001</code>. Et disons juste que si l'équipe <em>backend</em> vous signale une mise à jour, vous ferez simplement :</p>
<pre><code class="hljs language-Shell">cd my-node-api/
git pull</code></pre>
<p><em>Faut-il forcément organiser les dépôts de cette façon ?</em><br>
Pas du tout. Mais l'intérêt de cette configuration, c'est que le <em>backend</em> est "dans sa bulle" et que les développeurs qui le font évoluer n'ont pas à organiser le code en fonction de ce <em>frontend</em> en particulier.</p>
<p>Dernière chose importante : pensez à ajouter <code>my-node-api/</code> au fichier <code>.gitignore</code> du projet React. Il ne faudrait évidemment pas qu'il versionne le <em>backend</em>.</p>
<h2 id="passez-moi-sur-le-cors"><a href="#passez-moi-sur-le-cors" class="phenomic-HeadingAnchor">#</a>Passez moi sur le CORS</h2>
<p>En production, il est fréquent d'utiliser le même serveur pour servir l'application React et l'API sous-jacente. Dans cette configuration, le mécanisme de <em>Cross-origin resource sharing</em> (<a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a>), basé sur des headers HTTP, n'a pas à être implémenté.</p>
<p>En développement, par contre, il est plus pratique de dissocier les serveurs pour bénéficier de toutes les fonctionnalités de l'écosystème React.</p>
<p>Pour répondre à cette contrainte, <em>create-react-app</em> propose <a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#proxying-api-requests-in-development">un mécanisme</a> qui permet de mettre en place un <strong>proxy</strong> d'API.</p>
<p>En partant du principe que votre frontend écoute sur le port 3000, et le serveur API sur le port 3001, il suffit d'ajouter un paramètre au premier niveau du <code>package.json</code> :</p>
<pre><code class="hljs language-json">{
  <span class="hljs-attr">"proxy"</span>: <span class="hljs-string">"http://localhost:3001"</span>,
}</code></pre>
<p>De cette façon, vous pourrez utiliser un chemin relatif pour accéder à vos ressources. Si une requête ne concerne pas un <em>asset</em> statique, elle sera relayée vers votre <em>backend</em>. <code>fetch('/api/bananas')</code>, par exemple, requêtera notre API sur <code>http://localhost:3001/api/bananas</code>.</p>
<h2 id="tout-lancer-en-une-seule-commande"><a href="#tout-lancer-en-une-seule-commande" class="phenomic-HeadingAnchor">#</a>Tout lancer en une seule commande</h2>
<p>Nous utiliserons pour cela un script NPM défini dans le <code>package.json</code> situé à la racine du projet React.</p>
<p>Deux petits outils seront nécessaires pour créer le script <em>ad hoc</em> :</p>
<ul>
<li>le package <a href="https://www.npmjs.com/package/concurrently"><code>concurrently</code></a> qui permet de lancer plusieurs scripts en une seule commande. Faites par exemple un <code>npm install --save-dev concurrently</code>.</li>
<li>le package <a href="https://www.npmjs.com/package/nodemon"><code>nodemon</code></a> qui scrute votre <em>backend</em> Node.js et relance le serveur automatiquement en cas de modification du code. Faites donc un <code>npm install --save-dev nodemon</code>, vous ne le regretterez pas.</li>
</ul>
<p>Tout est prêt ! Ouvrez <code>package.json</code> et ajoutez dans les <code>scripts</code>:</p>
<pre><code class="hljs language-json"><span class="hljs-string">"start-with-api"</span>: <span class="hljs-string">"concurrently \"react-scripts start\" \"PORT=3001 nodemon ./my-node-api/server/server.js\""</span></code></pre>
<p>Le chemin d'accès au script serveur est à adapter en fonction de vos propres choix techniques ! Notez que dans ce cas précis, on passe une variable d'environnement <code>PORT</code> que le script serveur utilise pour écraser son port d'écoute par défaut.</p>
<p>Au final, le <code>package.json</code> doit ressembler à ceci :</p>
<pre><code class="hljs language-json">{
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"my-react-frontend"</span>,
  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"0.1.0"</span>,
  <span class="hljs-attr">"private"</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">"proxy"</span>: <span class="hljs-string">"http://localhost:3001"</span>,
  <span class="hljs-attr">"scripts"</span>: {
    <span class="hljs-attr">"start"</span>: <span class="hljs-string">"react-scripts start"</span>,
    <span class="hljs-attr">"start-with-api"</span>: <span class="hljs-string">"concurrently \"react-scripts start\" \"PORT=3001 nodemon ./my-node-api/server/server.js\""</span>,
    <span class="hljs-attr">"build"</span>: <span class="hljs-string">"react-scripts build"</span>,
    <span class="hljs-attr">"test"</span>: <span class="hljs-string">"react-scripts test --env=jsdom"</span>,
    <span class="hljs-attr">"eject"</span>: <span class="hljs-string">"react-scripts eject"</span>
  },
  <span class="hljs-attr">"devDependencies"</span>: {
    <span class="hljs-attr">"react-scripts"</span>: <span class="hljs-string">"1.0.14"</span>,
    <span class="hljs-attr">"concurrently"</span>: <span class="hljs-string">"3.5.0"</span>,
    <span class="hljs-attr">"nodemon"</span>: <span class="hljs-string">"1.12.1"</span>
  },
  <span class="hljs-attr">"dependencies"</span>: {
    <span class="hljs-attr">"react"</span>: <span class="hljs-string">"^16.0.0"</span>,
    <span class="hljs-attr">"react-dom"</span>: <span class="hljs-string">"^16.0.0"</span>
  }
}</code></pre>
<p>Pour mémoire, nous n'avons ajouté que deux lignes : "proxy" et "scripts/start-with-api".</p>
<h2 id="une-astuce-pour-les-pressés"><a href="#une-astuce-pour-les-press%C3%A9s" class="phenomic-HeadingAnchor">#</a>Une astuce pour les pressés</h2>
<p>Si le backend ne joue pas un grand rôle dans votre application ou si -plus probablement- vous souhaitez démarrer sans attendre que le véritable backend soit disponible, je vous conseille de tester l'excellent <a href="https://github.com/typicode/json-server"><code>json-server</code></a>.</p>
<p>Cet élégant package offre la possibilité de créer un fichier JSON avec quelques données factices (<em>data fixtures</em>) et de les mettre à disposition de votre application à la façon d'une API RESTful, grâce à un simple <code>json-server --watch db.json</code>.</p>
<p>Il va sans dire qu'en modifiant légèrement le script <em>start-with-api</em>, vous disposerez en quelques secondes d'un <em>backend</em> au poil pour votre nouvelle application.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/react/create-react-app-et-api/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/react/create-react-app-et-api/</guid><pubDate>Tue, 07 Nov 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Introduction à l'Overlay Manager Service, expliqué par quelqu'un qui n'y connaît rien]]></title><description><![CDATA[<blockquote>
<p>DISCLAIMER : J'entrave pas un keyword de Java, j'ai jamais développé une seule app native, et plus globalement, je ne connais vraiment pas mon sujet. Ainsi, si quelqu'un s'y connaissant mieux que moi passe par là, qu'il n'hésite surtout pas à me corriger et à m'afficher devant la planète entière, j'ai besoin de nourrir mon syndrome de l'imposteur.</p>
</blockquote>
<p>Salut les copains aujourd'hui tonton FoetusBoy (SkinnyFoetusDaron) (moi) va vous parler d'un sujet qu'il ne connaît pas et qui s'insèrera à ce titre aux côtés d'autres sujets qu'il ne connaît pas tels que la joie de vivre, les souvenirs des jours joyeux et comment ne pas parler de soi à la troisième personne.</p>
<p>Ouvrez vos calepins à la page bullshit, on va faire un cours sur l'Overlay Manager Service (ou OMS) d'Android, sur comment ça fonctionne et comment vous allez pouvoir l'utiliser pour faire des trucs moches.</p>
<figure>
  <img src="OMS-moche.png" alt="hahaha comment c'est trop moche" />
  <figcaption>J'ai séché les cours de théorie des couleurs</figcaption>
</figure>
<p>Okay alors maintenant que vos rétines sont perpétuellement démolies par cette capture d'écran et que votre curiosité est piquée au vif, on attaque le cours d'histoire.
Fin 2015, deux ingénieurs de chez Sony Mobile, Mårten Kongstad et Martin Wallgren, que j'identifie à 99% de chances comme étant probablement tous les deux Suédois (et qui illustrent bien l'inventivité de ce peuple lorsqu'il s'agit de trouver toutes les façons de nommer quelqu'un Martin), coécrivent un commit dans l'AOSP (Android Open-Source Project), sous le chouette identifiant "OMS: introduce the OverlayManagerService". Cet événement est chouette pour deux raisons :</p>
<ul>
<li>La première est qu'Android étant malgré le contrôle de Google un projet open-source, c'est toujours intéressant de voir les constructeurs participer un peu au projet (les mauvaises langues diront que seul Sony joue vraiment le jeu de l'open-source et les mauvaises langues n'auraient pas vraiment tort).</li>
<li>La deuxième est que ça marque l'arrivée sur Android d'un véritable système de theming (thématisation en Français, donc je vais dire theming plutôt hein), permettant ainsi aux constructeurs d'implémenter leurs customisations de façon beaucoup plus souple et surtout aux initiés (moi et bientôt vous) de s'amuser un peu.</li>
<li>Troisième raison (bonus) : C'était bientôt Noël et cette année-là on m'avait offert un joli manteau.</li>
</ul>
<p>Commençons. Comme son nom l'indique si vous parlez la langue de Jay-Z, l'Overlay Manager Service est un service de gestion de surcouches.</p>
<figure>
  <img src="jayz.png" alt="" />
  <figcaption>Si votre Google Translate n'a pas l'option de traduction de Jay-Z vers Molière c'est que vous n'avez pas souscrit à un abonnement Translate Gold</figcaption>
</figure>
<p>L'OMS est lui-même le successeur du RRO, pour "Runtime Resource Overlay", ancien système propriétaire de Sony Mobile, utilisé en interne pour déployer et paramétrer rapidement leur surcouche à Android en fonction des demandes et besoins des opérateurs et des mises à jour d'Android lui-même ou bien pour faire fonctionner les Thèmes Xperia (on connaît Sony assez friands de la customisation par les utilisateurs depuis la sortie de la PS3, surtout quand il s'agit de vendre des thèmes à 25$).</p>
<p>Ce Runtime Resource Overlay (surcouches de ressources à l'exécution) s'opposait à l'outil Static Resource Overlay (surcouches de ressources statiques), un flag du packager d'Android (aapt) qui était comme qui dirait "bien mais pas top" : il permettait de séparer le code source d'une application de sa surcouche pour garder une base de travail propre (bien) mais ces surcouches ne pouvaient être installées qu'à la compilation de l'app, les rendant donc chiantes à débugger et nécessitaient plus ou moins qu'on soit le vendor original de l'application à modifier (pas top). Le principal intérêt du RRO était donc de faire sauter ces "barrières".</p>
<p>Voyant donc que l'un des principaux reproches faits à Android, à raison ou à tort (à raison hein, on va pas se mentir) était sa fragmentation et que l'un de ses facteurs (mais non le seul) était lié aux <em>vendors</em> (Samsung.) mettant trop de temps à recoder leur surcouche de A à Z à chaque version d'Android (et que de toute façon pourquoi s'emmerder à mettre à jour un téléphone gratuitement alors que tu peux en vendre un nouveau pour 700 pétrodollars <em>allez achète, vil consommateur</em> ?) les braves petits ingés de chez Sony ont préféré faire une petite PR sympa du côté de l'AOSP pour ajouter ce système de surcouches en natif dans Android.
Resté dormant pendant quelques temps, l'OMS a enfin été activé de façon officielle (à peu près) par Google, lors de la sortie d'Android 8.0 Oreo, qui en tire une utilité assez basique mais prometteuse : changer littéralement une seule couleur dans l'interface, spécifiquement pour les téléphones Pixel.</p>
<figure>
  <img src="epoustouflan.png" alt="époustouflan" />
  <figcaption>époustouflan</figcaption>
</figure>
<p>Ça peut paraître peu mais c'est finalement ce genre de modifications à la con qui peut considérablement ralentir le portage d'une nouvelle version d'Android sur un device existant. Ouvrons un peu le ventre de la bête.</p>
<p>Un overlay, ça fonctionne assez simplement. Il prend la forme d'un Android PacKage (ci-après APK), le format standard des applications Android, genre de point JAR survitaminé, qu'il conviendra donc de signer s'il vous plaît merci c'est important bonne journée, si vous comptez l'installer par vous-même en dehors de l'IDE consacré (Android Studio, donc). De par sa nature d'APK, un overlay devra donc contenir un AndroidManifest.xml, sorte de package.json si je devais faire une équivalence avec le dev web, cet AndroidManifest donc, qui prendra la forme suivante :</p>
<pre><code>&#x3C;?xml version="1.0" encoding="utf-8" standalone="no"?>
&#x3C;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="LePetitNomDeMonPackage">
    &#x3C;overlay android:priority="1000" android:targetPackage="LePetitNomDuPackageCible"/>
&#x3C;/manifest>
</code></pre>
<p>Mettons les points sur les i et définissons immédiatement ce qu'un overlay n'est pas :
un overlay n'est <em>pas</em> une extension d'application, il ne peut en aucun cas rajouter des fonctionnalités à une application existante, de la même manière que vous galéreriez à rajouter des features à un site existant juste en modifiant son CSS. En somme, à peu de choses près, un overlay se réduit à une feuille de style où toutes les déclarations seraient faites avec <code>!important</code> et comme on aime les bonnes pratiques bien maintenables chez PutainDeCode on vous rappellera de ne <em>JAMAIS</em> faire ça s'il vous plaît.</p>
<p>Là où la comparaison s'arrête c'est que contrairement à CSS, les ressources d'une application ne comprennent pas que les couleurs et occasionnellement les dimensions des blocs, mais peuvent renfermer les icônes, les sons, les images, et à peu près tout ce que le développeur original a voulu foutre dedans.</p>
<p>En résumé, rajouter une feature pour envoyer des SMS depuis votre lecteur de musique : c'est non; remplacer toutes les couleurs d'une appli par du rose, les typos par du Comic Sans MS et les sons d'interactions par le bruit d'un canard qui fait "Coin coin" : c'est oui.</p>
<p>D'ailleurs on va rendre l'application Calculatrice (dont le nom de package est "com.google.android.calculator", ça servira plus tard) toute rose parce que pourquoi pas.
En décompilant donc l'APK à l'aide de notre fidèle <a href="https://ibotpeaches.github.io/Apktool/">apktool</a>, nous voilà dans le cœur du code, dans la matrice, dans la mer numérique, bref, dans un sacré paquet de fichiers XML.</p>
<figure>
  <img src="chosenOne.png" alt="Mes collègues détestent que je dise I'm in à chaque fois que je fais un git pull" />
  <figcaption>*hacker voice* I'm in</figcaption>
</figure>
<p>Selon toute logique, la gestion des couleurs de l'app va probablement se retrouver dans un fichier qui s'appelle à peu près <code>colors.xml</code>, ce qui n'est pas étonnant parce que c'est comme ça qu'on nomme ses fichiers quand on veut s'y retrouver, j'ai appris ça à l'école quand je mettais des gommettes sur mes cahiers.
Il s'agit donc maintenant de voir ce à quoi sert chaque valeur dans ce fichier. Si vous arrivez à déduire le code hexa d'une couleur juste en la regardant, félicitations, vous êtes probablement un Terminator. Pour ceux qui ne sont pas des robots tueurs venus du turfu, faire une capture d'écran de l'application et ouvrir celle-ci dans Photoshop fonctionne très bien aussi.</p>
<figure>
  <img src="colors.png" alt="Featuring l'outil pipette de Photoshop, on applaudit l'outil pipette de Photoshop" />
  <figcaption>Devinez à quel moment j'en ai eu marre de faire de belles flèches bien droites</figcaption>
</figure>
<p>Les trois valeurs nous intéressant sont donc <code>pad_advanced_background_color</code>, <code>pad_numeric_background_color</code> et <code>pad_operator_background_color</code> qui sont finalement assez bien nommées. Vous remarquerez que les couleurs sont au format #aarrggbb et non pas #rrggbb, donc faites gaffe quand vous tripotez ça et que vous remplacez les couleurs par du rose (j'ai choisi le Bubblegum Pink de Pantone mais si vous préférez d'autres teintes de rose, libre à vous). Il s'agit maintenant de créer un nouveau fichier colors.xml dans notre <a href="https://github.com/skinnyfoetusboy/OMS-template">template OMS</a> qu'on va remplir ainsi :</p>
<pre><code class="hljs language-xml"><span class="php"><span class="hljs-meta">&#x3C;?</span>xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"utf-8"</span><span class="hljs-meta">?></span></span>
<span class="hljs-tag">&#x3C;<span class="hljs-name">resources</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"pad_advanced_background_color"</span>></span>#fff4cbd4<span class="hljs-tag">&#x3C;/<span class="hljs-name">color</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"pad_numeric_background_color"</span>></span>#fff4cbd4<span class="hljs-tag">&#x3C;/<span class="hljs-name">color</span>></span>
    <span class="hljs-tag">&#x3C;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"pad_operator_background_color"</span>></span>#fff4cbd4<span class="hljs-tag">&#x3C;/<span class="hljs-name">color</span>></span>
<span class="hljs-tag">&#x3C;/<span class="hljs-name">resources</span>></span></code></pre>
<p>Puis nous pouvons enfin compiler notre chef d'œuvre (toujours avec apktool) puis l'installer sur notre appareil, non sans l'avoir <a href="https://stackoverflow.com/questions/10930331/how-to-sign-an-already-compiled-apk">au préalable signé</a>, puis enfin de l'appliquer via la commande</p>
<pre><code>adb shell cmd overlay enable [le namespace de votre package que vous avez spécifié dans AndroidManifest.xml, moi par exemple c'est "com.sfb.pinkcalc"]
</code></pre>
<p>(il faut que votre téléphone soit en mode Développeur et que vous tourniez sous Android Oreo minimum sinon ça ne marchera pas, pas la peine de me demander pour faire marcher ça sur votre téléphone si vous êtes sous Gingerbread, tout ce que je ferai ce sera me moquer de vous).</p>
<p>Admirons ce merdier, maintenant.</p>
<figure>
  <img src="fuckthatspink.png" alt="Sans rire, depuis l'écriture de cet article j'ai pas désactivé cet overlay, j'aime vraiment le look que ça donne à l'app calculatrice" />
  <figcaption>Absolument splendide.</figcaption>
</figure>
<p>C'est à peu près tout pour l'OMS, pour les bases du moins, n'hésitez surtout pas à décompiler toutes les apps que vous trouvez pour voir un peu comment ça marche à l'intérieur, c'est aussi pour ça que c'est cool Android. Allez faire vos propres trucs moches maintenant.
<em>Ciao.</em></p>
]]></description><link>http://putaindecode.io/fr/articles/android/overlaymanagerservice/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/android/overlaymanagerservice/</guid><pubDate>Thu, 02 Nov 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Se lancer dans le TDD]]></title><description><![CDATA[<h2 id="introduction"><a href="#introduction" class="phenomic-HeadingAnchor">#</a>Introduction</h2>
<p>Tout commence en octobre 1999 lorsque <a href="https://fr.wikipedia.org/wiki/Kent_Beck">Kent Beck</a>
présente une nouvelle méthode de programmation agile : l'eXtreme Programmming abrégé <em>XP</em>.<br>
l'<em>XP</em> définit des pratiques de développement optimisées qui améliorent la production et
la robustesse du code.<br>
Parmi les principes les plus connus de sa méthode on pourra citer <strong>l'intégration continue</strong>
aussi appelée <em>CI</em> pour <em>Continuous Integration</em> et <strong>la programmation en binôme</strong>
ou <em>pair programming</em> en anglais.</p>
<p>L'aspect qui nous intéresse ici est un autre pilier de la méthode qui consiste à piloter
le développement par les tests alias <em>TDD</em>.</p>
<p>Le TDD est une pratique controversée car coûteuse à mettre en place.
Popularisée par les développeurs elle peine à émerger.</p>
<p>Avec la multiplication des environnements d'execution, la complexité des applications web
et l'essor des projets Open-source, les développeurs se heurtent à des problèmes de
compatibilités croisées et d'inconsistances.<br>
Aujourd’hui les standards sont de plus en plus permissifs et favorisent
ainsi les comportements à risque. La plupart du temps, les systèmes sont capables de
corriger vos erreurs, des fois sans même vous en avertir.</p>
<p>Dans ce contexte :</p>
<ul>
<li>Comment écrire un code multi-plateforme fonctionnel ?</li>
<li>Comment être sûr que les ajouts ne cassent pas le code plus ancien ?</li>
<li>Comment être sûr que le code se comporte comme voulu ?</li>
</ul>
<p>Commencer par vous imposer des pratiques de développement rigoureuses est impératif
mais les tests seront un complément indispensable à la qualité de votre code.</p>
<p>Heureusement, le TDD apporte alors une réponse élégante à l'ensemble de ces problématiques.</p>
<h2 id="tdd-vous-avez-dit-tdd-"><a href="#tdd-vous-avez-dit-tdd-" class="phenomic-HeadingAnchor">#</a>TDD, vous avez dit TDD ?</h2>
<p>Le Test Driven Development <em>(Développement Dirigé par les Tests)</em>,
est une technique de développement qui impose l’écriture de tests
avant même l’écriture de la première ligne de code.</p>
<p>Dans la théorie, la méthode requiert l’intervention d’au moins
deux intervenants différents, une personne écrit les tests, l’autre
le code testé. Cela permet d’éviter les problèmes liés à la subjectivité.</p>
<p>Dans la pratique les choses sont plus compliquées,
parfois on développe seul ou on écrit soi-même les tests qui
garantissent l’intégrité d'une nouvelle fonctionnalité dans un projet collaboratif.</p>
<blockquote>
<p>Quoi qu’il arrive, un test peu efficace vaudra toujours mieux que pas de test du tout.
Le but étant de prendre l’habitude d’en écrire et d’être objectif dans leur rédaction.</p>
</blockquote>
<p>Le TDD tend à se démocratiser et requiert l’effort de chacun pour devenir un standard.
Tout développeur soucieux de son environnement et de son héritage doit se poser sérieusement
la question.<br>
Les frameworks de tests, les guides et les documentations sur le sujet fleurissent,
vous pouvez donc vous lancer sans crainte.</p>
<p>On peut découper le TDD en 5 étapes distinctes :</p>
<ol>
<li>Écrire un test,</li>
<li>Vérifier qu’il échoue,</li>
<li>Écrire le code <strong>suffisant</strong> pour que le test passe,</li>
<li>Vérifier que le test passe,</li>
<li>Optimiser le code et vérifier qu’il n’y ait pas de régression.</li>
</ol>
<p>Pour simplifier cette logique on peut regrouper ces cinq étapes en trois grandes idées :</p>
<ul>
<li><strong>Tester d’abord</strong>, qui correspond aux deux premières étapes.</li>
<li><strong>Rendre fonctionnel</strong>, qui englobe les points 3 et 4.</li>
<li><strong>Rendre meilleur</strong>, qui n’est autre que l’étape 5.</li>
</ul>
<p>Bill Wake définit ainsi la méthode <a href="http://xp123.com/articles/3a-arrange-act-assert/">3A</a>,
pour Arrange, Act, Assert <em>(Arranger, Agir, Affirmer)</em>.<br>
Il insiste sur le fait que la méthode ne définit pas un ordre immuable,
l’<em>affirmation</em> peut ainsi venir avant l’<em>action</em>, etc...</p>
<ul>
<li><strong>Arranger</strong> : Phase de préparation de l’environnement de test dans laquelle
on déclare les variables et les fonctions.</li>
<li><strong>Agir</strong> : Phase qui met à l’épreuve notre environnement en lui faisant subir des mutations.</li>
<li><strong>Affirmer</strong> : On formule des attentes à propos de l'environnement
(variables, fonctions, paramètres).</li>
</ul>
<h2 id="tdd--concepts-de-base"><a href="#tdd--concepts-de-base" class="phenomic-HeadingAnchor">#</a>TDD : concepts de base</h2>
<p>Pour la série de tests suivante on utilisera EcmaScript 6 et la méthode
<a href="https://developer.mozilla.org/fr/docs/Web/API/Console/assert"><code>.assert()</code></a>
de la console navigateur: Vous pourrez ainsi reproduire ces tests vous-même.</p>
<p>Objectif : Ecrire une fonction <code>countWords()</code> qui compte les mots d'une phrase.</p>
<p><strong>ITERATION 1</strong> : écriture et échec du test initial</p>
<p>On écrit tout d'abord une affirmation de base.</p>
<pre><code class="hljs language-js"><span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">''</span>) === <span class="hljs-number">0</span>, <span class="hljs-string">'test 0: le texte ne contient aucun mot'</span>);</code></pre>
<blockquote>
<p><code>Uncaught ReferenceError: countWords is not defined</code></p>
</blockquote>
<p>Après exécution la console rejette le test.
On doit d'abord définir <code>countWords()</code>.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> countWords = <span class="hljs-function"><span class="hljs-params">()</span> =></span> {};
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">''</span>) === <span class="hljs-number">0</span>, <span class="hljs-string">'test 0: le texte ne contient aucun mot'</span>);</code></pre>
<blockquote>
<p><code>Assertion failed: test 0: le texte ne contient aucun mot</code></p>
</blockquote>
<p><code>countWords()</code> est définie et le test échoue mais l'erreur a changé.<br>
Il faut à présent définir la logique du cœur de notre fonction.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> countWords = <span class="hljs-function"><span class="hljs-params">text</span> =></span> text || <span class="hljs-number">0</span>;
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">''</span>) === <span class="hljs-number">0</span>, <span class="hljs-string">'test 0: le texte ne contient aucun mot'</span>);</code></pre>
<blockquote>
<p><code>undefined</code></p>
</blockquote>
<p>La console ne renvoie rien, le test est donc passé.  </p>
<blockquote>
<p><code>countWords()</code> étant très simple nous omettrons les phases d'optimisation.
On peut aussi considérer les itérations suivantes comme des optimisations.</p>
</blockquote>
<p><strong>ITERATION 2</strong> : test pour les phrases d'un seul mot</p>
<p>Très bien. Essayons à présent une phrase d'un seul mot.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> countWords = <span class="hljs-function"><span class="hljs-params">text</span> =></span> text || <span class="hljs-number">0</span>;
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">''</span>) === <span class="hljs-number">0</span>, <span class="hljs-string">'test 0: le texte ne contient aucun mot'</span>);
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">'nope'</span>) === <span class="hljs-number">1</span>, <span class="hljs-string">'test 1: le texte contient 1 mot'</span>);</code></pre>
<blockquote>
<p><code>Assertion failed: test 1: le texte contient 1 mot</code></p>
</blockquote>
<p><code>countWords()</code> ne compte pas correctement, ajoutons le code suffisant pour passer le test.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> countWords = <span class="hljs-function"><span class="hljs-params">text</span> =></span> text ? text.split(<span class="hljs-string">' '</span>).length : <span class="hljs-number">0</span>;
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">''</span>) === <span class="hljs-number">0</span>, <span class="hljs-string">'test 0: le texte ne contient aucun mot'</span>);
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">'nope'</span>) === <span class="hljs-number">1</span>, <span class="hljs-string">'test 1: le texte contient 1 mot'</span>);</code></pre>
<blockquote>
<p><code>undefined</code></p>
</blockquote>
<p>Le test est passé, ajoutons un autre cas standard.</p>
<p><strong>ITERATION 3</strong> : test pour les phrases de plusieurs mots</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> countWords = <span class="hljs-function"><span class="hljs-params">text</span> =></span> text ? text.split(<span class="hljs-string">' '</span>).length : <span class="hljs-number">0</span>;
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">''</span>) === <span class="hljs-number">0</span>, <span class="hljs-string">'test 0: le texte ne contient aucun mot'</span>);
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">'nope'</span>) === <span class="hljs-number">1</span>, <span class="hljs-string">'test 1: le texte contient 1 mot'</span>);
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">'tdd is so fun'</span>) === <span class="hljs-number">4</span>, <span class="hljs-string">'test 2: le texte contient 4 mots'</span>);</code></pre>
<blockquote>
<p><code>undefined</code></p>
</blockquote>
<p>Le nouveau test passe sans modification, on peut continuer.</p>
<p><strong>ITERATION 4</strong> : test pour les phrases contenant des espaces au début et à la fin</p>
<p>Vérifions à présent la robustesse de la fonction.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> countWords = <span class="hljs-function"><span class="hljs-params">text</span> =></span> text ? text.split(<span class="hljs-string">' '</span>).length : <span class="hljs-number">0</span>;
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">''</span>) === <span class="hljs-number">0</span>, <span class="hljs-string">'test 0: le texte ne contient aucun mot'</span>);
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">'nope'</span>) === <span class="hljs-number">1</span>, <span class="hljs-string">'test 1: le texte contient 1 mot'</span>);
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">'tdd is so fun'</span>) === <span class="hljs-number">4</span>, <span class="hljs-string">'test 2: le texte contient 4 mots'</span>);
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">' so is skateboarding '</span>) === <span class="hljs-number">3</span>, <span class="hljs-string">'test 3: le texte contient 3 mots'</span>);</code></pre>
<blockquote>
<p><code>Assertion failed: test 3: le texte contient 3 mots</code></p>
</blockquote>
<p>Aïe… notre fonction n'est pas assez solide. Corrigeons-la pour capter ce nouveau cas en supprimant les
espaces inutiles avant et après le texte.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> countWords = <span class="hljs-function"><span class="hljs-params">text</span> =></span> text ? text.trim().split(<span class="hljs-string">' '</span>).length : <span class="hljs-number">0</span>;
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">''</span>) === <span class="hljs-number">0</span>, <span class="hljs-string">'test 0: le texte ne contient aucun mot'</span>);
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">'nope'</span>) === <span class="hljs-number">1</span>, <span class="hljs-string">'test 1: le texte contient 1 mot'</span>);
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">'tdd is so fun'</span>) === <span class="hljs-number">4</span>, <span class="hljs-string">'test 2: le texte contient 4 mots'</span>);
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">' so is skateboarding '</span>) === <span class="hljs-number">3</span>, <span class="hljs-string">'test 3: le texte contient 3 mots'</span>);</code></pre>
<blockquote>
<p><code>undefined</code></p>
</blockquote>
<p>Parfait, La fonction est améliorée ! Ajoutons quand même un dernier test pour être sur.</p>
<p><strong>ITERATION 5</strong> : test pour les phrases contenant un nombre inégal d'espaces entre les mots</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> countWords = <span class="hljs-function"><span class="hljs-params">text</span> =></span> text ? text.trim().split(<span class="hljs-string">' '</span>).length : <span class="hljs-number">0</span>;
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">''</span>) === <span class="hljs-number">0</span>, <span class="hljs-string">'test 0: le texte ne contient aucun mot'</span>);
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">'nope'</span>) === <span class="hljs-number">1</span>, <span class="hljs-string">'test 1: le texte contient 1 mot'</span>);
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">'tdd is so fun'</span>) === <span class="hljs-number">4</span>, <span class="hljs-string">'test 2: le texte contient 4 mots'</span>);
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">' so is skateboarding '</span>) === <span class="hljs-number">3</span>, <span class="hljs-string">'test 3: le texte contient 3 mots'</span>);
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">`  I'm 28, I love $#@! and    multi-spaces  `</span>) === <span class="hljs-number">7</span>, <span class="hljs-string">'test 4: le texte contient 7 mots'</span>);</code></pre>
<blockquote>
<p><code>Assertion failed: test 4: le texte contient 7 mots</code></p>
</blockquote>
<p>Et mince… Encore un cas particulier, modifions l'algorithme en conséquence.
On doit ici retirer les espaces inutiles entre les mots.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> countWords = <span class="hljs-function"><span class="hljs-params">text</span> =></span> text ? text.trim().replace(<span class="hljs-regexp">/\s+/g</span>, <span class="hljs-string">' '</span>).split(<span class="hljs-string">' '</span>).length : <span class="hljs-number">0</span>;
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">''</span>) === <span class="hljs-number">0</span>, <span class="hljs-string">'test 0: le texte ne contient aucun mot'</span>);
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">'nope'</span>) === <span class="hljs-number">1</span>, <span class="hljs-string">'test 1: le texte contient 1 mot'</span>);
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">'tdd is so fun'</span>) === <span class="hljs-number">4</span>, <span class="hljs-string">'test 2: le texte contient 4 mots'</span>);
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">' so is skateboarding '</span>) === <span class="hljs-number">3</span>, <span class="hljs-string">'test 3: le texte contient 3 mots'</span>);
<span class="hljs-built_in">console</span>.assert(countWords(<span class="hljs-string">`  I'm 28, I love $#@! and    multi-spaces  `</span>) === <span class="hljs-number">7</span>, <span class="hljs-string">'test 4: le texte contient 7 mots'</span>);</code></pre>
<blockquote>
<p><code>undefined</code></p>
</blockquote>
<p>Le test final est passé sans que les précédents n'échouent.</p>
<p>On notera que l'écriture de tests est un processus itératif.<br>
La phase d'optimisation implique l'écriture d'un nouveau test qui échoue
et relance donc une nouvelle itération.</p>
<p>Evidemment <code>countWords()</code> est très largement sous-optimisée et ne couvre pas tous les cas spéciaux.
On aurait pu ajouter une vérification sur le paramètre <code>text</code> et compter avec une expression régulière comme ceci :</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> countWords = <span class="hljs-function"><span class="hljs-params">text</span> =></span> <span class="hljs-keyword">typeof</span> text === <span class="hljs-string">'string'</span> &#x26;&#x26; text.trim() ? text.match(<span class="hljs-regexp">/\S+\s{0,1}/g</span>).length : <span class="hljs-number">0</span>;</code></pre>
<p>L'idée ici est que coder est un processus incrémental et que chaque nouveau cycle doit être initié
par un besoin spécifique défini par un test dédié.  </p>
<p>L'écriture des tests est simple : on décompose notre script en une suite d'affirmations
correspondant chacune à une fonctionnalité précise de notre algorithme.</p>
<p>Grâce à ce processus on évite :</p>
<ul>
<li><strong>les régressions</strong>: la suite valide de tests est la garantie que le code reste
fonctionnel malgré les évolutions de l'algorithme.</li>
<li><strong>le code mort</strong>: chaque morceau de code écrit est testé et a son utilité.</li>
<li><strong>le code non documenté</strong>: chaque comportement est décrit de manière fonctionnelle.</li>
</ul>
<h2 id="bdd--des-tests-pour-tous"><a href="#bdd--des-tests-pour-tous" class="phenomic-HeadingAnchor">#</a>BDD : Des tests pour tous</h2>
<p>Une variante plus agnostique de la logique du développeur existe et permet à des
intervenants externes de faire partie intégrante du processus créatif.</p>
<p>le BDD, Behaviour Driven Development (Développement Dirigé par le Comportement),
permet de définir de manière compréhensible pour tous les intervenants les
spécifications d’une fonctionnalité. Cela permet aussi aux développeurs de comprendre
le comportement général sans évoquer les détails techniques.
La discussion est donc facilitée entre les différents acteurs.  </p>
<p>Pour illustrer cette variante adaptons l'exemple précédent :</p>
<blockquote>
<p>Note : Pour exécuter ce type de code vous aurez besoin d'un <em>test-runner</em> comme
<a href="https://facebook.github.io/jest/">Jest</a>, <a href="https://mochajs.org">Mocha</a> ou <a href="https://karma-runner.github.io">Karma</a>.</p>
</blockquote>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> countWords = <span class="hljs-function"><span class="hljs-params">text</span> =></span> text ? text.trim().replace(<span class="hljs-regexp">/\s+/g</span>, <span class="hljs-string">' '</span>).split(<span class="hljs-string">' '</span>).length : <span class="hljs-number">0</span>;

describe(<span class="hljs-string">'countWords()'</span>, () => {
  it(<span class="hljs-string">'doit traiter un texte vide'</span>, () => {
    expect(countWords(<span class="hljs-string">''</span>)).toBe(<span class="hljs-number">0</span>);
  });

  it(<span class="hljs-string">'doit traiter un texte d\'un seul mot'</span>, () => {
    expect(countWords(<span class="hljs-string">'nope'</span>)).toBe(<span class="hljs-number">1</span>);
  });

  it(<span class="hljs-string">'doit traiter un texte de n mots'</span>, () => {
    expect(countWords(<span class="hljs-string">'tdd is so fun'</span>)).toBe(<span class="hljs-number">4</span>);
  });

  it(<span class="hljs-string">'doit traiter un texte avec des espaces aux extrémités'</span>, () => {
    expect(countWords(<span class="hljs-string">' so is skateboarding '</span>)).toBe(<span class="hljs-number">3</span>);
  });

  it(<span class="hljs-string">'doit traiter un texte avec des espaces inégaux entre les mots'</span>, () => {
    expect(countWords(<span class="hljs-string">`  I'm 28, I love $#@! and    multi-spaces  `</span>)).toBe(<span class="hljs-number">7</span>);
  });
});</code></pre>
<p>Voici le résultat du run :</p>
<p><img src="./testrunner.png" alt="résultat du run de tests"></p>
<p>La relecture est simplifiée pour tous les participants non techniques.</p>
<h2 id="conclusion"><a href="#conclusion" class="phenomic-HeadingAnchor">#</a>Conclusion</h2>
<p>Le TDD est destiné à être incorporé à un processus d'<a href="http://putaindecode.io/fr/articles/ci/">Intégration Continue</a>
pour s'assurer du bon fonctionnement de l'application sur tous les environnements
de production après chaque nouveau <code>commit</code>.  </p>
<p>J'espère vous avez apprécié la démo et que ça vous a donné envie de
tester le TDD pour apporter équilibre et harmonie à votre code.  </p>
<p>Dans tous les cas, je peux vous certifier que les autres codeurs vous
en seront reconnaissants, croyez-moi.</p>
]]></description><link>http://putaindecode.io/fr/articles/tdd/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/tdd/</guid><pubDate>Tue, 31 Oct 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Swift - la fonction: une closure particulière]]></title><description><![CDATA[<p><strong>Swift</strong> est un langage simple pour les débutants, tout en offrant de grandes possibilitées aux développeurs expérimentés. Les <em>fonctions</em> Swift sont un bon exemple de cette façon d’avoir pensé le langage.</p>
<h2 id="les-fonctions"><a href="#les-fonctions" class="phenomic-HeadingAnchor">#</a>Les fonctions</h2>
<h3 id="déclaration-simple"><a href="#d%C3%A9claration-simple" class="phenomic-HeadingAnchor">#</a>Déclaration simple</h3>
<p>La déclaration et l’utilisation de <em>fonctions</em> est simple. On commence avec le mot clé <code>func</code> suivi du <em>nom</em>, puis des <em>paramètres</em> entre parenthèses (a.k.a. <code>input</code>) :</p>
<pre><code class="hljs language-swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(name:String, age:UInt)</span></span>{
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello <span class="hljs-subst">\(name)</span>, you are <span class="hljs-subst">\(age)</span>"</span>)
}</code></pre>
<p>L’appel se fait aussi simplement que ça : <code>sayHello(name:"Bob", age: 32)</code>. Le mot clé <code>_</code> permet d'enlever le label du paramètre dans l'appel si besoin :</p>
<pre><code class="hljs language-swift"><span class="hljs-comment">// Declaration</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(name:String,<span class="hljs-number">_</span> age:UInt)</span></span>{
 <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello <span class="hljs-subst">\(name)</span>, you are <span class="hljs-subst">\(age)</span>"</span>)
}
<span class="hljs-comment">// Appel</span>
sayHello(name:<span class="hljs-string">"Bob"</span>, <span class="hljs-number">32</span>)</code></pre>
<p>Mais vous perdrez en clarté de code suivant les cas. Par exemple, avec <code>min(3,6)</code> on voit tout de suite ce que fait la fonction. Alors que <code>sayHelloTo("Bob", 32)</code>, le <code>32</code> pourrait être beaucoup de choses.</p>
<blockquote>
<p>Les paramètres sont obligatoirement typés, mais peuvent être optionnels (en autorisant la valeur nil) avec la notation ? (e.g. Int?, String?).</p>
</blockquote>
<p>Vous pouvez aussi définir des valeurs par défauts pour les paramètres :</p>
<pre><code class="hljs language-swift"><span class="hljs-comment">// Declaration</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(name:String, <span class="hljs-number">_</span> age:UInt? = <span class="hljs-literal">nil</span>)</span></span>{
    <span class="hljs-keyword">if</span> age == <span class="hljs-literal">nil</span> {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello <span class="hljs-subst">\(name)</span>"</span>)
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello <span class="hljs-subst">\(name)</span>, you are <span class="hljs-subst">\(age!)</span>"</span>) <span class="hljs-comment">//! permet de pas afficher Optinal(value)</span>
    }
}
<span class="hljs-comment">// Appel</span>
sayHello(name:<span class="hljs-string">"Bob"</span>) <span class="hljs-comment">// -> Hello Bob</span>
sayHello(name:<span class="hljs-string">"Bob"</span>, <span class="hljs-number">32</span>) <span class="hljs-comment">// ->  Hello Bob, you are 32</span></code></pre>
<p>La plupart du temps nos fonctions servent à nous retourner des informations. Pour cela on utilise <code>-></code> en signe de retour suivi du type de la valeur retournée.</p>
<pre><code>func formatHelloSentence(name:String, age:UInt? = nil) -> String {
    if age == nil {
        return "Hello \(name)"
    } else {
        return "Hello \(name), you are \(age)"
    }
}
// Appel
let helloSentence = formatHelloSentence(name:"Bob", age: 32)
</code></pre>
<h3 id="retours-multiples-ou-tuples"><a href="#retours-multiples-ou-tuples" class="phenomic-HeadingAnchor">#</a>Retours multiples ou Tuples</h3>
<p>Apple n’est pas connu pour sa générosité, mais dans Swift ils en ont fait autrement <code>:troll:</code> : on peut retourner plusieurs valeurs avec une seule fonction. Pour cela on utilise un <code>Tuple</code> : un collection de variables ordonnées.</p>
<pre><code class="hljs language-swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hardFunction</span><span class="hljs-params">(fInputs:[Float])</span></span>->(<span class="hljs-type">Int</span>,<span class="hljs-type">Int</span>,<span class="hljs-type">Float</span>,<span class="hljs-type">String</span>) {    
    <span class="hljs-keyword">var</span> a = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> b = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> f : <span class="hljs-type">Float</span> = <span class="hljs-number">0.0</span>
    <span class="hljs-keyword">var</span> str = <span class="hljs-string">""</span>
    <span class="hljs-comment">//...</span>
    <span class="hljs-keyword">return</span> (a,b,f,str)
}</code></pre>
<p>Ici cette fonction prend en paramètres un tableau de <code>Float</code> et retourne un <em>Tuple</em> composé de deux <code>Int</code>, un <code>Float</code> et un <code>String</code> dans cet ordre. Vous pouvez alors utiliser le <em>Tuple</em> comme une structure en utilisant l’index des éléments du <em>Tuple</em> comme nom de variable (ex: <code>0</code>pour le premier <code>Int</code>, <code>3</code> pour le <code>String</code>).</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">let</span> myTuple = hardFunction([<span class="hljs-number">2.4</span>,<span class="hljs-number">2.6</span>,<span class="hljs-number">1.8</span>])
<span class="hljs-keyword">let</span> myTupleString = myTuple.<span class="hljs-number">3</span></code></pre>
<p>Mais ceci reste assez confus, alors on peut nommer les éléments.</p>
<pre><code class="hljs language-swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hardFunction</span><span class="hljs-params">(fInputs:[Float])</span></span>->(valSup:<span class="hljs-type">Int</span>,
        valMax:<span class="hljs-type">Int</span>,
        average:<span class="hljs-type">Float</span>,
        errorString:<span class="hljs-type">String</span>) {
    <span class="hljs-comment">//...</span>
}

<span class="hljs-comment">//utilisation</span>
<span class="hljs-keyword">let</span> myTuple = hardFunction([<span class="hljs-number">2.4</span>,<span class="hljs-number">2.6</span>,<span class="hljs-number">1.8</span>])
<span class="hljs-keyword">let</span> myTupleString = myTuple.errorString <span class="hljs-comment">// myTuple.3 marche encore</span></code></pre>
<p>L'exécution du code permettant d'avoir les valeurs <em>Tuple</em> n'est effectuée qu'à la demande de ces valeurs. Dans l'exemple ci-dessus, le code de <code>hardFunction</code> ne sera appelé qu'à la dernière ligne, car c'est là qu'on a besoin de <code>errorString</code>, pas avant.</p>
<p> Et la notion de <em>Closure</em> fait son entrée!</p>
<h2 id="la-closure-la-variable-fonction"><a href="#la-closure-la-variable-fonction" class="phenomic-HeadingAnchor">#</a>La closure: la variable-fonction</h2>
<h3 id="quésaco"><a href="#qu%C3%A9saco" class="phenomic-HeadingAnchor">#</a>Quésaco</h3>
<p><strong>Une <em>closure</em> est une partie de code, avec paramètres et sorties, qui peut être encapsulé dans une variable, et exécutée à la demande</strong>. Si vous développez en C++ ou Objective-C vous connaissez peut-être déjà les <em>blocks</em> et en Java ou C# les <em>lambdas</em> qui sont des <em>features</em> très (très) proches.</p>
<h3 id="déclaration"><a href="#d%C3%A9claration" class="phenomic-HeadingAnchor">#</a>Déclaration</h3>
<p>Une <em>closure</em>  se déclare grâce au <code>{}</code> et peut être appelée (exécutée) grâce aux parenthèses :</p>
<pre><code class="hljs language-swift"> <span class="hljs-keyword">let</span> helloClosure = {
     <span class="hljs-built_in">print</span>(<span class="hljs-string">"hello, I’m a closure"</span>)
 }

 helloClosure() <span class="hljs-comment">// Le code est exécuté ici</span></code></pre>
<p>Ça vous rappelle rien ? L’appel d’une <em>fonction</em> ! En réalité, la <em>fonction</em> est une <em>closure</em> particulière associé à un contexte (Object, environnement, Bundle...) pour réaliser des optimisations et une meilleur compréhension du code.</p>
<blockquote>
<p>Pour une <em>closure</em> "à l’air libre", on dit d’elle, qu’elle est <em>Self Contained</em> alors qu’une fonction est contenue par un contexte (<code>class</code> par exemple)</p>
</blockquote>
<p>Comme les fonctions, les <em>closures</em>  ont des paramètres d’entrée et de retour:  </p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">let</span> complexClosure = {(name:<span class="hljs-type">String</span>, age:<span class="hljs-type">Float</span>) -> <span class="hljs-type">Bool</span> <span class="hljs-keyword">in</span>
    <span class="hljs-comment">// Code</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
}
<span class="hljs-keyword">let</span> success = complexClosure(<span class="hljs-string">"Louis"</span>,<span class="hljs-number">32</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Louis has <span class="hljs-subst">\(success)</span>"</span>)</code></pre>
<p>Ainsi, les valeurs dans la première partie après la <code>{</code> sont les paramètres d’entrées et après la <code>-></code> ce sont les paramètres de sortie. Le code à exécuter est après le <code>in</code>.</p>
<blockquote>
<p>Comme vous avez dû le remarquer, les <em>closures</em> n’ont pas de paramètres nominatif. IL faut passer les paramètres d'entrée dans l'ordre de la déclaration.</p>
</blockquote>
<h3 id="closure-et-type"><a href="#closure-et-type" class="phenomic-HeadingAnchor">#</a>Closure et Type</h3>
<p>Toute variable est typée en <em>Swift</em>, implicitement ou explicitement. Pour les <em>closures</em> le type est souvent implicite, aussi bien qu’on en oublie souvent qu’elles sont typées. Le type d’une closure va être défini par ses paramètres d’entrée et de sortie. Ainsi la <em>complexClosure</em>  ci-dessus est du type : <code>((String, Float)) -> (Bool)</code>.</p>
<p>Je peux alors écrire ce code puisque les closures sont du même type :</p>
<pre><code class="hljs language-swift"><span class="hljs-keyword">let</span> otherComplexClosure = { (surname:<span class="hljs-type">String</span>,size:<span class="hljs-type">Float</span>) -> <span class="hljs-type">Bool</span> <span class="hljs-keyword">in</span>
    <span class="hljs-comment">// Other complexe Code</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
}
complexClosure = otherComplexClosure</code></pre>
<h3 id="utilisation-du-contexte"><a href="#utilisation-du-contexte" class="phenomic-HeadingAnchor">#</a>Utilisation du contexte</h3>
<p>Les <em>closures</em> ont une connaissance du contexte qui l’entoure. Ce qui veut dire que si la closure est créé dans une méthode, elle aura accès :</p>
<ul>
<li>au contexte de classe en passant par <code>self</code> (variables, autre fonctions...)</li>
<li>au contexte de la fonction (paramètres, fonctions internes...)</li>
</ul>
<pre><code class="hljs language-swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>{
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">"Boby"</span>

    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">crier</span><span class="hljs-params">(cri:String)</span></span>{
        <span class="hljs-keyword">let</span> uselessClosure = {
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"<span class="hljs-subst">\(<span class="hljs-keyword">self</span>.name)</span> cri <span class="hljs-subst">\(cri)</span>"</span>)
        }
        uselessClosure()
    }
}</code></pre>
<h3 id="trailing-closure"><a href="#trailing-closure" class="phenomic-HeadingAnchor">#</a>Trailing Closure</h3>
<p>Pour finir, un peu d'esthétisme car on aime tous le <em>beau</em> code. La <em>Trailing Closure</em> est une syntaxe d'appel de fonction qui permet de rendre le code plus facile à lire.</p>
<p>Prenant la fonction suivante, prenant une <code>URL</code> est une closure de type <code>Void->Void</code> :</p>
<pre><code class="hljs language-swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doLongTask</span><span class="hljs-params">(on file:URL,
        completion:<span class="hljs-params">()</span></span></span> -> ()){
    <span class="hljs-comment">//long task</span>
    completion()
}</code></pre>
<p>On alors l'appeler cette fonction comme ceci :</p>
<pre><code class="hljs language-swift">doLongTask(on: aFileURL, completion:{
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Task Applied on <span class="hljs-subst">\(aFileURL)</span>"</span>)
})</code></pre>
<p>Avec du code plus complexe, ça commence à devenir difficile à lire. Or si le dernier paramètre d'une fonction est une <em>closure</em>, on peut alors écrire l'appel comme ceci :</p>
<pre><code class="hljs language-swift">doLongTask(on: aFileURL){
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Task Applied on <span class="hljs-subst">\(aFileURL)</span>"</span>)
}</code></pre>
<h2 id="pro-tip"><a href="#pro-tip" class="phenomic-HeadingAnchor">#</a>Pro Tip</h2>
<p>Imaginons une classe <code>A</code> ayant une variable <code>event</code>  et un classe <code>B</code> ayant une fonction <code>awesomeEvent</code> ayant le même type que la variable <code>event</code> de la classe <code>A</code>. Je peux alors allouer, à la variable <code>event</code>, le code de <code>awesomeEvent</code>.</p>
<pre><code class="hljs language-swift"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>{
    <span class="hljs-keyword">var</span> event : ((<span class="hljs-type">String</span>)-><span class="hljs-type">Void</span>)?
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">awesome</span><span class="hljs-params">(name:String)</span></span>{
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Awesome <span class="hljs-subst">\(name)</span>"</span>)
    }
}

<span class="hljs-keyword">let</span> b = <span class="hljs-type">B</span>()
<span class="hljs-keyword">let</span> a = <span class="hljs-type">A</span>()

a.event = b.awesome
a.event?(<span class="hljs-string">"Mate"</span>)</code></pre>
<p><a href="http://swift.sandbox.bluemix.net/#/repl/59ecdb8508529b23242b5696">Exécutez ce code sur IBM Swift Sandbox c'est magique!</a></p>
<h2 id="conclusion"><a href="#conclusion" class="phenomic-HeadingAnchor">#</a>Conclusion</h2>
<p>Voilà vous savez tout, ou presque, sur les fonctions et les closures. Les closures ont vraiment la part belle en Swift, donc apprenez à les utiliser et les comprendre pour simplifiez votre code. Elles sont partout dans les API iOS et macOS.</p>
<p>Et un petit conseil: faite attention à l'état de vos <em>closures</em> dans vos <code>Thread</code> si vous ne voulez pas de fuite 😊</p>
]]></description><link>http://putaindecode.io/fr/articles/swift/closure/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/swift/closure/</guid><pubDate>Thu, 26 Oct 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Introduction aux pattern des observables]]></title><description><![CDATA[<p>En JavaScript, nous pouvons exécuter du code de manière synchrone (bloquant) ou
asynchrone (non bloquant).</p>
<p>Prenons une fonction <code>logValue</code>, qui prend une valeur et l'affiche dans la
console :</p>
<pre><code class="hljs language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logValue</span>(<span class="hljs-params">value</span>) </span>{
  <span class="hljs-built_in">console</span>.log(value);
}</code></pre>
<p>Nous allons passer <code>logValue</code> comme callback à la méthode
<code>Array.prototype.forEach</code>, qui va l'exécuter de manière <strong>synchrone</strong> :</p>
<pre><code class="hljs language-JavaScript"><span class="hljs-keyword">const</span> arrayOfValues = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]

arrayOfValues.forEach(logValue)
<span class="hljs-comment">// Log 1, 2, 3, 4 puis 5</span></code></pre>
<p>On peut également passer <code>logValue</code> comme callback de <code>setTimeout</code>, qui va
l'exécuter de manière <strong>asynchrone</strong> :</p>
<pre><code class="hljs language-JavaScript">setTimeout(logValue, <span class="hljs-number">3000</span>, <span class="hljs-string">"Hello world!"</span>)
logValue(<span class="hljs-string">"How are you?"</span>)
<span class="hljs-comment">// Log "How are you?"</span>
<span class="hljs-comment">// Log "Hello world!" 3 secondes plus tard</span></code></pre>
<p>Une fonction est agnostique: elle peut être appelée de manière synchrone ou
asynchrone, c'est la façon dont elle est exécutée qui définira le "mode".</p>
<p>Un cas où il est utile d'utiliser des APIs asynchrones avec Node.js: les accès
au <em>file-system</em>. Si vous lisez un gros fichier en mode synchrone, il va bloquer
l'exécution de votre programme tant qu'il n'a pas fini, mieux vaut attendre
qu'il vous l'envoie quand il est prêt.</p>
<p>Node.js propose l'API suivante: <code>fs.readFile(fileToRead, options, callback)</code></p>
<pre><code class="hljs language-JavaScript">fs.readFile(<span class="hljs-string">"./alphabet.txt"</span>, {<span class="hljs-attr">encoding</span>: <span class="hljs-string">"utf-8"</span>}, (err, data) => {
  <span class="hljs-keyword">if</span> (err) {
    onError(err)
  } <span class="hljs-keyword">else</span> {
    onData(data)
  }
})</code></pre>
<p>Cet exemple montre une API utilisant un simple callback qui est exécuté lorsque
<code>readFile</code> a lu le fichier ou échoué à le faire.</p>
<p>Un autre cas où utiliser des APIs asynchrones est particulièrement important :
les appels réseaux. On ne peut pas se permettre de <em>freeze</em> toute notre
interface pendant que la requête réseau tourne.</p>
<pre><code class="hljs language-JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logValue</span>(<span class="hljs-params">value</span>) </span>{ <span class="hljs-built_in">console</span>.log(value) }
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logError</span>(<span class="hljs-params">err</span>) </span>{ <span class="hljs-built_in">console</span>.error(err) }

fetch(<span class="hljs-string">"https://api.github.com/users/wyeo"</span>)
  .then(<span class="hljs-function"><span class="hljs-params">res</span> =></span> res.json())
  .then(logValue) <span class="hljs-comment">// Log le payload JSON lorsque la requête est terminée</span>
  .catch(logError) <span class="hljs-comment">// Lance une erreur dans la console si quelque chose s'est mal passé</span></code></pre>
<p>Dans cet exemple, l'API renvoie une <code>Promise</code>: <a href="/fr/articles/js/es2015/promises/">une structure représentant une
valeur potentielle</a>. Lorsque sa valeur est
disponible, la promesse est <em>remplie</em>, et exécutera les callbacks qu'on lui a
passé dans <code>.then</code>, si elle constate une erreur, elle exécutera les callbacks
qu'on lui a passé dans <code>.catch</code>.</p>
<p>Les <code>Promise</code> ne permettent cependant pas de traiter de la donnée au fur et à
mesure de son arrivée: elle est remplie une seule fois.</p>
<p>C'est là que les <code>Observable</code> arrivent à la rescousse.</p>
<p>Un <code>Observable</code> est un objet implémentant une méthode <code>.subscribe</code> qui prend
comme paramètre un <code>Observer</code>. Ce dernier a cette forme :</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> observer = {
  <span class="hljs-attr">next</span>: <span class="hljs-function"><span class="hljs-params">val</span> =></span> <span class="hljs-built_in">console</span>.log(val), <span class="hljs-comment">// une fonction à exécuter à chaque nouvel évenement</span>
  error: <span class="hljs-function"><span class="hljs-params">err</span> =></span> <span class="hljs-built_in">console</span>.error(err), <span class="hljs-comment">// une fonction à exécuter en cas d'erreur</span>
  complete: <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-built_in">console</span>.info(<span class="hljs-string">"Complete!"</span>) <span class="hljs-comment">// une fonction à exécuter lorsque l'observable a fini</span>
};</code></pre>
<p>Implémentons naïvement un <code>Observable</code> qui va réagir lorsqu'un user va taper sur
son clavier et se considérer terminé une fois <code>Enter</code> pressé:</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> KeyboardObservable = {
  <span class="hljs-attr">subscribe</span>: <span class="hljs-function"><span class="hljs-params">observer</span> =></span> {
    <span class="hljs-keyword">const</span> handleKeyUp = <span class="hljs-function"><span class="hljs-params">event</span> =></span> {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> event.keyCode === <span class="hljs-string">"number"</span>) {
        <span class="hljs-keyword">if</span> (event.keyCode === <span class="hljs-number">13</span> <span class="hljs-comment">/* Enter */</span>) {
          <span class="hljs-built_in">document</span>.removeEventListener(<span class="hljs-string">"keyup"</span>, handleKeyUp);
          observer.complete();
        } <span class="hljs-keyword">else</span> {
          observer.next(event.keyCode);
        }
      } <span class="hljs-keyword">else</span> {
        observer.error(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"No keyCode found"</span>));
      }
    };
    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">"keyup"</span>, handleKeyUp);
    <span class="hljs-comment">// subscribe retourne la "soucription", contenant une fonction pour la stopper</span>
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">unsubscribe</span>: <span class="hljs-function"><span class="hljs-params">()</span> =></span> <span class="hljs-built_in">document</span>.removeEventListener(<span class="hljs-string">"keyup"</span>, handleKeyUp)
    };
  }
};

<span class="hljs-keyword">let</span> keys = [];
KeyboardObservable.subscribe({
  <span class="hljs-attr">next</span>: <span class="hljs-function"><span class="hljs-params">keyCode</span> =></span> keys.push(<span class="hljs-built_in">String</span>.fromCharCode(keyCode)),
  <span class="hljs-attr">error</span>: <span class="hljs-function"><span class="hljs-params">error</span> =></span> <span class="hljs-built_in">console</span>.error(error),
  <span class="hljs-attr">complete</span>: <span class="hljs-function"><span class="hljs-params">()</span> =></span> alert(keys.join(<span class="hljs-string">""</span>))
});</code></pre>
<p>Un <code>Observable</code> fonctionne à la fois pour du code synchrone et asynchrone, et il
s'agit d'un pattern qui peut s'appliquer à des cas où <code>Promise</code> manque de
granularité, puisqu'il permet de traiter la donnée au fur et à mesure de son
arrivée. <em>In fine</em>, un observable est un <em>event emitter</em> avec un concept de
completion.</p>
<p>Il existe d'ailleurs un <a href="https://tc39.github.io/proposal-observable/"><em>proposal</em> en stage
1</a> pour en faire une API de la
specification de JavaScript. On peut très bien imaginer que les observables
deviennent une interface très répandue dans un futur proche.</p>
<p>Dans les prochains articles, nous verrons pourquoi et comment combiner des
observables ainsi que les cas d'usage au sein d'une application React.</p>
]]></description><link>http://putaindecode.io/fr/articles/js/observable/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/js/observable/</guid><pubDate>Mon, 23 Oct 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Podcast 7: React 16, GraphQL, IDLs, RPCs et mauvaise foi sur l'iPhone X]]></title><description><![CDATA[<p>On se retrouve pour un nouvel épisode avec un joli programme: on vous y parle de
React 16, de GraphQL, des IDLs et des RPCs. En plus de ça, on vous offre une
belle dose de mauvaise foi dans un débat sur l'iPhone X.</p>
<p>Moi, Matthias (<a href="https://twitter.com/bloodyowl">https://twitter.com/bloodyowl</a>), vous présente ce podcast en
compagnie de mes fidèles acolytes :</p>
<ul>
<li>Mathieu (<a href="https://twitter.com/Zoontek">https://twitter.com/Zoontek</a>)</li>
<li>Georges (<a href="https://twitter.com/skinnyfoetusboy">https://twitter.com/skinnyfoetusboy</a>)</li>
</ul>
<p>Les petits liens qui vont bien :</p>
<ul>
<li>React 16: <a href="https://reactjs.org/blog/2017/09/26/react-v16.0.html">https://reactjs.org/blog/2017/09/26/react-v16.0.html</a></li>
<li>GraphQL: <a href="http://graphql.org">http://graphql.org</a></li>
<li>Relay: <a href="https://facebook.github.io/relay/">https://facebook.github.io/relay/</a></li>
<li>Apollo: <a href="https://www.apollodata.com">https://www.apollodata.com</a></li>
<li>ProtoBuf: <a href="https://github.com/google/protobuf">https://github.com/google/protobuf</a></li>
<li>Thrift: <a href="https://thrift.apache.org">https://thrift.apache.org</a></li>
<li>gRPC: <a href="https://grpc.io">https://grpc.io</a></li>
<li>iPhone X: <a href="https://www.apple.com/iphone-x/">https://www.apple.com/iphone-x/</a></li>
</ul>
<p>La track du générique: <a href="https://soundcloud.com/matthias-le-brun/arrow">https://soundcloud.com/matthias-le-brun/arrow</a></p>
<iframe width="100%" height="300" scrolling="no" frameborder="no" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/348401054&amp;color=%23ff5500&amp;auto_play=false&amp;hide_related=true&amp;show_comments=true&amp;show_user=true&amp;show_reposts=false&amp;show_teaser=false&amp;visual=true"></iframe>
<ul>
<li>Le
<a href="http://feeds.soundcloud.com/users/soundcloud:users:273901232/sounds.rss">RSS</a></li>
<li>Sur iTunes : <a href="https://itunes.apple.com/fr/podcast/putain-de-code-!/id1185311825?l=en&#x26;mt=2">Putain de
Code</a></li>
</ul>
]]></description><link>http://putaindecode.io/fr/articles/podcast/7/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/podcast/7/</guid><pubDate>Wed, 18 Oct 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Utiliser Reason avec JavaScript]]></title><description><![CDATA[<p>Dans un <a href="/fr/articles/reason/introduction-reason/">précédent article</a>, on vous
présentait une nouvelle syntaxe pour OCaml:
<a href="https://reasonml.github.io">ReasonML</a>, elle rend le langage plus accessible en
le rapprochant de JavaScript moderne.</p>
<p>À l'aide du projet
<a href="https://bucklescript.github.io/bucklescript/Manual.html">BuckleScript</a> qui
supporte Reason nativement, on peut compiler notre code Reason vers JavaScript
très facilement. Le créateur de BuckleScript utilisait à l'origine un autre
projet appelé <a href="http://ocsigen.org/js_of_ocaml/">js_of_ocaml</a>. Trouvant qu'il
serait possible d'optimiser et de rendre plus lisible le code JavaScript en
sortie si le compiler commençait son travail à une étape plus haut niveau (une
représentation du programme contenant des informations supplémentaires, alors
que js_of_ocaml utilise du bytecode), il propose ce changement à la team
js_of_ocaml qui refuse, et décide donc de se lancer dans le projet qui deviendra
BuckleScript.</p>
<p>Pour démarrer un projet avec BuckleScript et Reason, on ouvre son terminal, et
c'est parti:</p>
<p>On installe BuckleScript:</p>
<pre><code class="hljs language-console"><span class="hljs-meta">$</span><span class="bash"> npm install -g bs-platform</span></code></pre>
<p>On initialise le projet:</p>
<pre><code class="hljs language-console"><span class="hljs-meta">$</span><span class="bash"> bsb -init my-app -theme basic-reason</span></code></pre>
<p>Hop, votre projet est prêt dans <code>my-app</code>.</p>
<p>Maintenant la question est: comment est-ce que je peux utiliser du JS dans
Reason et vice-versa ?</p>
<h2 id="les-ffi-ou-foreign-function-interface"><a href="#les-ffi-ou-foreign-function-interface" class="phenomic-HeadingAnchor">#</a>Les FFI (ou Foreign Function Interface)</h2>
<p>OCaml gère naturellement les <code>FFI</code>, notamment pour appeler des fonctions <code>C</code>
lorsqu'il compile vers du code natif.</p>
<p>BuckleScript vient les overloader pour les adapter à JavaScript.</p>
<p>Créons une FFI pour la fonction <code>alert</code> :</p>
<pre><code class="hljs language-reason">[@bs.<span class="hljs-keyword">val</span>] <span class="hljs-keyword">external</span> alert : <span class="hljs-built_in">string</span> => <span class="hljs-built_in">unit</span> = <span class="hljs-string">""</span>;</code></pre>
<p>On définit:</p>
<ul>
<li>une fonction externe nommée <code>alert</code></li>
<li>qui prend une <code>string</code> et ne retourne <em>rien</em> (ici représenté par la valeur
<code>unit</code>)</li>
<li>qui est une valeur à simplement récupérer (<code>[@bs.val]</code>)</li>
</ul>
<p>Si on regarde le code JavaScript en sortie, c'est vide. En effet, <code>external</code> est
un moyen de définir comment accéder à une valeur ainsi que son type. Si en
revanche on utilise la function <code>alert</code> dans le module:</p>
<pre><code class="hljs language-reason">[@bs.<span class="hljs-keyword">val</span>] <span class="hljs-keyword">external</span> alert : <span class="hljs-built_in">string</span> => <span class="hljs-built_in">unit</span> = <span class="hljs-string">""</span>;

alert(<span class="hljs-string">"Hello!"</span>);</code></pre>
<p>On voit dans l'output que BuckleScript a <em>inliné</em> l'appel de <code>alert</code>, il n'a pas
crée de représentation intermédiaire.</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Generated by BUCKLESCRIPT VERSION 1.9.1, PLEASE EDIT WITH CARE</span>
<span class="hljs-meta">"use strict"</span>;

alert(<span class="hljs-string">"Hello!"</span>);

<span class="hljs-comment">/*  Not a pure module */</span></code></pre>
<p>Maintenant amusons nous à créer des bindings pour jQuery, juste pour le fun:</p>
<pre><code class="hljs language-reason">/* <span class="hljs-type">On</span> crée un <span class="hljs-keyword">type</span> opaque pour représenter un objet jQuery */
<span class="hljs-keyword">type</span> jQuery;

/* <span class="hljs-type">On</span> <span class="hljs-keyword">type</span> le <span class="hljs-keyword">module</span> jQuery */
[@bs.<span class="hljs-keyword">module</span>] <span class="hljs-keyword">external</span> jQuery : <span class="hljs-built_in">string</span> => jQuery = <span class="hljs-string">"jquery"</span>;

/* <span class="hljs-type">On</span> <span class="hljs-keyword">type</span> la méthod `on`, <span class="hljs-type">BuckleScript</span> peut naturellement typer
  le pattern de chaining, assez commun en <span class="hljs-type">JS</span>, à l'aide de l'annotation
  `bs.send.pipe: <span class="hljs-keyword">type</span>` */
[@bs.send.pipe: jQuery] <span class="hljs-keyword">external</span> on : <span class="hljs-built_in">string</span> => (<span class="hljs-type">Dom</span>.event => <span class="hljs-built_in">unit</span>) => jQuery = <span class="hljs-string">""</span>;

jQuery(<span class="hljs-string">".selector"</span>)
  |> on(<span class="hljs-string">"click"</span>, (_) => alert(<span class="hljs-string">"hey"</span>));</code></pre>
<p>Ce qui va nous sortir:</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Generated by BUCKLESCRIPT VERSION 1.9.1, PLEASE EDIT WITH CARE</span>
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">var</span> JQuery = <span class="hljs-built_in">require</span>(<span class="hljs-string">"jquery"</span>);

JQuery(<span class="hljs-string">".selector"</span>).on(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  alert(<span class="hljs-string">"hey"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-comment">/* () */</span> <span class="hljs-number">0</span>;
});

<span class="hljs-comment">/*  Not a pure module */</span></code></pre>
<p>Comme on peut le constater, le code de sortie ressemble beaucoup à ce qu'on
pourrait écrire à la main.</p>
<p>Pour en savoir un peu plus sur les FFI JavaScript:</p>
<ul>
<li><a href="https://bucklescript.github.io/bucklescript/Manual.html">La documentation de
BuckleScript</a></li>
<li><a href="https://github.com/reasonml-community">Les projets de bindings crées par la
communauté</a> (ceux nommés
<code>bs-{nom-de-lib-js}</code>)</li>
</ul>
<h2 id="les-objets"><a href="#les-objets" class="phenomic-HeadingAnchor">#</a>Les objets</h2>
<p>On peut directement utiliser des objets JavaScript en Reason. Pour accéder à une
propriété, on utilise <code>##</code>.</p>
<pre><code class="hljs language-reason"><span class="hljs-meta">myJsObject#</span><span class="bash"><span class="hljs-comment">#property</span></span></code></pre>
<p>Ça dépanne, mais au sein de notre code Reason, on préférera bien souvent
utiliser des records: ils ont une représentation plus légère et sont par défaut
immutables. Pour effectuer une conversion, on procède de la manière suivante:</p>
<pre><code class="hljs language-reason"><span class="hljs-keyword">type</span> jsUser = {
  .
  <span class="hljs-string">"id"</span>: <span class="hljs-built_in">string</span>,
  <span class="hljs-string">"username"</span>: <span class="hljs-built_in">string</span>,
  <span class="hljs-comment">/* valeur pouvant être null, undefined, ou la valeur */</span>
  <span class="hljs-string">"birthdate"</span>: Js.Null_undefined.t(<span class="hljs-built_in">string</span>),
  <span class="hljs-comment">/* "light" ou "dark", les enums sont souvent représentés par des strings en JS */</span>
  <span class="hljs-string">"theme"</span>: <span class="hljs-built_in">string</span>
};

<span class="hljs-comment">/* En Reason, les enums sont représentés par des variants */</span>
<span class="hljs-keyword">type</span> theme =
  | Light
  | Dark;

<span class="hljs-keyword">type</span> user = {
  id: <span class="hljs-built_in">string</span>,
  username: <span class="hljs-built_in">string</span>,
  <span class="hljs-comment">/* pas de null ou undefined, on utilise un type option */</span>
  birthdate: option(<span class="hljs-built_in">string</span>),
  theme
};

<span class="hljs-comment">/* une fonction de transformation JS -> Reason */</span>
<span class="hljs-keyword">let</span> fromJs = <span class="hljs-function">(<span class="hljs-params">jsUser</span>) =></span> {
  id: jsUser##id,
  username: jsUser##username,
  <span class="hljs-comment">/* BuckleScript propose des helpers pour les conversions */</span>
  birthdate: Js.Null_undefined.to_opt(jsUser##birthdate),
  theme:
    <span class="hljs-keyword">switch</span> jsUser##theme {
    | <span class="hljs-string">"dark"</span> => Dark
    | <span class="hljs-string">"light"</span>
    <span class="hljs-comment">/* On match une chaîne de caractère, le match n'est pas exhaustif,
         on doit donc définir la valeur de fallback (par defaut) à l'aide
         de `_`
       */</span>
    | _ => Light
    }
};

<span class="hljs-comment">/* Pour créer un objet JS en Reason, il suffit de l'écrire comme un
     record, mais avec des clés entre quotes, comme du JSON.
   */</span>
<span class="hljs-keyword">let</span> toJs = <span class="hljs-function">(<span class="hljs-params">user</span>) =></span> {
  <span class="hljs-string">"id"</span>: user.id,
  <span class="hljs-string">"username"</span>: user.username,
  <span class="hljs-string">"birthdate"</span>: Js.Null_undefined.from_opt(user.birthdate),
  <span class="hljs-string">"theme"</span>:
    <span class="hljs-keyword">switch</span> user.theme {
    | <span class="hljs-function"><span class="hljs-params">Light</span> =></span> <span class="hljs-string">"light"</span>
    | <span class="hljs-function"><span class="hljs-params">Dark</span> =></span> <span class="hljs-string">"dark"</span>
    }
};</code></pre>
<p>Le code en sortie:</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Generated by BUCKLESCRIPT VERSION 1.9.1, PLEASE EDIT WITH CARE</span>
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">var</span> Js_primitive = <span class="hljs-built_in">require</span>(<span class="hljs-string">"bs-platform/lib/js/js_primitive.js"</span>);
<span class="hljs-keyword">var</span> Js_null_undefined = <span class="hljs-built_in">require</span>(<span class="hljs-string">"bs-platform/lib/js/js_null_undefined.js"</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fromJs</span>(<span class="hljs-params">jsUser</span>) </span>{
  <span class="hljs-keyword">var</span> match = jsUser.theme;
  <span class="hljs-keyword">var</span> tmp;
  <span class="hljs-keyword">switch</span> (match) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">"dark"</span>:
      tmp = <span class="hljs-comment">/* Dark */</span> <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">"light"</span>:
      tmp = <span class="hljs-comment">/* Light */</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      tmp = <span class="hljs-comment">/* Light */</span> <span class="hljs-number">0</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-comment">/* record */</span> [
    <span class="hljs-comment">/* id */</span> jsUser.id,
    <span class="hljs-comment">/* username */</span> jsUser.username,
    <span class="hljs-comment">/* birthdate */</span> Js_primitive.null_undefined_to_opt(jsUser.birthdate),
    <span class="hljs-comment">/* theme */</span> tmp
  ];
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toJs</span>(<span class="hljs-params">user</span>) </span>{
  <span class="hljs-keyword">var</span> match = user[<span class="hljs-comment">/* theme */</span> <span class="hljs-number">3</span>];
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">id</span>: user[<span class="hljs-comment">/* id */</span> <span class="hljs-number">0</span>],
    <span class="hljs-attr">username</span>: user[<span class="hljs-comment">/* username */</span> <span class="hljs-number">1</span>],
    <span class="hljs-attr">birthdate</span>: Js_null_undefined.from_opt(user[<span class="hljs-comment">/* birthdate */</span> <span class="hljs-number">2</span>]),
    <span class="hljs-attr">theme</span>: match !== <span class="hljs-number">0</span> ? <span class="hljs-string">"dark"</span> : <span class="hljs-string">"light"</span>
  };
}

exports.fromJs = fromJs;
exports.toJs = toJs;
<span class="hljs-comment">/* No side effect */</span></code></pre>
<h2 id="les-standard-libs"><a href="#les-standard-libs" class="phenomic-HeadingAnchor">#</a>Les standard-libs</h2>
<p>Si le besoin s'en fait sentir, BuckleScript propose naturellement la stdlib de
JavaScript.</p>
<pre><code class="hljs language-reason"><span class="hljs-keyword">let</span> myArray = [|<span class="hljs-type">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>|<span class="hljs-type">];

myArray</span>
  |<span class="hljs-type">> Js</span>.Array.map((item) => item * <span class="hljs-number">2</span>)
  |<span class="hljs-type">> Js</span>.Array.reduce((acc, item) => acc + item, <span class="hljs-number">0</span>);</code></pre>
<p>vous sortira:</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Generated by BUCKLESCRIPT VERSION 1.9.1, PLEASE EDIT WITH CARE</span>
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">var</span> myArray = <span class="hljs-comment">/* array */</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];

myArray
  .map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>{
    <span class="hljs-keyword">return</span> item &#x3C;&#x3C; <span class="hljs-number">1</span>;
  })
  .reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">acc, item</span>) </span>{
    <span class="hljs-keyword">return</span> (acc + item) | <span class="hljs-number">0</span>;
  }, <span class="hljs-number">0</span>);

exports.myArray = myArray;
<span class="hljs-comment">/*  Not a pure module */</span></code></pre>
<h2 id="la-technique-bourrin"><a href="#la-technique-bourrin" class="phenomic-HeadingAnchor">#</a>La technique bourrin</h2>
<p>Pour les cas extrêmes ou vous voulez juste balancer une fonction JS, vous
pouvez:</p>
<pre><code class="hljs language-reason"><span class="hljs-comment">/* %bs.raw pour une expression, %%bs.raw pour un bloc de code arbitraire */</span>
<span class="hljs-keyword">let</span> log: <span class="hljs-function"><span class="hljs-params">string</span> =></span> unit = [%bs.raw {|
  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>) </span>{
    <span class="hljs-built_in">console</span>.log(a);
  }
|}];

log(<span class="hljs-string">"ok"</span>);</code></pre>
<p>qui vous sort un joli:</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// Generated by BUCKLESCRIPT VERSION 1.9.1, PLEASE EDIT WITH CARE</span>
<span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">var</span> Curry = <span class="hljs-built_in">require</span>(<span class="hljs-string">"bs-platform/lib/js/curry.js"</span>);

<span class="hljs-keyword">var</span> log = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) </span>{
  <span class="hljs-built_in">console</span>.log(a);
};

Curry._1(log, <span class="hljs-string">"ok"</span>);

exports.log = log;
<span class="hljs-comment">/* log Not a pure module */</span></code></pre>
<h2 id="conclusion"><a href="#conclusion" class="phenomic-HeadingAnchor">#</a>Conclusion</h2>
<p>OCaml peut en grande majorité être compilé en JavaScript très simple, parce
qu'il partage beaucoup de concepts avec ce dernier. Il est assez simple de créer
des ponts entre les deux langages à l'aide des FFI. L'énorme avantage de cette
feature, c'est que l'on peut commencer à utiliser Reason incrémentalement sur
son projet sans avoir à tout réécrire d'un coup.</p>
<p>Bisous bisous.</p>
]]></description><link>http://putaindecode.io/fr/articles/reason/interop/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/reason/interop/</guid><pubDate>Tue, 10 Oct 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Introduction à ReasonML (ou pourquoi j'ai arrêté d'utiliser JavaScript)]]></title><description><![CDATA[<p>Les bugs c'est chiant, surtout quand on sait qu'on aurait pu les éviter. Avec
JavaScript, c'est plus facile d'en avoir que de les éviter.</p>
<p>JavaScript, on ne peut pas y échapper parce que c'est partout, parce que c'est
le langage de programmation le plus utilisé sur Terre, et parce que c'est le
seul truc qui (pour l'instant) tourne nativement dans le navigateur. Et puis
c'est pas si mal, c'est facile de l'apprendre en bidouillant un peu, c'est très
permissif et pas trop frustrant pour débuter.</p>
<p>Le problème c'est que c'est facile d'en faire, mais c'est très dur d'en faire
<strong>bien</strong> (moins que CSS, mais quand même). On s'est tous déjà retrouvé avec
<code>undefined is not a function</code>, <code>null is not an object</code> ou un bon gros <code>[object Object]</code> qui traîne dans la console.</p>
<h2 id="pourquoi-est-ce-que-cest-comme-ça-"><a href="#pourquoi-est-ce-que-cest-comme-%C3%A7a-" class="phenomic-HeadingAnchor">#</a>Pourquoi est-ce que c'est comme ça ?</h2>
<p>JavaScript est un langage dynamiquement et faiblement typé, ce qui veut dire :</p>
<ul>
<li>qu'une fonction ne sait pas ce qu'elle prend ou retourne comme type
d'arguments, c'est à vous de gérer</li>
<li>que le programme n'en a aucune idée non plus tant qu'il n'execute pas la
portion de code</li>
</ul>
<p>Tout ça fait qu'il est très difficile de faire confiance à du code JavaScript.</p>
<figure>
<img src="./js.png" alt="js" />
<figcaption>Source: MIT</figcaption>
</figure>
<p>Il existe Flow et TypeScript (dont on a parlé dans un <a href="/fr/articles/js/flow/">précédent
article</a> et un <a href="fr/articles/podcast/3/">podcast</a>), deux
projets qui permettent d'apporter du typage statique pour sécuriser son code.
Ils contraignent votre usage de JavaScript, mais devront toujours se battre
contre sa permissivité.</p>
<p>Ça revient au final à coller des rustines sur vos pneus avant d'aller rouler sur
des clous, ça va vous protéger un peu, mais ça reste de base pas bien malin
d'aller rouler sur des clous.</p>
<p>Il existe des langages qui ont la judicieuse idée de balayer la route pour virer
les clous avant d'y aller : les langages typés fortement et statiquement (10
points pour Gryffondor pour cette métaphore filée).</p>
<p>OCaml est un de ces langages. Il est de la famille ML et a été créé en France
dans les années 90. Il est à peu près aussi âgé que JavaScript mais est beaucoup
plus sage. Il est certes fortement et statiquement typé, mais il infère la
plupart des types du programme (ce qui veut dire que vous n'avez pas à
renseigner les types partout, il va l'extrapoler dès qu'il le peut). En bonus,
il possède de <a href="https://ocaml.org/learn/tutorials/comparison_of_standard_containers.html">bonnes
data-structures</a>.</p>
<p>Seulement voilà, OCaml, comme beaucoup de langages fonctionnels n'a pas vraiment
mis l'accent sur l'accessibilité pour les débutants, et a une syntaxe qu'on peut
pour le moins qualifier de pas très friendly: elle n'a rien de bien mal, mais
mettez quelqu'un qui vient de JS/PHP/Java devant, ça va pas lui causer des
masses:</p>
<pre><code class="hljs language-ocaml"><span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> qsort = <span class="hljs-keyword">fun</span> <span class="hljs-keyword">value</span> ->
  <span class="hljs-keyword">match</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">with</span>
   | <span class="hljs-literal">[]</span> -> <span class="hljs-literal">[]</span>
   | pivot :: rest ->
       <span class="hljs-keyword">let</span> is_less x = x &#x3C; pivot <span class="hljs-keyword">in</span>
       <span class="hljs-keyword">let</span> left, right = <span class="hljs-type">List</span>.partition is_less rest <span class="hljs-keyword">in</span>
       qsort left @ [pivot] @ qsort right;;</code></pre>
<figure>
<img src="./giphy.gif" alt="" />
<figcaption>fig. 1: dev JS devant du code OCaml</figcaption>
</figure>
<p>C'est là qu'intervient Reason, un projet initié par <a href="https://twitter.com/jordwalke">le créateur de
React</a>. Les premières itérations de React étaient
d'ailleurs codées dans un langage cousin de OCaml, le SML.</p>
<p>C'est en gros:</p>
<ul>
<li>OCaml</li>
<li>avec une syntaxe <em>beginner-friendly</em></li>
<li>avec un tooling le rendant plus simple à utiliser</li>
<li>qui peut compiler vers JavaScript et de multiples plateformes</li>
</ul>
<p>Avec son type system, OCaml propose un langage <em>safe-by-design</em>, chose que même
avec une palanquée d'outils, on ne peut pas atteindre avec JavaScript.</p>
<p>Le langage propose par défaut une approche fonctionnelle et immutable, mais
permet cependant de choisir d'utiliser des structures mutables et de l'orienté
objet au besoin.</p>
<h2 id="le-langage"><a href="#le-langage" class="phenomic-HeadingAnchor">#</a>Le langage</h2>
<p>Reason comporte plus de types de primitifs que JavaScript:</p>
<pre><code class="hljs language-reason"><span class="hljs-comment">/* pas un gros "number" fourre tout, magique */</span>
<span class="hljs-number">1</span>; <span class="hljs-comment">/* int */</span>
<span class="hljs-number">1.0</span>; <span class="hljs-comment">/* float */</span>
<span class="hljs-comment">/* un caractère est d'un type différent de string */</span>
<span class="hljs-string">"foo"</span>; <span class="hljs-comment">/* string */</span>
'a'; <span class="hljs-comment">/* char */</span>
<span class="hljs-comment">/* on trouve list ET array, chacun peut être utilisé pour différents cas */</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-comment">/* list */</span>
[| <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> |]; <span class="hljs-comment">/* array */</span>
<span class="hljs-comment">/* pas de null, mais des valeurs de type `option` qui contiennent
  soit une valeur, soit rien */</span>
Some(<span class="hljs-number">1</span>); <span class="hljs-comment">/* option int */</span>
None; <span class="hljs-comment">/* option int */</span></code></pre>
<p>Puisqu'il est fortement typé, il est impossible de mixer les types comme en
JavaScript, vous devrez obligatoirement les convertir:</p>
<pre><code class="hljs language-reason"><span class="hljs-number">1</span> + <span class="hljs-number">1.0</span>;
<span class="hljs-comment">/* Error:
  This expression has type int but an expression was expected of type float */</span>
<span class="hljs-number">1</span> + int_of_float(<span class="hljs-number">1.0</span>);
<span class="hljs-comment">/* - : int = 2 */</span></code></pre>
<p>La plupart des opérations de transformations de type primitifs vers un autre
sont accessibles dans le module <code>Pervasives</code> qui contient plein de petits
utilitaires bien pratiques. Toutes les fonctions de ce module sont accessibles
directement dans n'importe quel de vos fichiers.</p>
<p>Les fonctions de Reason sont beaucoup plus puissantes qu'en JavaScript:</p>
<pre><code class="hljs language-reason">let <span class="hljs-keyword">add </span>= (a, <span class="hljs-keyword">b) </span>=> a + <span class="hljs-keyword">b;
</span><span class="hljs-comment">/* int => int => int */</span>
<span class="hljs-keyword">add(1, </span><span class="hljs-number">2</span>)<span class="hljs-comment">;</span>
<span class="hljs-comment">/* 3 */</span>
<span class="hljs-keyword">add(1, </span><span class="hljs-number">2</span>.<span class="hljs-number">0</span>)<span class="hljs-comment">;</span>
<span class="hljs-comment">/* This expression has type float but an expression was expected of type int */</span>

<span class="hljs-comment">/* Les fonctions sont "auto-curried", ce qui signifie qu'une fonction
   qui n'a pas reçu tous ses paramètres retourne une nouvelle fonction
  qui va recevoir les paramètres manquants */</span>
let <span class="hljs-keyword">addOne </span>= <span class="hljs-keyword">add(1);
</span><span class="hljs-comment">/* int => int */</span>

<span class="hljs-comment">/* Les fonctions peuvent avoir des paramètres nommés, optionnels et avec des valeurs par défaut */</span>
let sayHi = (~name, ~punct=<span class="hljs-string">"!"</span>, ()) => <span class="hljs-string">"Hello "</span> ++ name ++ punct<span class="hljs-comment">;</span>
<span class="hljs-comment">/* name::string => string */</span>
sayHi(~name=<span class="hljs-string">"you"</span>, ())<span class="hljs-comment">;</span>
<span class="hljs-comment">/* "Hello you!" */</span>
<span class="hljs-comment">/* L'ordre des arguments nommés n'a pas d'importance*/</span>
sayHi(~punct,<span class="hljs-string">"?"</span>, ~name=<span class="hljs-string">"you"</span>, ())<span class="hljs-comment">;</span>
<span class="hljs-comment">/* "Hello you?" */</span></code></pre>
<p>Pour définir l'équivalent d'un <em>plain-object</em> JavaScript en Reason, on utilise
des records:</p>
<pre><code class="hljs language-reason">/* On doit typer les records */
<span class="hljs-keyword">type</span> <span class="hljs-keyword">user</span> <span class="hljs-title">= {
  username</span>: <span class="hljs-keyword">string</span>,
  age: int
};

/* Les records ont un nombre de clés fini, vous <span class="hljs-keyword">ne</span> pouvez pas en
  ommettre une ou en mettre une en trop */
let <span class="hljs-keyword">user</span> <span class="hljs-title">= { username</span>: <span class="hljs-string">"Bob"</span> };
/* Error: Some record fields are undefined: age */

let <span class="hljs-keyword">user</span> <span class="hljs-title">= { username</span>: <span class="hljs-string">"Bob"</span>, age: <span class="hljs-number">20</span> };

/* Les records sont immutables par défaut */
let olderUser = {...user, age: user.age + <span class="hljs-number">1</span> };</code></pre>
<p>Reason possède un système de module très puissant: par défaut, chaque fichier de
votre codebase est un module, mais vous pouvez également déclarer des modules
<em>dans</em> un module.</p>
<pre><code class="hljs language-reason"><span class="hljs-keyword">module</span> User = {
  <span class="hljs-keyword">type</span> t = {
    id: <span class="hljs-built_in">string</span>,
    username: <span class="hljs-built_in">string</span>,
    email: option(<span class="hljs-built_in">string</span>)
  };
  <span class="hljs-keyword">let</span> make = <span class="hljs-function">(<span class="hljs-params">~id, ~username, ~email</span>) =></span> {id, username, email};
  <span class="hljs-keyword">let</span> sayHi = <span class="hljs-function">(<span class="hljs-params">user</span>) =></span> <span class="hljs-string">"Hello "</span> ++ user.username ++ <span class="hljs-string">"!"</span>;
};

<span class="hljs-comment">/* Pour utiliser un module, tapez son nom, tout simplement */</span>
User.make(~id=<span class="hljs-string">"0"</span>, ~username=<span class="hljs-string">"bloodyowl"</span>, ~email=None)
  <span class="hljs-comment">/* (ah oui, le pipe existe déjà ici, pas besoin d'attendre ES2050)*/</span>
  |> User.sayHi
  |> print_endline;
<span class="hljs-comment">/* "Hello bloodyowl" */</span>

<span class="hljs-comment">/* On peut également rendre toutes les valeurs d'un module accessibles localement */</span>
User.(
  make(~id=<span class="hljs-string">"0"</span>, ~username=<span class="hljs-string">"bloodyowl"</span>, ~email=None)
    |> sayHi
    |> print_endline
);

<span class="hljs-comment">/* Carrément les rendre accessibles globalement dans le module */</span>
open User;

make(~id=<span class="hljs-string">"0"</span>, ~username=<span class="hljs-string">"bloodyowl"</span>, ~email=None)
  |> sayHi
  |> print_endline;

<span class="hljs-comment">/* Ou même étendre un module statiquement et proprement,
  ça vous parle ça, Prototype et MooTools ?! */</span>
<span class="hljs-keyword">module</span> UserThatCanSayBye = {
  include User;
  <span class="hljs-keyword">let</span> sayBye = <span class="hljs-function">(<span class="hljs-params">user</span>) =></span> <span class="hljs-string">"Bye "</span> ++ user.username ++ <span class="hljs-string">"!"</span>;
};</code></pre>
<p>Il existe également des functors, qui sont des sortes de fonctions retournant
des modules à partir d'autres modules, mais on ne l'abordera pas dans cet
article.</p>
<p>Reason possède également des variants, il s'agit de types pouvant avoir
différents cas. Prenons l'exemple d'un message de chat:</p>
<pre><code class="hljs language-reason">type <span class="hljs-built_in">image</span> = {url: <span class="hljs-keyword">string</span>, <span class="hljs-built_in">width</span>: <span class="hljs-keyword">int</span>, <span class="hljs-built_in">height</span>: <span class="hljs-keyword">int</span>};

<span class="hljs-comment">/* chaque cas du variant peut prendre des paramètres */</span>
type message =
  | <span class="hljs-keyword">String</span>(<span class="hljs-keyword">string</span>) <span class="hljs-comment">/* soit une chaîne de caractères */</span>
  | Image(<span class="hljs-built_in">image</span>) <span class="hljs-comment">/* soit une image */</span>
  | Emoji(<span class="hljs-keyword">string</span>); <span class="hljs-comment">/* soit un gros emoji */</span>

let stringMessage = <span class="hljs-keyword">String</span>(<span class="hljs-string">"Hello"</span>); <span class="hljs-comment">/* On crée la valeur avec son constructeur */</span>
let imageMessage = Image({url: <span class="hljs-string">"https://fakeimg.pl/300x300"</span>, <span class="hljs-built_in">width</span>: <span class="hljs-number">300</span>, <span class="hljs-built_in">height</span>: <span class="hljs-number">300</span>});
let emojiMessage = Emoji({js|🐫|js}); <span class="hljs-comment">/* Quand la string contient de caractères unicode,
  on doit utiliser {js|votre string|js} */</span></code></pre>
<p>Ici, notre type <code>message</code> est bien délimité, et ses valeurs ne peuvent être que
celles que l'on a défini.</p>
<p>Pour utiliser les valeurs d'un variant, on peut les extraire à l'aide de
<code>switch</code>, qui va <em>pattern-matcher</em> pour nous permettre d'identifier et
d'extraire les valeurs.</p>
<pre><code class="hljs language-reason"><span class="hljs-comment">/* Petit bonus, l'exemple utilise ReasonReact, mais on détaillera ça dans un prochain article */</span>
<span class="hljs-keyword">let</span> component = ReasonReact.statelessComponent(<span class="hljs-string">"ChatMessage"</span>);

<span class="hljs-keyword">let</span> make = <span class="hljs-function">(<span class="hljs-params">~message, _children</span>) =></span> {
  ...component,
  <span class="hljs-attr">render</span>: <span class="hljs-function">(<span class="hljs-params">_</span>) =></span>
    &#x3C;div>
      (<span class="hljs-keyword">switch</span> message {
        | <span class="hljs-built_in">String</span>(value) => ReasonReact.stringToElement(value)
        | Image({<span class="hljs-attr">url</span>: src, width, height}) => <span class="xml"><span class="hljs-tag">&#x3C;<span class="hljs-name">img</span> <span class="hljs-attr">width</span> <span class="hljs-attr">height</span> <span class="hljs-attr">src</span> /></span>
        /* Si par mégarde j'oublie un cas possible dans un switch, je vais avoir un joli warning du
          compiler qui me dira:
            This pattern-matching is not exhaustive.
            Here is an example of a value that is not matched:
              Emoji
        */
        | Emoji(value) =>
          </span>&#x3C;div style=(ReactDOMRe.Style.make(~fontSize="40px", ()))>
            (ReasonReact.stringToElement(value))
          &#x3C;/div><span class="xml">
      })
    <span class="hljs-tag">&#x3C;/<span class="hljs-name">div</span>></span></span>
};</code></pre>
<p>En Reason, les <em>let bindings</em> ont automatiquement le block parent comme scope,
on peut du coup écrire des choses comme ceci :</p>
<pre><code class="hljs language-reason"><span class="hljs-keyword">let</span> <span class="hljs-attr">value</span> = {
  <span class="hljs-keyword">let</span> <span class="hljs-attr">a</span> = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">let</span> <span class="hljs-attr">b</span> = <span class="hljs-number">2</span>;
  a + b; <span class="hljs-comment">/* la dernière expression est toujours retournée par défaut */</span>
};
<span class="hljs-comment">/* let value : int = 3 */</span>
a
<span class="hljs-comment">/* Error: Unbound value a */</span></code></pre>
<p>Voilà pour l'introduction à ReasonML, pour en découvrir un peu plus je vous
invite à aller lire la <a href="https://reasonml.github.io/">documentation officielle</a>.
On verra dans les prochains articles comment fonctionne
<a href="https://reasonml.github.io/reason-react">ReasonReact</a> (les bindings Reason vers
React, avec quelques petites features sympathiques en plus), et comment
l'adopter incrémentalement dans sa codebase pour avoir du code plus sûr, et
<em>(spoilers)</em>, plus rapide que si vous l'écriviez à la main.</p>
<p>Bisous bisous.</p>
]]></description><link>http://putaindecode.io/fr/articles/reason/introduction-reason/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/reason/introduction-reason/</guid><pubDate>Mon, 02 Oct 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Podcast 6: L'air chaud]]></title><description><![CDATA[<p>Un épisode en petit comité:</p>
<ul>
<li>Zoontek (<a href="https://twitter.com/Zoontek">https://twitter.com/Zoontek</a>)</li>
<li>Matthias (<a href="https://twitter.com/bloodyowl">https://twitter.com/bloodyowl</a>)</li>
</ul>
<p>On vous parle de ReasonML, une nouvelle syntaxe et tooling pour rendre OCaml
plus accessible, et on s'attarde un peu sur ce dernier, ainsi que sur
l'écosystème permettant à Reason d'être utilisé avec JavaScript.</p>
<p>On vous présente également de manière détaillée ReactNative, le framework qui
permet de créer des applications natives avec React en JavaScript.</p>
<p>Les quelques liens (si peu):</p>
<ul>
<li>Reason <a href="https://facebook.github.io/reason/">https://facebook.github.io/reason/</a></li>
<li>OCaml <a href="https://ocaml.org">https://ocaml.org</a></li>
<li>Les containers OCaml
<a href="https://ocaml.org/learn/tutorials/comparison_of_standard_containers.html">https://ocaml.org/learn/tutorials/comparison_of_standard_containers.html</a></li>
<li>js_of_ocaml <a href="http://ocsigen.org/js_of_ocaml/">http://ocsigen.org/js_of_ocaml/</a></li>
<li>BuckleScript <a href="http://bucklescript.github.io/bucklescript/Manual.html">http://bucklescript.github.io/bucklescript/Manual.html</a></li>
<li>BuckleScript Reason (online demo)
<a href="http://bucklescript.github.io/bucklescript/reason-demo/">http://bucklescript.github.io/bucklescript/reason-demo/</a></li>
<li>BuckleScript benchmark <a href="https://github.com/neonsquare/bucklescript-benchmark">https://github.com/neonsquare/bucklescript-benchmark</a></li>
<li>ReasonReact <a href="https://reasonml.github.io/reason-react/">https://reasonml.github.io/reason-react/</a></li>
<li>ReReactPrimitives (petit travail perso qui peut aider à aborder la syntaxe)
<a href="https://github.com/bloodyowl/reReactPrimitives">https://github.com/bloodyowl/reReactPrimitives</a></li>
<li>BuckleScript TEA <a href="https://github.com/OvermindDL1/bucklescript-tea">https://github.com/OvermindDL1/bucklescript-tea</a></li>
<li>Discord ReasonML <a href="https://discord.gg/reasonml">https://discord.gg/reasonml</a></li>
<li>ReactNative <a href="https://facebook.github.io/react-native/">https://facebook.github.io/react-native/</a></li>
<li>ReactNative Changelog <a href="https://github.com/facebook/react-native/releases">https://github.com/facebook/react-native/releases</a></li>
<li>MetroBundler <a href="https://github.com/facebook/metro-bundler">https://github.com/facebook/metro-bundler</a></li>
<li>Create React Native App
<a href="https://facebook.github.io/react-native/blog/2017/03/13/introducing-create-react-native-app.html">https://facebook.github.io/react-native/blog/2017/03/13/introducing-create-react-native-app.html</a></li>
<li>Expo <a href="https://expo.io">https://expo.io</a></li>
<li>Qui utilise ReactNative ?
<a href="https://facebook.github.io/react-native/showcase.html">https://facebook.github.io/react-native/showcase.html</a></li>
<li>Animated <a href="https://github.com/animatedjs/animated">https://github.com/animatedjs/animated</a></li>
<li>ReactNativeWeb <a href="https://github.com/necolas/react-native-web/">https://github.com/necolas/react-native-web/</a></li>
<li>ReactPrimitives <a href="https://github.com/lelandrichardson/react-primitives">https://github.com/lelandrichardson/react-primitives</a></li>
<li>NativeModules
<a href="https://facebook.github.io/react-native/docs/native-modules-ios.html">https://facebook.github.io/react-native/docs/native-modules-ios.html</a></li>
<li>React Navigation <a href="https://github.com/react-community/react-navigation">https://github.com/react-community/react-navigation</a></li>
<li>React Native Maps airbnb/react-native-maps</li>
<li>Lottie React Native <a href="https://github.com/airbnb/lottie-react-native">https://github.com/airbnb/lottie-react-native</a></li>
<li>React Native Vector Icons <a href="https://github.com/oblador/react-native-vector-icons">https://github.com/oblador/react-native-vector-icons</a></li>
<li>React Native Animatable <a href="https://github.com/oblador/react-native-animatable">https://github.com/oblador/react-native-animatable</a></li>
<li>BuckleScript React Native <a href="https://github.com/BuckleTypes/bs-react-native">https://github.com/BuckleTypes/bs-react-native</a></li>
</ul>
<p>La track du générique:</p>
<p><a href="https://soundcloud.com/matthias-le-brun/moon">https://soundcloud.com/matthias-le-brun/moon</a></p>
<iframe width="100%" height="450" scrolling="no" frameborder="no" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/329979777&amp;auto_play=false&amp;hide_related=false&amp;show_comments=true&amp;show_user=true&amp;show_reposts=false&amp;visual=true"></iframe>
<ul>
<li>Le
<a href="http://feeds.soundcloud.com/users/soundcloud:users:273901232/sounds.rss">RSS</a></li>
<li>Sur iTunes : <a href="https://itunes.apple.com/fr/podcast/putain-de-code-!/id1185311825?l=en&#x26;mt=2">Putain de
Code</a></li>
</ul>
]]></description><link>http://putaindecode.io/fr/articles/podcast/6/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/podcast/6/</guid><pubDate>Tue, 27 Jun 2017 00:00:00 GMT</pubDate></item><item><title><![CDATA[Podcast 5: On va tous crever !]]></title><description><![CDATA[<p>Très certainement notre pire épisode, en tout cas le plus pénible à monter.</p>
<p>Sont présents mentalement dans la pièce dans laquelle s'est déroulé
l'enregistrement :</p>
<ul>
<li>Georges (<a href="https://twitter.com/skinnyfoetusboy">https://twitter.com/skinnyfoetusboy</a>)</li>
<li>Mathieu (<a href="https://twitter.com/Zoontek">https://twitter.com/Zoontek</a>)</li>
<li>Matthias (<a href="https://twitter.com/bloodyowl">https://twitter.com/bloodyowl</a>)</li>
</ul>
<p>Est présent physiquement:</p>
<ul>
<li>Maxime Thirouin ouin ouin (<a href="https://twitter.com/MoOx">https://twitter.com/MoOx</a>)</li>
</ul>
<p>On vous parle du concept d'immutabilité, du nouvel outil Prettier ainsi que du
langage Go que Mathieu nous présente.</p>
<p>Liens:</p>
<ul>
<li>Prettier: <a href="https://github.com/prettier/prettier">https://github.com/prettier/prettier</a></li>
<li>LearnXInYMinutes: <a href="https://learnxinyminutes.com">https://learnxinyminutes.com</a></li>
</ul>
<p>Erratum par avance:</p>
<ul>
<li>Go en JS, ça existe: <a href="https://github.com/gopherjs/gopherjs">https://github.com/gopherjs/gopherjs</a></li>
<li>Go a vraiment une tabulation à la con: <a href="https://golang.org/cmd/gofmt/">https://golang.org/cmd/gofmt/</a></li>
</ul>
<iframe width="100%" height="450" scrolling="no" frameborder="no" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/320551397&amp;auto_play=false&amp;hide_related=false&amp;show_comments=true&amp;show_user=true&amp;show_reposts=false&amp;visual=true"></iframe>
<ul>
<li>Le
<a href="http://feeds.soundcloud.com/users/soundcloud:users:273901232/sounds.rss">RSS</a></li>
<li>Sur iTunes : <a href="https://itunes.apple.com/fr/podcast/putain-de-code-!/id1185311825?l=en&#x26;mt=2">Putain de
Code</a></li>
</ul>
]]></description><link>http://putaindecode.io/fr/articles/podcast/5/</link><guid isPermaLink="true">http://putaindecode.io/fr/articles/podcast/5/</guid><pubDate>Wed, 03 May 2017 00:00:00 GMT</pubDate></item></channel></rss>