{"head":{"layout":"Post","comments":true,"date":"2017-11-16","title":"La programmation reactive avec RxJS","tags":["Observable","JavaScript"],"authors":["wyeo"],"description":"La programmation réactive est un paradigme de programmation dont le concept repose sur l'émission de données depuis une ou plusieurs…"},"body":"<p>La <a href=\"https://www.reactivemanifesto.org/fr\">programmation réactive</a> est un paradigme de programmation dont le concept repose sur l'émission de données depuis une ou plusieurs sources (producteurs) à destinations d'autres éléments appelés <em>consommateurs</em>. Elle repose sur le design pattern <a href=\"http://design-patterns.fr/observateur\">Observable - Observer</a>.</p>\n<p>Dans ce paradigme, on traite toutes les données, quelles qu'elles soient, de la même façon: au travers de flux. Un flux, c'est en gros une structure qui balance une ou plusieurs données dans le temps au travers d'observables, comme on l'a vu dans le <a href=\"/fr/articles/js/observable/\">post précédent</a>.</p>\n<p><img src=\"https://i.imgur.com/NLqK4bF.png\" alt=\"Programmation Réactive\"></p>\n<p>Un flux, pour résumer, c'est simplement de la donnée qui arrive de manière ordonnée dans le temps. Comme expliqué précédemment, trois types de signaux peuvent être émis par un flux : une valeur, une erreur ou un signal de fin indiquant que le flux n'a plus de données à envoyer.</p>\n<p>L'idée des flux, c'est cool, mais comment on manipule ça ?</p>\n<h2 id=\"la-bibliothèque-rxjs\"><a href=\"#la-biblioth%C3%A8que-rxjs\" class=\"phenomic-HeadingAnchor\">#</a>La bibliothèque RxJS</h2>\n<p><a href=\"https://github.com/Reactive-Extensions/RxJS/blob/master/doc/libraries/main/rx.md\">RxJS</a> est l'implémentation JavaScript de <a href=\"http://reactivex.io/\">ReactiveX</a>, <em>extensions-réactives</em> en français, un projet visant à implémenter sous la forme de bibliothèque les outils nécessaire pour utiliser le paradigme réactif dans de multiples languages.\nAussi appelé le <strong>Lodash</strong> des données asynchrones, il implémente la notion d'observables-observer et fournit tout un panel d'opérateurs pour travailler avec les données qui y passent.</p>\n<p>Vous pourrez facilement intégrer progressivement Rx à votre codebase à l'aide d'opérateurs tels que <code>Rx.from</code> (qui crée un observable à partir d'une valeur synchrone), <code>Rx.fromEvent</code> (qui va carrément écouter les évenement DOM d'un élement pour en faire un observable), <code>Rx.fromPromise</code>, <code>Rx.Ajax</code> et bien d'autres.</p>\n<p>Exemple tout simple : on va compter le nombre de clics sur un bouton.</p>\n<pre><code class=\"hljs language-JavaScript\"><span class=\"hljs-keyword\">const</span> Rx = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'rxjs'</span>)\n\n<span class=\"hljs-comment\">// on écoute les clics</span>\n<span class=\"hljs-keyword\">const</span> button$ = Rx.Observable.fromEvent(<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">\"button\"</span>), <span class=\"hljs-string\">\"click\"</span>)\n  <span class=\"hljs-comment\">// scan est l'équivalent de reduce ; il va garder l'accumulateur et retourner le nouveau à chaque clic</span>\n  .scan(<span class=\"hljs-function\"><span class=\"hljs-params\">count</span> =></span> count + <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>)\n  .subscribe(<span class=\"hljs-function\"><span class=\"hljs-params\">clickCount</span> =></span> {\n    <span class=\"hljs-comment\">// on met ça dans le DOM à chaque changement</span>\n    <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">\"count\"</span>).innerHTML = <span class=\"hljs-string\">\"You clicked \"</span> + clickCount + <span class=\"hljs-string\">\" times\"</span>\n  })</code></pre>\n<p>Si vous vous demandez pourquoi <code>button$</code> et pas <code>button</code>, c'est que le suffixe <strong>$</strong> est une convention montrant qu'il s'agit d'un flux.</p>\n<p>La programmation réactive peut être compliquée à se représenter, ainsi, pour mieux la visualiser, il existe les <a href=\"http://rxmarbles.com/\"><code>marbles diagrams</code></a> qui vous permettront de mettre en rapport entrée et sortie de chaque transformation de la data avec une idée plus concrète que de simples bouts de code.</p>\n<p>Le cœur de la programmation réactive, c'est de concevoir votre programme comme quelque chose qui est valable à n'importe quel point dans le temps, et c'est son avantage principal. Si une donnée change, toutes les parties de votre programme l'utilisant en seront notifiées et pourront agir en conséquence.</p>\n<p>Si vos programmes récupèrent des données de manière asynchrone (et il y a de fortes chances pour que ce soit le cas), ça peut valoir le coup de jeter un œil à ce paradigme, vous pourrez peut-être vous enlever un paquet d'épines du pied.</p>\n<p>Dans le prochain chapitre, nous verrons les cas d'usages des Observables au sein d'une application React/Redux.</p>\n","rawBody":"\nLa [programmation réactive](https://www.reactivemanifesto.org/fr) est un paradigme de programmation dont le concept repose sur l'émission de données depuis une ou plusieurs sources (producteurs) à destinations d'autres éléments appelés *consommateurs*. Elle repose sur le design pattern [Observable - Observer](http://design-patterns.fr/observateur).\n\nDans ce paradigme, on traite toutes les données, quelles qu'elles soient, de la même façon: au travers de flux. Un flux, c'est en gros une structure qui balance une ou plusieurs données dans le temps au travers d'observables, comme on l'a vu dans le [post précédent](/fr/articles/js/observable/).\n\n![Programmation Réactive](https://i.imgur.com/NLqK4bF.png)\n\n\nUn flux, pour résumer, c'est simplement de la donnée qui arrive de manière ordonnée dans le temps. Comme expliqué précédemment, trois types de signaux peuvent être émis par un flux : une valeur, une erreur ou un signal de fin indiquant que le flux n'a plus de données à envoyer.\n\nL'idée des flux, c'est cool, mais comment on manipule ça ?\n\n## La bibliothèque RxJS\n\n[RxJS](https://github.com/Reactive-Extensions/RxJS/blob/master/doc/libraries/main/rx.md) est l'implémentation JavaScript de [ReactiveX](http://reactivex.io/), *extensions-réactives* en français, un projet visant à implémenter sous la forme de bibliothèque les outils nécessaire pour utiliser le paradigme réactif dans de multiples languages.\nAussi appelé le **Lodash** des données asynchrones, il implémente la notion d'observables-observer et fournit tout un panel d'opérateurs pour travailler avec les données qui y passent.\n\nVous pourrez facilement intégrer progressivement Rx à votre codebase à l'aide d'opérateurs tels que `Rx.from` (qui crée un observable à partir d'une valeur synchrone), `Rx.fromEvent` (qui va carrément écouter les évenement DOM d'un élement pour en faire un observable), `Rx.fromPromise`, `Rx.Ajax` et bien d'autres.\n\nExemple tout simple : on va compter le nombre de clics sur un bouton.\n\n```JavaScript\nconst Rx = require('rxjs')\n\n// on écoute les clics\nconst button$ = Rx.Observable.fromEvent(document.getElementById(\"button\"), \"click\")\n  // scan est l'équivalent de reduce ; il va garder l'accumulateur et retourner le nouveau à chaque clic\n  .scan(count => count + 1, 0)\n  .subscribe(clickCount => {\n    // on met ça dans le DOM à chaque changement\n    document.getElementById(\"count\").innerHTML = \"You clicked \" + clickCount + \" times\"\n  })\n```\n\nSi vous vous demandez pourquoi `button$` et pas `button`, c'est que le suffixe **$** est une convention montrant qu'il s'agit d'un flux.\n\nLa programmation réactive peut être compliquée à se représenter, ainsi, pour mieux la visualiser, il existe les [`marbles diagrams`](http://rxmarbles.com/) qui vous permettront de mettre en rapport entrée et sortie de chaque transformation de la data avec une idée plus concrète que de simples bouts de code.\n\nLe cœur de la programmation réactive, c'est de concevoir votre programme comme quelque chose qui est valable à n'importe quel point dans le temps, et c'est son avantage principal. Si une donnée change, toutes les parties de votre programme l'utilisant en seront notifiées et pourront agir en conséquence.\n\nSi vos programmes récupèrent des données de manière asynchrone (et il y a de fortes chances pour que ce soit le cas), ça peut valoir le coup de jeter un œil à ce paradigme, vous pourrez peut-être vous enlever un paquet d'épines du pied.\n\nDans le prochain chapitre, nous verrons les cas d'usages des Observables au sein d'une application React/Redux.\n","__filename":"fr/articles/js/observable/programmation-reactive.md","__url":"/fr/articles/js/observable/programmation-reactive/","__resourceUrl":"/fr/articles/js/observable/programmation-reactive/index.html","__dataUrl":"/fr/articles/js/observable/programmation-reactive/index.html.521486c5e550df1d4d0f63cac8fa4719.json"}