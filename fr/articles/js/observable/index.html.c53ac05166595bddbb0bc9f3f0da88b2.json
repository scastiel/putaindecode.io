{"head":{"layout":"Post","comments":true,"date":"2017-10-23","title":"Introduction aux pattern des observables","tags":["Observable","JavaScript"],"authors":["wyeo"],"description":"En JavaScript, nous pouvons exécuter du code de manière synchrone (bloquant) ou asynchrone (non bloquant). Prenons une fonction logValue,…"},"body":"<p>En JavaScript, nous pouvons exécuter du code de manière synchrone (bloquant) ou\nasynchrone (non bloquant).</p>\n<p>Prenons une fonction <code>logValue</code>, qui prend une valeur et l'affiche dans la\nconsole :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">logValue</span>(<span class=\"hljs-params\">value</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(value);\n}</code></pre>\n<p>Nous allons passer <code>logValue</code> comme callback à la méthode\n<code>Array.prototype.forEach</code>, qui va l'exécuter de manière <strong>synchrone</strong> :</p>\n<pre><code class=\"hljs language-JavaScript\"><span class=\"hljs-keyword\">const</span> arrayOfValues = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]\n\narrayOfValues.forEach(logValue)\n<span class=\"hljs-comment\">// Log 1, 2, 3, 4 puis 5</span></code></pre>\n<p>On peut également passer <code>logValue</code> comme callback de <code>setTimeout</code>, qui va\nl'exécuter de manière <strong>asynchrone</strong> :</p>\n<pre><code class=\"hljs language-JavaScript\">setTimeout(logValue, <span class=\"hljs-number\">3000</span>, <span class=\"hljs-string\">\"Hello world!\"</span>)\nlogValue(<span class=\"hljs-string\">\"How are you?\"</span>)\n<span class=\"hljs-comment\">// Log \"How are you?\"</span>\n<span class=\"hljs-comment\">// Log \"Hello world!\" 3 secondes plus tard</span></code></pre>\n<p>Une fonction est agnostique: elle peut être appelée de manière synchrone ou\nasynchrone, c'est la façon dont elle est exécutée qui définira le \"mode\".</p>\n<p>Un cas où il est utile d'utiliser des APIs asynchrones avec Node.js: les accès\nau <em>file-system</em>. Si vous lisez un gros fichier en mode synchrone, il va bloquer\nl'exécution de votre programme tant qu'il n'a pas fini, mieux vaut attendre\nqu'il vous l'envoie quand il est prêt.</p>\n<p>Node.js propose l'API suivante: <code>fs.readFile(fileToRead, options, callback)</code></p>\n<pre><code class=\"hljs language-JavaScript\">fs.readFile(<span class=\"hljs-string\">\"./alphabet.txt\"</span>, {<span class=\"hljs-attr\">encoding</span>: <span class=\"hljs-string\">\"utf-8\"</span>}, (err, data) => {\n  <span class=\"hljs-keyword\">if</span> (err) {\n    onError(err)\n  } <span class=\"hljs-keyword\">else</span> {\n    onData(data)\n  }\n})</code></pre>\n<p>Cet exemple montre une API utilisant un simple callback qui est exécuté lorsque\n<code>readFile</code> a lu le fichier ou échoué à le faire.</p>\n<p>Un autre cas où utiliser des APIs asynchrones est particulièrement important :\nles appels réseaux. On ne peut pas se permettre de <em>freeze</em> toute notre\ninterface pendant que la requête réseau tourne.</p>\n<pre><code class=\"hljs language-JavaScript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">logValue</span>(<span class=\"hljs-params\">value</span>) </span>{ <span class=\"hljs-built_in\">console</span>.log(value) }\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">logError</span>(<span class=\"hljs-params\">err</span>) </span>{ <span class=\"hljs-built_in\">console</span>.error(err) }\n\nfetch(<span class=\"hljs-string\">\"https://api.github.com/users/wyeo\"</span>)\n  .then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =></span> res.json())\n  .then(logValue) <span class=\"hljs-comment\">// Log le payload JSON lorsque la requête est terminée</span>\n  .catch(logError) <span class=\"hljs-comment\">// Lance une erreur dans la console si quelque chose s'est mal passé</span></code></pre>\n<p>Dans cet exemple, l'API renvoie une <code>Promise</code>: <a href=\"/fr/articles/js/es2015/promises/\">une structure représentant une\nvaleur potentielle</a>. Lorsque sa valeur est\ndisponible, la promesse est <em>remplie</em>, et exécutera les callbacks qu'on lui a\npassé dans <code>.then</code>, si elle constate une erreur, elle exécutera les callbacks\nqu'on lui a passé dans <code>.catch</code>.</p>\n<p>Les <code>Promise</code> ne permettent cependant pas de traiter de la donnée au fur et à\nmesure de son arrivée: elle est remplie une seule fois.</p>\n<p>C'est là que les <code>Observable</code> arrivent à la rescousse.</p>\n<p>Un <code>Observable</code> est un objet implémentant une méthode <code>.subscribe</code> qui prend\ncomme paramètre un <code>Observer</code>. Ce dernier a cette forme :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> observer = {\n  <span class=\"hljs-attr\">next</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =></span> <span class=\"hljs-built_in\">console</span>.log(val), <span class=\"hljs-comment\">// une fonction à exécuter à chaque nouvel évenement</span>\n  error: <span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =></span> <span class=\"hljs-built_in\">console</span>.error(err), <span class=\"hljs-comment\">// une fonction à exécuter en cas d'erreur</span>\n  complete: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> <span class=\"hljs-built_in\">console</span>.info(<span class=\"hljs-string\">\"Complete!\"</span>) <span class=\"hljs-comment\">// une fonction à exécuter lorsque l'observable a fini</span>\n};</code></pre>\n<p>Implémentons naïvement un <code>Observable</code> qui va réagir lorsqu'un user va taper sur\nson clavier et se considérer terminé une fois <code>Enter</code> pressé:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> KeyboardObservable = {\n  <span class=\"hljs-attr\">subscribe</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">observer</span> =></span> {\n    <span class=\"hljs-keyword\">const</span> handleKeyUp = <span class=\"hljs-function\"><span class=\"hljs-params\">event</span> =></span> {\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> event.keyCode === <span class=\"hljs-string\">\"number\"</span>) {\n        <span class=\"hljs-keyword\">if</span> (event.keyCode === <span class=\"hljs-number\">13</span> <span class=\"hljs-comment\">/* Enter */</span>) {\n          <span class=\"hljs-built_in\">document</span>.removeEventListener(<span class=\"hljs-string\">\"keyup\"</span>, handleKeyUp);\n          observer.complete();\n        } <span class=\"hljs-keyword\">else</span> {\n          observer.next(event.keyCode);\n        }\n      } <span class=\"hljs-keyword\">else</span> {\n        observer.error(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">\"No keyCode found\"</span>));\n      }\n    };\n    <span class=\"hljs-built_in\">document</span>.addEventListener(<span class=\"hljs-string\">\"keyup\"</span>, handleKeyUp);\n    <span class=\"hljs-comment\">// subscribe retourne la \"soucription\", contenant une fonction pour la stopper</span>\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">unsubscribe</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> <span class=\"hljs-built_in\">document</span>.removeEventListener(<span class=\"hljs-string\">\"keyup\"</span>, handleKeyUp)\n    };\n  }\n};\n\n<span class=\"hljs-keyword\">let</span> keys = [];\nKeyboardObservable.subscribe({\n  <span class=\"hljs-attr\">next</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">keyCode</span> =></span> keys.push(<span class=\"hljs-built_in\">String</span>.fromCharCode(keyCode)),\n  <span class=\"hljs-attr\">error</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =></span> <span class=\"hljs-built_in\">console</span>.error(error),\n  <span class=\"hljs-attr\">complete</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> alert(keys.join(<span class=\"hljs-string\">\"\"</span>))\n});</code></pre>\n<p>Un <code>Observable</code> fonctionne à la fois pour du code synchrone et asynchrone, et il\ns'agit d'un pattern qui peut s'appliquer à des cas où <code>Promise</code> manque de\ngranularité, puisqu'il permet de traiter la donnée au fur et à mesure de son\narrivée. <em>In fine</em>, un observable est un <em>event emitter</em> avec un concept de\ncompletion.</p>\n<p>Il existe d'ailleurs un <a href=\"https://tc39.github.io/proposal-observable/\"><em>proposal</em> en stage\n1</a> pour en faire une API de la\nspecification de JavaScript. On peut très bien imaginer que les observables\ndeviennent une interface très répandue dans un futur proche.</p>\n<p>Dans les prochains articles, nous verrons pourquoi et comment combiner des\nobservables ainsi que les cas d'usage au sein d'une application React.</p>\n","rawBody":"\nEn JavaScript, nous pouvons exécuter du code de manière synchrone (bloquant) ou\nasynchrone (non bloquant).\n\nPrenons une fonction `logValue`, qui prend une valeur et l'affiche dans la\nconsole :\n\n```javascript\nfunction logValue(value) {\n  console.log(value);\n}\n```\n\nNous allons passer `logValue` comme callback à la méthode\n`Array.prototype.forEach`, qui va l'exécuter de manière **synchrone** :\n\n```JavaScript\nconst arrayOfValues = [1, 2, 3, 4, 5]\n\narrayOfValues.forEach(logValue)\n// Log 1, 2, 3, 4 puis 5\n```\n\nOn peut également passer `logValue` comme callback de `setTimeout`, qui va\nl'exécuter de manière **asynchrone** :\n\n```JavaScript\nsetTimeout(logValue, 3000, \"Hello world!\")\nlogValue(\"How are you?\")\n// Log \"How are you?\"\n// Log \"Hello world!\" 3 secondes plus tard\n```\n\nUne fonction est agnostique: elle peut être appelée de manière synchrone ou\nasynchrone, c'est la façon dont elle est exécutée qui définira le \"mode\".\n\nUn cas où il est utile d'utiliser des APIs asynchrones avec Node.js: les accès\nau *file-system*. Si vous lisez un gros fichier en mode synchrone, il va bloquer\nl'exécution de votre programme tant qu'il n'a pas fini, mieux vaut attendre\nqu'il vous l'envoie quand il est prêt.\n\nNode.js propose l'API suivante: `fs.readFile(fileToRead, options, callback)`\n\n```JavaScript\nfs.readFile(\"./alphabet.txt\", {encoding: \"utf-8\"}, (err, data) => {\n  if (err) {\n    onError(err)\n  } else {\n    onData(data)\n  }\n})\n```\n\nCet exemple montre une API utilisant un simple callback qui est exécuté lorsque\n`readFile` a lu le fichier ou échoué à le faire.\n\nUn autre cas où utiliser des APIs asynchrones est particulièrement important :\nles appels réseaux. On ne peut pas se permettre de _freeze_ toute notre\ninterface pendant que la requête réseau tourne.\n\n```JavaScript\nfunction logValue(value) { console.log(value) }\nfunction logError(err) { console.error(err) }\n\nfetch(\"https://api.github.com/users/wyeo\")\n  .then(res => res.json())\n  .then(logValue) // Log le payload JSON lorsque la requête est terminée\n  .catch(logError) // Lance une erreur dans la console si quelque chose s'est mal passé\n```\n\nDans cet exemple, l'API renvoie une `Promise`: [une structure représentant une\nvaleur potentielle](/fr/articles/js/es2015/promises/). Lorsque sa valeur est\ndisponible, la promesse est *remplie*, et exécutera les callbacks qu'on lui a\npassé dans `.then`, si elle constate une erreur, elle exécutera les callbacks\nqu'on lui a passé dans `.catch`.\n\nLes `Promise` ne permettent cependant pas de traiter de la donnée au fur et à\nmesure de son arrivée: elle est remplie une seule fois.\n\nC'est là que les `Observable` arrivent à la rescousse.\n\nUn `Observable` est un objet implémentant une méthode `.subscribe` qui prend\ncomme paramètre un `Observer`. Ce dernier a cette forme :\n\n```javascript\nconst observer = {\n  next: val => console.log(val), // une fonction à exécuter à chaque nouvel évenement\n  error: err => console.error(err), // une fonction à exécuter en cas d'erreur\n  complete: () => console.info(\"Complete!\") // une fonction à exécuter lorsque l'observable a fini\n};\n```\n\nImplémentons naïvement un `Observable` qui va réagir lorsqu'un user va taper sur\nson clavier et se considérer terminé une fois `Enter` pressé:\n\n```javascript\nconst KeyboardObservable = {\n  subscribe: observer => {\n    const handleKeyUp = event => {\n      if (typeof event.keyCode === \"number\") {\n        if (event.keyCode === 13 /* Enter */) {\n          document.removeEventListener(\"keyup\", handleKeyUp);\n          observer.complete();\n        } else {\n          observer.next(event.keyCode);\n        }\n      } else {\n        observer.error(new Error(\"No keyCode found\"));\n      }\n    };\n    document.addEventListener(\"keyup\", handleKeyUp);\n    // subscribe retourne la \"soucription\", contenant une fonction pour la stopper\n    return {\n      unsubscribe: () => document.removeEventListener(\"keyup\", handleKeyUp)\n    };\n  }\n};\n\nlet keys = [];\nKeyboardObservable.subscribe({\n  next: keyCode => keys.push(String.fromCharCode(keyCode)),\n  error: error => console.error(error),\n  complete: () => alert(keys.join(\"\"))\n});\n```\n\nUn `Observable` fonctionne à la fois pour du code synchrone et asynchrone, et il\ns'agit d'un pattern qui peut s'appliquer à des cas où `Promise` manque de\ngranularité, puisqu'il permet de traiter la donnée au fur et à mesure de son\narrivée. *In fine*, un observable est un _event emitter_ avec un concept de\ncompletion.\n\nIl existe d'ailleurs un [_proposal_ en stage\n1](https://tc39.github.io/proposal-observable/) pour en faire une API de la\nspecification de JavaScript. On peut très bien imaginer que les observables\ndeviennent une interface très répandue dans un futur proche.\n\nDans les prochains articles, nous verrons pourquoi et comment combiner des\nobservables ainsi que les cas d'usage au sein d'une application React.\n","__filename":"fr/articles/js/observable/index.md","__url":"/fr/articles/js/observable/","__resourceUrl":"/fr/articles/js/observable/index.html","__dataUrl":"/fr/articles/js/observable/index.html.c53ac05166595bddbb0bc9f3f0da88b2.json"}