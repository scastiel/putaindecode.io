{"head":{"layout":"Post","comments":true,"date":"2017-11-13","title":"Top 10 des snippets pour démolir le runtime JavaScript","tags":["javascript","snippets","demolir"],"authors":["bloodyowl"],"header":{"color":"#3A0000","image":"index.jpg"},"description":"(ou juste faire une blague à vos collègues) 10\\. L'array vide magique Cette technique fonctionne grace à l'héritage prototypal et au fait…"},"body":"<p>(ou juste faire une blague à vos collègues)</p>\n<h2 id=\"10-larray-vide-magique\"><a href=\"#10-larray-vide-magique\" class=\"phenomic-HeadingAnchor\">#</a>10. L'array vide magique</h2>\n<p>Cette technique fonctionne grace à l'héritage prototypal et au fait que pour une obscure raison, <code>Array.prototype</code> est un array (qui hérite de lui même, allez savoir). Il suffit d'appeler une des méthodes mutatives d'<code>Array.prototype</code> sur lui-même :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-built_in\">Array</span>.prototype.push(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);</code></pre>\n<p>Puisque dans le corps de <code>Array.prototype.push()</code>, <code>this</code> correspond à <code>Array.prototype</code>, c'est dans celui-ci que seront injectés les éléments.</p>\n<pre><code class=\"hljs language-javascript\">[][<span class=\"hljs-number\">0</span>] <span class=\"hljs-comment\">// 1</span></code></pre>\n<p>Et hop. À noter que vu l'implémentation de la plupart des fonctions travaillant avec des <em>arrays</em>, ça devrait pas causer grand dommage puisque <code>length</code> est géré au niveau de l'array, et pas de son prototype. Ceci-dit ça peut surprendre en faisant mumuse dans la console.</p>\n<h2 id=\"9-lobjet-magique\"><a href=\"#9-lobjet-magique\" class=\"phenomic-HeadingAnchor\">#</a>9. L'objet magique</h2>\n<p>Souvent, dans une boucle <code>for(name in object)</code>, on appelle <code>object.hasOwnProperty(name)</code> pour vérifier si la propriété appartient bien à l'objet et qu'il ne s'agit pas juste d'un truc hérité.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-built_in\">Object</span>.prototype.hasOwnProperty = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> <span class=\"hljs-literal\">true</span>;\n<span class=\"hljs-comment\">// peut se combiner avec un petit</span>\n<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span>; index &#x3C; <span class=\"hljs-number\">10</span>; index++) {\n  <span class=\"hljs-built_in\">Object</span>.prototype[index] = <span class=\"hljs-literal\">undefined</span>;\n};</code></pre>\n<p>Même concept que pour l'exemple précédent, avec l'héritage prototypal. Le petit côté rigolo ici, c'est que c'est un pattern très courant en JavaScript, notamment dans les bibliothèques que vous utilisez probablement. Et c'est là qu'on se rend compte que de mettre la fonction qui vérifie si une propriété est héritée ou non dans l'héritage, c'est pas forcément l'idée du siècle.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">let</span> object = {};\n<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> key <span class=\"hljs-keyword\">in</span> object) {\n  <span class=\"hljs-keyword\">if</span>(object.hasOwnProperty(object)) {\n    <span class=\"hljs-built_in\">console</span>.log(key)\n  }\n}\n<span class=\"hljs-comment\">// 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</span></code></pre>\n<h2 id=\"8-le-dom-fou\"><a href=\"#8-le-dom-fou\" class=\"phenomic-HeadingAnchor\">#</a>8. Le DOM fou</h2>\n<p>Celui-là est plutôt sympa quand vous ou vos bibliothèques DOM de prédilection touchez un peu aux élements. Vu que l'appel à <code>Math.random()</code> rend l'opération aussi déterministe que l'application de styles assignés à des sélecteurs CSS chargés de manière asynchrone, vous risquez de jolies surprises.</p>\n<pre><code class=\"hljs language-javascript\">Element.prototype.appendChild = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">element</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> Element.prototype.insertBefore.call(\n    <span class=\"hljs-keyword\">this</span>,\n    element,\n    <span class=\"hljs-keyword\">this</span>.childNodes[<span class=\"hljs-built_in\">Math</span>.floor(<span class=\"hljs-built_in\">Math</span>.random() * <span class=\"hljs-keyword\">this</span>.childNodes.length)]\n  )\n};</code></pre>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> index = <span class=\"hljs-number\">0</span>; index &#x3C; <span class=\"hljs-number\">10</span>; index++) {\n  <span class=\"hljs-built_in\">document</span>.body.appendChild(<span class=\"hljs-built_in\">document</span>.createTextNode(<span class=\"hljs-built_in\">String</span>(index)))\n};\n<span class=\"hljs-comment\">// \"1895234760\" (par exemple)</span></code></pre>\n<h2 id=\"7-simple-mais-efficace-faire-de-la-console-une-no-op\"><a href=\"#7-simple-mais-efficace-faire-de-la-console-une-no-op\" class=\"phenomic-HeadingAnchor\">#</a>7. Simple mais efficace, faire de la console une no-op</h2>\n<p>Bizarrement, j'ai déjà vu des sites qui faisaient ça en production (e.g. Twitter si je me rappelle correctement). Vous rendez inopérable la console, ce qui peut faire une très bonne blague à vos collègues en cachant ça dans un vieux commit avec l'option <code>amend</code>.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-built_in\">Object</span>.keys(<span class=\"hljs-built_in\">console</span>).forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =></span> {\n  <span class=\"hljs-built_in\">console</span>[key] = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {}\n});</code></pre>\n<h2 id=\"6-supprimer-les-stack-traces-des-erreurs\"><a href=\"#6-supprimer-les-stack-traces-des-erreurs\" class=\"phenomic-HeadingAnchor\">#</a>6. Supprimer les stack traces des erreurs</h2>\n<p>Là, on est vraiment sur le petit truc horrible, parce que vous pouvez mettre un petit moment avant de le réaliser. Le constructeur <code>Error</code> vient normalement ajouter une propriété <code>stack</code> qui vous permet de retrouver le chemin qu'a emprunté le code avant de jeter une erreur. Eh ben fini, à vous le debug à l'aveugle !</p>\n<pre><code class=\"hljs language-javascript\">(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Error</span>(<span class=\"hljs-params\">message</span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.message = message;\n  }\n  <span class=\"hljs-built_in\">Error</span>.prototype = <span class=\"hljs-built_in\">window</span>.Error.prototype;\n  <span class=\"hljs-built_in\">window</span>.Error = <span class=\"hljs-built_in\">Error</span>;\n})();</code></pre>\n<h2 id=\"5-rendre-lasynchrone-synchrone\"><a href=\"#5-rendre-lasynchrone-synchrone\" class=\"phenomic-HeadingAnchor\">#</a>5. Rendre l'asynchrone synchrone</h2>\n<p>Il est assez courrant d'avoir des <code>setTimeout(func)</code> ou <code>setTimeout(func, 0)</code> (les deux sont équivalents). Ça permet s'assurer qu'on décale un peu l'execution d'une fonction, et souvent de s'assurer que si elle jette une erreur, elle n'empêchera pas le reste de s'executer.</p>\n<pre><code class=\"hljs language-javascript\">(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n  <span class=\"hljs-keyword\">let</span> originalTimeout = <span class=\"hljs-built_in\">window</span>.setTimeout;\n  <span class=\"hljs-built_in\">window</span>.setTimeout = <span class=\"hljs-function\">(<span class=\"hljs-params\">func, duration, ...args</span>) =></span> !duration ? func(...args) : originalTimeout.call(<span class=\"hljs-built_in\">window</span>, func, duration, ...args);\n})()</code></pre>\n<p>Avec ce snippet, petites surprises bizarres assurées. Et c'est un bug présent dans quelques bibliothèques implémentant une fonction <code>domReady</code>, et qui font:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">domReady</span>(<span class=\"hljs-params\">func</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">document</span>.readyState === <span class=\"hljs-string\">\"complete\"</span>) {\n    func()\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-built_in\">document</span>.addEventListener(<span class=\"hljs-string\">\"DOMContentLoaded\"</span>, func)\n  }\n}</code></pre>\n<p>Avec une implémentation comme celle qu'on voit au dessus, <code>func</code> aura un comportement différent si le DOM est chargé ou non:</p>\n<pre><code class=\"hljs language-javascript\">domReady(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n  <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>()\n})\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>)\n<span class=\"hljs-comment\">// Logue 1 si le DOM est prêt, parce que l'execution de func par le handler DOMContentLoaded est asynchrone</span>\n<span class=\"hljs-comment\">// Logue rien du tout si func() est appelé en synchrone par la première branche de domReady</span></code></pre>\n<h2 id=\"4-le-réseau-qui-ne-répond-jamais\"><a href=\"#4-le-r%C3%A9seau-qui-ne-r%C3%A9pond-jamais\" class=\"phenomic-HeadingAnchor\">#</a>4. Le réseau qui ne répond jamais</h2>\n<p>Les <code>Promise</code>, c'est bien relou à débugger lorsque ça reste infiniment en \"pending\": on ne sait pas forcément pourquoi, surtout si c'est derrière une API opaque, comme <code>fetch</code>. Plaisir garanti, parce qu'avec ça sur la page, c'est probablement le dernier endroit où on va intuitivement chercher la source la bug.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-built_in\">window</span>.fetch = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {})</code></pre>\n<h2 id=\"3-faire-marcher-les-event-listener-au-hasard\"><a href=\"#3-faire-marcher-les-event-listener-au-hasard\" class=\"phenomic-HeadingAnchor\">#</a>3. Faire marcher les event listener au hasard</h2>\n<p>C'est particulièrement horrible quand un bug n'est pas reproduit à tous les coups: pourquoi ne pas attacher les évenements au hasard ?</p>\n<pre><code class=\"hljs language-javascript\">(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n  <span class=\"hljs-keyword\">let</span> originalAddEventListener = Element.prototype.addEventListener\n  Element.prototype.addEventListener = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">...args</span>) </span>{\n    <span class=\"hljs-keyword\">if</span>(<span class=\"hljs-built_in\">Math</span>.random() &#x3C; <span class=\"hljs-number\">0.75</span>) {\n      originalAddEventListener.call(<span class=\"hljs-keyword\">this</span>, ...args)\n    }\n  };\n})();</code></pre>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-built_in\">document</span>.body.addEventListener(<span class=\"hljs-string\">\"click\"</span>, () => <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">1</span>));\n<span class=\"hljs-built_in\">document</span>.body.addEventListener(<span class=\"hljs-string\">\"click\"</span>, () => <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>));\n<span class=\"hljs-built_in\">document</span>.body.addEventListener(<span class=\"hljs-string\">\"click\"</span>, () => <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">3</span>));\n<span class=\"hljs-built_in\">document</span>.body.addEventListener(<span class=\"hljs-string\">\"click\"</span>, () => <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">4</span>));\n<span class=\"hljs-built_in\">document</span>.body.addEventListener(<span class=\"hljs-string\">\"click\"</span>, () => <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">5</span>));</code></pre>\n<h2 id=\"2-faire-foirer-parseint-de-temps-en-temps\"><a href=\"#2-faire-foirer-parseint-de-temps-en-temps\" class=\"phenomic-HeadingAnchor\">#</a>2. Faire foirer parseInt de temps en temps</h2>\n<pre><code class=\"hljs language-javascript\">(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n  <span class=\"hljs-keyword\">let</span> originalParseInt = <span class=\"hljs-built_in\">window</span>.parseInt;\n  <span class=\"hljs-built_in\">window</span>.parseInt = <span class=\"hljs-function\">(<span class=\"hljs-params\">n</span>) =></span> <span class=\"hljs-built_in\">Math</span>.random() > <span class=\"hljs-number\">0.9</span> ? originalParseInt(n) : <span class=\"hljs-literal\">NaN</span>;\n})()</code></pre>\n<p>Pour un bon petit moment à pas comprendre ce qui se passe. Je suis sûr que <code>NaN</code> n'est pas toujours géré dans tous les cas dans la plupart des scripts qui tournent aujourd'hui en prod.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-string\">\"1\"</span>) <span class=\"hljs-comment\">// 1</span>\n<span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-string\">\"1\"</span>) <span class=\"hljs-comment\">// NaN</span></code></pre>\n<h2 id=\"1-deserialiser-les-url\"><a href=\"#1-deserialiser-les-url\" class=\"phenomic-HeadingAnchor\">#</a>1. (De)serialiser les URL</h2>\n<p>Pour ce coup, c'est bien de prévoir les deux fonctions utilisées par tout le monde pour encoder et décoder les URLs. Vu que si l'une ne marche pas, le reflexe est souvent de tester la deuxième, bon arrachage de cheveux en perspective.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-built_in\">window</span>.decodeURIComponent = <span class=\"hljs-built_in\">window</span>.encodeURIComponent = <span class=\"hljs-built_in\">window</span>.escape = <span class=\"hljs-built_in\">window</span>.unescape = <span class=\"hljs-function\">(<span class=\"hljs-params\">a</span>) =></span> <span class=\"hljs-built_in\">String</span>(a)</code></pre>\n<h2 id=\"bonus-pour-rendre-tout-ça-crédible\"><a href=\"#bonus-pour-rendre-tout-%C3%A7a-cr%C3%A9dible\" class=\"phenomic-HeadingAnchor\">#</a>Bonus: pour rendre tout ça crédible</h2>\n<p>Si dans la console de développement, vous tapez le nom d'une fonction accessible dans le scope, le navigateur va appeler <code>Function.prototype.toString</code> sur cette fonction pour en récupérer l'allure. Couvrez vos arrières en replaçant la méthode :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-built_in\">Function</span>.prototype.toString = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`function <span class=\"hljs-subst\">${ <span class=\"hljs-keyword\">this</span>.name || <span class=\"hljs-string\">\"\"</span> }</span>() {\n    [native code]\n}`</span>\n}</code></pre>\n<pre><code class=\"hljs language-javascript\">(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {})\n<span class=\"hljs-comment\">/* function () {\n    [native code]\n} */</span></code></pre>\n<p>Pour faire un peu de zèle, vous pouvez également déclarer ces fonctions dans un <code>eval</code> pour brouiller les pistes sur l'endroit où elles ont été déclarées.</p>\n<p>Voilà, vous avez toutes les clés pour faire des petites blagues à vos collègues.</p>\n<p>Et n'oubliez pas, JavaScript c'est super, mais faisez gaffe quand même, parce que dans un langage encourageant la mutabilité, qui utilise des globales et de l'héritage par dessus le marché, il suffit d'un petit bout de code innocent pour que plus rien ne marche.</p>\n<p>Bisous.</p>\n","rawBody":"\n(ou juste faire une blague à vos collègues)\n\n## 10. L'array vide magique\n\nCette technique fonctionne grace à l'héritage prototypal et au fait que pour une obscure raison, `Array.prototype` est un array (qui hérite de lui même, allez savoir). Il suffit d'appeler une des méthodes mutatives d'`Array.prototype` sur lui-même :\n\n```javascript\nArray.prototype.push(1, 2, 3);\n```\n\nPuisque dans le corps de `Array.prototype.push()`, `this` correspond à `Array.prototype`, c'est dans celui-ci que seront injectés les éléments.\n\n```javascript\n[][0] // 1\n```\n\nEt hop. À noter que vu l'implémentation de la plupart des fonctions travaillant avec des *arrays*, ça devrait pas causer grand dommage puisque `length` est géré au niveau de l'array, et pas de son prototype. Ceci-dit ça peut surprendre en faisant mumuse dans la console.\n\n## 9. L'objet magique\n\nSouvent, dans une boucle `for(name in object)`, on appelle `object.hasOwnProperty(name)` pour vérifier si la propriété appartient bien à l'objet et qu'il ne s'agit pas juste d'un truc hérité.\n\n```javascript\nObject.prototype.hasOwnProperty = () => true;\n// peut se combiner avec un petit\nfor(let index = 0; index < 10; index++) {\n  Object.prototype[index] = undefined;\n};\n```\n\nMême concept que pour l'exemple précédent, avec l'héritage prototypal. Le petit côté rigolo ici, c'est que c'est un pattern très courant en JavaScript, notamment dans les bibliothèques que vous utilisez probablement. Et c'est là qu'on se rend compte que de mettre la fonction qui vérifie si une propriété est héritée ou non dans l'héritage, c'est pas forcément l'idée du siècle.\n\n```javascript\nlet object = {};\nfor(let key in object) {\n  if(object.hasOwnProperty(object)) {\n    console.log(key)\n  }\n}\n// 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n```\n\n## 8. Le DOM fou\n\nCelui-là est plutôt sympa quand vous ou vos bibliothèques DOM de prédilection touchez un peu aux élements. Vu que l'appel à `Math.random()` rend l'opération aussi déterministe que l'application de styles assignés à des sélecteurs CSS chargés de manière asynchrone, vous risquez de jolies surprises.\n\n```javascript\nElement.prototype.appendChild = function(element) {\n  return Element.prototype.insertBefore.call(\n    this,\n    element,\n    this.childNodes[Math.floor(Math.random() * this.childNodes.length)]\n  )\n};\n```\n\n```javascript\nfor(let index = 0; index < 10; index++) {\n  document.body.appendChild(document.createTextNode(String(index)))\n};\n// \"1895234760\" (par exemple)\n```\n\n## 7. Simple mais efficace, faire de la console une no-op\n\nBizarrement, j'ai déjà vu des sites qui faisaient ça en production (e.g. Twitter si je me rappelle correctement). Vous rendez inopérable la console, ce qui peut faire une très bonne blague à vos collègues en cachant ça dans un vieux commit avec l'option `amend`.\n\n```javascript\nObject.keys(console).forEach(key => {\n  console[key] = () => {}\n});\n```\n\n## 6. Supprimer les stack traces des erreurs\n\nLà, on est vraiment sur le petit truc horrible, parce que vous pouvez mettre un petit moment avant de le réaliser. Le constructeur `Error` vient normalement ajouter une propriété `stack` qui vous permet de retrouver le chemin qu'a emprunté le code avant de jeter une erreur. Eh ben fini, à vous le debug à l'aveugle !\n\n```javascript\n(() => {\n  function Error(message) {\n    this.message = message;\n  }\n  Error.prototype = window.Error.prototype;\n  window.Error = Error;\n})();\n```\n\n## 5. Rendre l'asynchrone synchrone\n\nIl est assez courrant d'avoir des `setTimeout(func)` ou `setTimeout(func, 0)` (les deux sont équivalents). Ça permet s'assurer qu'on décale un peu l'execution d'une fonction, et souvent de s'assurer que si elle jette une erreur, elle n'empêchera pas le reste de s'executer.\n\n```javascript\n(() => {\n  let originalTimeout = window.setTimeout;\n  window.setTimeout = (func, duration, ...args) => !duration ? func(...args) : originalTimeout.call(window, func, duration, ...args);\n})()\n```\n\nAvec ce snippet, petites surprises bizarres assurées. Et c'est un bug présent dans quelques bibliothèques implémentant une fonction `domReady`, et qui font:\n\n```javascript\nfunction domReady(func) {\n  if (document.readyState === \"complete\") {\n    func()\n  } else {\n    document.addEventListener(\"DOMContentLoaded\", func)\n  }\n}\n```\n\nAvec une implémentation comme celle qu'on voit au dessus, `func` aura un comportement différent si le DOM est chargé ou non:\n\n```javascript\ndomReady(() => {\n  throw new Error()\n})\nconsole.log(1)\n// Logue 1 si le DOM est prêt, parce que l'execution de func par le handler DOMContentLoaded est asynchrone\n// Logue rien du tout si func() est appelé en synchrone par la première branche de domReady\n```\n\n## 4. Le réseau qui ne répond jamais\n\nLes `Promise`, c'est bien relou à débugger lorsque ça reste infiniment en \"pending\": on ne sait pas forcément pourquoi, surtout si c'est derrière une API opaque, comme `fetch`. Plaisir garanti, parce qu'avec ça sur la page, c'est probablement le dernier endroit où on va intuitivement chercher la source la bug.\n\n```javascript\nwindow.fetch = () => new Promise(() => {})\n```\n\n## 3. Faire marcher les event listener au hasard\n\nC'est particulièrement horrible quand un bug n'est pas reproduit à tous les coups: pourquoi ne pas attacher les évenements au hasard ?\n\n```javascript\n(() => {\n  let originalAddEventListener = Element.prototype.addEventListener\n  Element.prototype.addEventListener = function(...args) {\n    if(Math.random() < 0.75) {\n      originalAddEventListener.call(this, ...args)\n    }\n  };\n})();\n```\n\n```javascript\ndocument.body.addEventListener(\"click\", () => console.log(1));\ndocument.body.addEventListener(\"click\", () => console.log(2));\ndocument.body.addEventListener(\"click\", () => console.log(3));\ndocument.body.addEventListener(\"click\", () => console.log(4));\ndocument.body.addEventListener(\"click\", () => console.log(5));\n```\n\n## 2. Faire foirer parseInt de temps en temps\n\n```javascript\n(() => {\n  let originalParseInt = window.parseInt;\n  window.parseInt = (n) => Math.random() > 0.9 ? originalParseInt(n) : NaN;\n})()\n```\n\nPour un bon petit moment à pas comprendre ce qui se passe. Je suis sûr que `NaN` n'est pas toujours géré dans tous les cas dans la plupart des scripts qui tournent aujourd'hui en prod.\n\n```javascript\nparseInt(\"1\") // 1\nparseInt(\"1\") // NaN\n```\n\n## 1. (De)serialiser les URL\n\nPour ce coup, c'est bien de prévoir les deux fonctions utilisées par tout le monde pour encoder et décoder les URLs. Vu que si l'une ne marche pas, le reflexe est souvent de tester la deuxième, bon arrachage de cheveux en perspective.\n\n```javascript\nwindow.decodeURIComponent = window.encodeURIComponent = window.escape = window.unescape = (a) => String(a)\n```\n\n## Bonus: pour rendre tout ça crédible\n\nSi dans la console de développement, vous tapez le nom d'une fonction accessible dans le scope, le navigateur va appeler `Function.prototype.toString` sur cette fonction pour en récupérer l'allure. Couvrez vos arrières en replaçant la méthode :\n\n```javascript\nFunction.prototype.toString = function() {\n  return `function ${ this.name || \"\" }() {\n    [native code]\n}`\n}\n```\n\n```javascript\n(() => {})\n/* function () {\n    [native code]\n} */\n```\n\nPour faire un peu de zèle, vous pouvez également déclarer ces fonctions dans un `eval` pour brouiller les pistes sur l'endroit où elles ont été déclarées.\n\nVoilà, vous avez toutes les clés pour faire des petites blagues à vos collègues.\n\nEt n'oubliez pas, JavaScript c'est super, mais faisez gaffe quand même, parce que dans un langage encourageant la mutabilité, qui utilise des globales et de l'héritage par dessus le marché, il suffit d'un petit bout de code innocent pour que plus rien ne marche.\n\nBisous.\n","__filename":"fr/articles/js/top-10-snippets-demolir-runtime/index.md","__url":"/fr/articles/js/top-10-snippets-demolir-runtime/","__resourceUrl":"/fr/articles/js/top-10-snippets-demolir-runtime/index.html","__dataUrl":"/fr/articles/js/top-10-snippets-demolir-runtime/index.html.3d25fa8a87fb06bac2229da057eb5ff6.json"}