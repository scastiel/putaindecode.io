{"head":{"layout":"Post","comments":true,"date":"2017-11-07","title":"Développer avec Create React App et une API Node.js","tags":["javascript","react","create-react-app","api","Node.js"],"authors":["tmaziere"],"description":"tl;dr Dans un environnement de développement, pour lancer dans le même temps votre application React et une API basée sur Node.js, vous…"},"body":"<h2 id=\"tldr\"><a href=\"#tldr\" class=\"phenomic-HeadingAnchor\">#</a>tl;dr</h2>\n<p>Dans un environnement de développement, pour lancer dans le même temps votre application React et une API basée sur Node.js, vous pouvez imbriquer judicieusement les deux dépôts Git, puis utiliser un script NPM et quelques packages bien pratiques tels que <em>concurrently</em> et <em>nodemon</em> pour lancer les deux serveurs d'une seule commande. Pratique ! D'autant que pour contourner les restrictions d'accès liées à la <a href=\"https://fr.wikipedia.org/wiki/Same-origin_policy\"><em>politique de même origine</em></a>, <strong>create-react-app</strong> permet le paramétrage d'un <em>proxy</em> pour vos requêtes API.</p>\n<h2 id=\"est-ce-que-ça-me-concerne-\"><a href=\"#est-ce-que-%C3%A7a-me-concerne-\" class=\"phenomic-HeadingAnchor\">#</a>Est-ce que ça me concerne ?</h2>\n<p>La généralisation des architectures dites \"API first\" répond à des impératifs humains et techniques très divers. En ce qui concerne l'organisation du travail des développeurs, c'est l'assurance de pouvoir scinder l'implémentation de l'accès aux données -aux ressources- d'une part, et le travail sur l'UI/UX, d'autre part. Un premier groupe peut concevoir une API robuste et proposer un \"contrat\" clair à l'équipe <em>frontend</em> qui accède aux données avec un référentiel unique, que l'application soit web ou mobile.</p>\n<p>De cette façon, la conception de l'interface utilisateur est libérée d'une grande partie des contraintes qui régissent les architectures MVC traditionnelles. Le développeur peut ainsi mieux se concentrer sur la qualité de sa réponse aux spécifications fonctionnelles.</p>\n<p>Si l'architecture de votre projet est de ce type, et que vous attaquez la conception d'un frontend <a href=\"https://fr.wikipedia.org/wiki/Application_web_monopage\">SPA</a> React avec <a href=\"https://github.com/facebookincubator/create-react-app\">create-react-app</a> (quelle bonne idée !), ce qui suit peut vous éclairer. Nous allons voir comment il est possible d'accéder sans se compliquer la vie à une API RESTful basée sur Node.js, en imbriquant correctement ses dépôts.</p>\n<h2 id=\"deux-dépôts--le-frontend-lapi\"><a href=\"#deux-d%C3%A9p%C3%B4ts--le-frontend-lapi\" class=\"phenomic-HeadingAnchor\">#</a>Deux dépôts : le frontend, l’API</h2>\n<p>Le principe est le suivant : vous ne souhaitez pas forcément modifier l'API qui est implémentée par une autre équipe, ou par un collègue, mais vous devez y accéder facilement depuis votre application React.</p>\n<p>Vous allez pour cela devoir travailler sur deux dépôts Git clonés : celui du <em>frontend</em> React contiendra par exemple celui de l'API, et un <em>script NPM</em> se chargera de lancer les deux applications, sur deux ports différents.</p>\n<p><em>Faut-il utiliser un framework en particulier pour le backend ?</em><br>\nAbsolument pas ! Pour ma part je travaille plus volontiers avec <a href=\"https://loopback.io/\">LoopBack</a>, mais tout ce que qui s'appuie sur Node.js fait l'affaire.</p>\n<h2 id=\"organisation-locale-du-code\"><a href=\"#organisation-locale-du-code\" class=\"phenomic-HeadingAnchor\">#</a>Organisation locale du code</h2>\n<p>Mettons que votre projet React s'appelle <strong>my-react-frontend</strong> et que l'API qu'il consomme répond au doux nom de <strong>my-node-api</strong>.</p>\n<p><strong>my-react-frontend</strong> est cloné à la racine, c'est le projet parent. Il contient au moins les répertoires <code>src/</code>, <code>public/</code> et <code>node_modules/</code> générés par <em>create-react-app</em>.</p>\n<p><code>build/</code> peut également être présent si vous avez déjà lancé au moins une fois la commande <code>npm run build</code>.</p>\n<p>A la racine de <strong>my-react-frontend</strong>, clonez le dépôt <strong>my-node-api</strong>.</p>\n<p>Vous devez obtenir :</p>\n<pre><code>my-react-frontend/\n-- my-node-api/\n-- node_modules/\n-- public/\n-- src/\n...\n</code></pre>\n<p>Ne nous attardons pas trop sur <code>my-node-api</code>, qui peut être implémenté de très nombreuses manières. Partons du principe qu'une fois lancé, le serveur expose les ressources dont votre application a besoin sur <code>http://localhost:3001</code>. Et disons juste que si l'équipe <em>backend</em> vous signale une mise à jour, vous ferez simplement :</p>\n<pre><code class=\"hljs language-Shell\">cd my-node-api/\ngit pull</code></pre>\n<p><em>Faut-il forcément organiser les dépôts de cette façon ?</em><br>\nPas du tout. Mais l'intérêt de cette configuration, c'est que le <em>backend</em> est \"dans sa bulle\" et que les développeurs qui le font évoluer n'ont pas à organiser le code en fonction de ce <em>frontend</em> en particulier.</p>\n<p>Dernière chose importante : pensez à ajouter <code>my-node-api/</code> au fichier <code>.gitignore</code> du projet React. Il ne faudrait évidemment pas qu'il versionne le <em>backend</em>.</p>\n<h2 id=\"passez-moi-sur-le-cors\"><a href=\"#passez-moi-sur-le-cors\" class=\"phenomic-HeadingAnchor\">#</a>Passez moi sur le CORS</h2>\n<p>En production, il est fréquent d'utiliser le même serveur pour servir l'application React et l'API sous-jacente. Dans cette configuration, le mécanisme de <em>Cross-origin resource sharing</em> (<a href=\"https://en.wikipedia.org/wiki/Cross-origin_resource_sharing\">CORS</a>), basé sur des headers HTTP, n'a pas à être implémenté.</p>\n<p>En développement, par contre, il est plus pratique de dissocier les serveurs pour bénéficier de toutes les fonctionnalités de l'écosystème React.</p>\n<p>Pour répondre à cette contrainte, <em>create-react-app</em> propose <a href=\"https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#proxying-api-requests-in-development\">un mécanisme</a> qui permet de mettre en place un <strong>proxy</strong> d'API.</p>\n<p>En partant du principe que votre frontend écoute sur le port 3000, et le serveur API sur le port 3001, il suffit d'ajouter un paramètre au premier niveau du <code>package.json</code> :</p>\n<pre><code class=\"hljs language-json\">{\n  <span class=\"hljs-attr\">\"proxy\"</span>: <span class=\"hljs-string\">\"http://localhost:3001\"</span>,\n}</code></pre>\n<p>De cette façon, vous pourrez utiliser un chemin relatif pour accéder à vos ressources. Si une requête ne concerne pas un <em>asset</em> statique, elle sera relayée vers votre <em>backend</em>. <code>fetch('/api/bananas')</code>, par exemple, requêtera notre API sur <code>http://localhost:3001/api/bananas</code>.</p>\n<h2 id=\"tout-lancer-en-une-seule-commande\"><a href=\"#tout-lancer-en-une-seule-commande\" class=\"phenomic-HeadingAnchor\">#</a>Tout lancer en une seule commande</h2>\n<p>Nous utiliserons pour cela un script NPM défini dans le <code>package.json</code> situé à la racine du projet React.</p>\n<p>Deux petits outils seront nécessaires pour créer le script <em>ad hoc</em> :</p>\n<ul>\n<li>le package <a href=\"https://www.npmjs.com/package/concurrently\"><code>concurrently</code></a> qui permet de lancer plusieurs scripts en une seule commande. Faites par exemple un <code>npm install --save-dev concurrently</code>.</li>\n<li>le package <a href=\"https://www.npmjs.com/package/nodemon\"><code>nodemon</code></a> qui scrute votre <em>backend</em> Node.js et relance le serveur automatiquement en cas de modification du code. Faites donc un <code>npm install --save-dev nodemon</code>, vous ne le regretterez pas.</li>\n</ul>\n<p>Tout est prêt ! Ouvrez <code>package.json</code> et ajoutez dans les <code>scripts</code>:</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-string\">\"start-with-api\"</span>: <span class=\"hljs-string\">\"concurrently \\\"react-scripts start\\\" \\\"PORT=3001 nodemon ./my-node-api/server/server.js\\\"\"</span></code></pre>\n<p>Le chemin d'accès au script serveur est à adapter en fonction de vos propres choix techniques ! Notez que dans ce cas précis, on passe une variable d'environnement <code>PORT</code> que le script serveur utilise pour écraser son port d'écoute par défaut.</p>\n<p>Au final, le <code>package.json</code> doit ressembler à ceci :</p>\n<pre><code class=\"hljs language-json\">{\n  <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"my-react-frontend\"</span>,\n  <span class=\"hljs-attr\">\"version\"</span>: <span class=\"hljs-string\">\"0.1.0\"</span>,\n  <span class=\"hljs-attr\">\"private\"</span>: <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">\"proxy\"</span>: <span class=\"hljs-string\">\"http://localhost:3001\"</span>,\n  <span class=\"hljs-attr\">\"scripts\"</span>: {\n    <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-string\">\"react-scripts start\"</span>,\n    <span class=\"hljs-attr\">\"start-with-api\"</span>: <span class=\"hljs-string\">\"concurrently \\\"react-scripts start\\\" \\\"PORT=3001 nodemon ./my-node-api/server/server.js\\\"\"</span>,\n    <span class=\"hljs-attr\">\"build\"</span>: <span class=\"hljs-string\">\"react-scripts build\"</span>,\n    <span class=\"hljs-attr\">\"test\"</span>: <span class=\"hljs-string\">\"react-scripts test --env=jsdom\"</span>,\n    <span class=\"hljs-attr\">\"eject\"</span>: <span class=\"hljs-string\">\"react-scripts eject\"</span>\n  },\n  <span class=\"hljs-attr\">\"devDependencies\"</span>: {\n    <span class=\"hljs-attr\">\"react-scripts\"</span>: <span class=\"hljs-string\">\"1.0.14\"</span>,\n    <span class=\"hljs-attr\">\"concurrently\"</span>: <span class=\"hljs-string\">\"3.5.0\"</span>,\n    <span class=\"hljs-attr\">\"nodemon\"</span>: <span class=\"hljs-string\">\"1.12.1\"</span>\n  },\n  <span class=\"hljs-attr\">\"dependencies\"</span>: {\n    <span class=\"hljs-attr\">\"react\"</span>: <span class=\"hljs-string\">\"^16.0.0\"</span>,\n    <span class=\"hljs-attr\">\"react-dom\"</span>: <span class=\"hljs-string\">\"^16.0.0\"</span>\n  }\n}</code></pre>\n<p>Pour mémoire, nous n'avons ajouté que deux lignes : \"proxy\" et \"scripts/start-with-api\".</p>\n<h2 id=\"une-astuce-pour-les-pressés\"><a href=\"#une-astuce-pour-les-press%C3%A9s\" class=\"phenomic-HeadingAnchor\">#</a>Une astuce pour les pressés</h2>\n<p>Si le backend ne joue pas un grand rôle dans votre application ou si -plus probablement- vous souhaitez démarrer sans attendre que le véritable backend soit disponible, je vous conseille de tester l'excellent <a href=\"https://github.com/typicode/json-server\"><code>json-server</code></a>.</p>\n<p>Cet élégant package offre la possibilité de créer un fichier JSON avec quelques données factices (<em>data fixtures</em>) et de les mettre à disposition de votre application à la façon d'une API RESTful, grâce à un simple <code>json-server --watch db.json</code>.</p>\n<p>Il va sans dire qu'en modifiant légèrement le script <em>start-with-api</em>, vous disposerez en quelques secondes d'un <em>backend</em> au poil pour votre nouvelle application.</p>\n","rawBody":"## tl;dr\nDans un environnement de développement, pour lancer dans le même temps votre application React et une API basée sur Node.js, vous pouvez imbriquer judicieusement les deux dépôts Git, puis utiliser un script NPM et quelques packages bien pratiques tels que _concurrently_ et _nodemon_ pour lancer les deux serveurs d'une seule commande. Pratique ! D'autant que pour contourner les restrictions d'accès liées à la [_politique de même origine_](https://fr.wikipedia.org/wiki/Same-origin_policy), **create-react-app** permet le paramétrage d'un _proxy_ pour vos requêtes API.\n\n## Est-ce que ça me concerne ?\n\nLa généralisation des architectures dites \"API first\" répond à des impératifs humains et techniques très divers. En ce qui concerne l'organisation du travail des développeurs, c'est l'assurance de pouvoir scinder l'implémentation de l'accès aux données -aux ressources- d'une part, et le travail sur l'UI/UX, d'autre part. Un premier groupe peut concevoir une API robuste et proposer un \"contrat\" clair à l'équipe _frontend_ qui accède aux données avec un référentiel unique, que l'application soit web ou mobile.\n\nDe cette façon, la conception de l'interface utilisateur est libérée d'une grande partie des contraintes qui régissent les architectures MVC traditionnelles. Le développeur peut ainsi mieux se concentrer sur la qualité de sa réponse aux spécifications fonctionnelles.\n\nSi l'architecture de votre projet est de ce type, et que vous attaquez la conception d'un frontend [SPA](https://fr.wikipedia.org/wiki/Application_web_monopage) React avec [create-react-app](https://github.com/facebookincubator/create-react-app) (quelle bonne idée !), ce qui suit peut vous éclairer. Nous allons voir comment il est possible d'accéder sans se compliquer la vie à une API RESTful basée sur Node.js, en imbriquant correctement ses dépôts.\n\n## Deux dépôts : le frontend, l’API\n\nLe principe est le suivant : vous ne souhaitez pas forcément modifier l'API qui est implémentée par une autre équipe, ou par un collègue, mais vous devez y accéder facilement depuis votre application React.\n\nVous allez pour cela devoir travailler sur deux dépôts Git clonés : celui du _frontend_ React contiendra par exemple celui de l'API, et un _script NPM_ se chargera de lancer les deux applications, sur deux ports différents.\n\n\n_Faut-il utiliser un framework en particulier pour le backend ?_  \nAbsolument pas ! Pour ma part je travaille plus volontiers avec [LoopBack](https://loopback.io/), mais tout ce que qui s'appuie sur Node.js fait l'affaire.\n\n## Organisation locale du code\n\nMettons que votre projet React s'appelle **my-react-frontend** et que l'API qu'il consomme répond au doux nom de **my-node-api**.\n\n**my-react-frontend** est cloné à la racine, c'est le projet parent. Il contient au moins les répertoires `src/`, `public/` et `node_modules/` générés par _create-react-app_.\n\n`build/` peut également être présent si vous avez déjà lancé au moins une fois la commande `npm run build`.\n\nA la racine de **my-react-frontend**, clonez le dépôt **my-node-api**.\n\nVous devez obtenir :\n\n```\nmy-react-frontend/\n-- my-node-api/\n-- node_modules/\n-- public/\n-- src/\n...\n```\n\nNe nous attardons pas trop sur `my-node-api`, qui peut être implémenté de très nombreuses manières. Partons du principe qu'une fois lancé, le serveur expose les ressources dont votre application a besoin sur `http://localhost:3001`. Et disons juste que si l'équipe _backend_ vous signale une mise à jour, vous ferez simplement :\n\n```Shell\ncd my-node-api/\ngit pull\n```\n\n_Faut-il forcément organiser les dépôts de cette façon ?_  \nPas du tout. Mais l'intérêt de cette configuration, c'est que le _backend_ est \"dans sa bulle\" et que les développeurs qui le font évoluer n'ont pas à organiser le code en fonction de ce _frontend_ en particulier.\n\nDernière chose importante : pensez à ajouter `my-node-api/` au fichier `.gitignore` du projet React. Il ne faudrait évidemment pas qu'il versionne le _backend_.\n\n## Passez moi sur le CORS\n\nEn production, il est fréquent d'utiliser le même serveur pour servir l'application React et l'API sous-jacente. Dans cette configuration, le mécanisme de _Cross-origin resource sharing_ ([CORS](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing)), basé sur des headers HTTP, n'a pas à être implémenté.\n\nEn développement, par contre, il est plus pratique de dissocier les serveurs pour bénéficier de toutes les fonctionnalités de l'écosystème React.\n\nPour répondre à cette contrainte, _create-react-app_ propose [un mécanisme](https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#proxying-api-requests-in-development) qui permet de mettre en place un **proxy** d'API.\n\nEn partant du principe que votre frontend écoute sur le port 3000, et le serveur API sur le port 3001, il suffit d'ajouter un paramètre au premier niveau du `package.json` :\n\n```json\n{\n  \"proxy\": \"http://localhost:3001\",\n}\n```\n\nDe cette façon, vous pourrez utiliser un chemin relatif pour accéder à vos ressources. Si une requête ne concerne pas un _asset_ statique, elle sera relayée vers votre _backend_. `fetch('/api/bananas')`, par exemple, requêtera notre API sur `http://localhost:3001/api/bananas`.\n\n## Tout lancer en une seule commande\n\nNous utiliserons pour cela un script NPM défini dans le `package.json` situé à la racine du projet React.\n\nDeux petits outils seront nécessaires pour créer le script _ad hoc_ :\n\n- le package [`concurrently`](https://www.npmjs.com/package/concurrently) qui permet de lancer plusieurs scripts en une seule commande. Faites par exemple un `npm install --save-dev concurrently`.\n- le package [`nodemon`](https://www.npmjs.com/package/nodemon) qui scrute votre _backend_ Node.js et relance le serveur automatiquement en cas de modification du code. Faites donc un `npm install --save-dev nodemon`, vous ne le regretterez pas.\n\nTout est prêt ! Ouvrez `package.json` et ajoutez dans les `scripts`:\n\n```json\n\"start-with-api\": \"concurrently \\\"react-scripts start\\\" \\\"PORT=3001 nodemon ./my-node-api/server/server.js\\\"\"\n```\n\nLe chemin d'accès au script serveur est à adapter en fonction de vos propres choix techniques ! Notez que dans ce cas précis, on passe une variable d'environnement `PORT` que le script serveur utilise pour écraser son port d'écoute par défaut.\n\nAu final, le `package.json` doit ressembler à ceci :\n\n```json\n{\n  \"name\": \"my-react-frontend\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"proxy\": \"http://localhost:3001\",\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"start-with-api\": \"concurrently \\\"react-scripts start\\\" \\\"PORT=3001 nodemon ./my-node-api/server/server.js\\\"\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test --env=jsdom\",\n    \"eject\": \"react-scripts eject\"\n  },\n  \"devDependencies\": {\n    \"react-scripts\": \"1.0.14\",\n    \"concurrently\": \"3.5.0\",\n    \"nodemon\": \"1.12.1\"\n  },\n  \"dependencies\": {\n    \"react\": \"^16.0.0\",\n    \"react-dom\": \"^16.0.0\"\n  }\n}\n```\n\nPour mémoire, nous n'avons ajouté que deux lignes : \"proxy\" et \"scripts/start-with-api\".\n\n## Une astuce pour les pressés\n\nSi le backend ne joue pas un grand rôle dans votre application ou si -plus probablement- vous souhaitez démarrer sans attendre que le véritable backend soit disponible, je vous conseille de tester l'excellent [`json-server`](https://github.com/typicode/json-server).\n\nCet élégant package offre la possibilité de créer un fichier JSON avec quelques données factices (_data fixtures_) et de les mettre à disposition de votre application à la façon d'une API RESTful, grâce à un simple `json-server --watch db.json`.\n\nIl va sans dire qu'en modifiant légèrement le script _start-with-api_, vous disposerez en quelques secondes d'un _backend_ au poil pour votre nouvelle application.\n","__filename":"fr/articles/js/react/create-react-app-et-api/index.md","__url":"/fr/articles/js/react/create-react-app-et-api/","__resourceUrl":"/fr/articles/js/react/create-react-app-et-api/index.html","__dataUrl":"/fr/articles/js/react/create-react-app-et-api/index.html.97d196987be17189e48b151e53be05ba.json"}