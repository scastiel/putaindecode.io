{"head":{"layout":"Post","comments":true,"date":"2014-06-04","title":"Introduction à React","tags":["javascript","react"],"authors":["bloodyowl"],"description":"Cela fait maintenant un an que React est open-sourced. C'est l'occasion de présenter le petit dernier de la vague MV\\*. Les différentes…"},"body":"<p>Cela fait maintenant un an que React est open-sourced. C'est l'occasion de\nprésenter le petit dernier de la vague MV*.</p>\n<h2 id=\"les-différentes-approches-dui\"><a href=\"#les-diff%C3%A9rentes-approches-dui\" class=\"phenomic-HeadingAnchor\">#</a>Les différentes approches d'UI</h2>\n<h3 id=\"backbone\"><a href=\"#backbone\" class=\"phenomic-HeadingAnchor\">#</a>Backbone</h3>\n<p><a href=\"http://backbonejs.org\">Backbone</a> apporte une simplification dans la déclaration\nd'évenements, il reste cependant très peu impliqué dans le rendering. Le choix\nde laisser l'utilisateur décider de tout concernant <code>Backbone.View</code> est positif\npour de nombreux projets, mais rend la gestion du DOM pénible.</p>\n<p>Pour faire du data-binding, <code>Backbone</code> ne propose naturellement rien, et l'on\ndoit faire appel à des mixins supplémentaires pour le mettre en place sans\ns'arracher les cheveux.</p>\n<p>De plus, c'est souvent un moteur de templating comme Handlebars ou Jade qui\ngénére la vue originale. On se retrouve donc avec un joli\n<code>this.$el.html(this.template(data))</code> dans la méthode <code>render()</code> qui va provoquer\ndes jolies horreurs visuelles (ie. les images se rechargent, les videos sont\nréinitialisées).</p>\n<p>En somme, Backbone est très sympathique pour structurer son code proprement,\nmais concernant l'UI, n'aide absolument pas à réduire la compléxité liée aux\nétats du DOM.</p>\n<h3 id=\"angular\"><a href=\"#angular\" class=\"phenomic-HeadingAnchor\">#</a>Angular</h3>\n<p><a href=\"https://angularjs.org\">Angular</a> propose une approche beaucoup plus travaillée,\nen imposant un moteur de templating HTML (on peut utiliser du preprocessing) et\non déclare ses bindings très simplement avec une syntaxe <code>{{mustache}}</code>.</p>\n<p>On déclare les évenements à l'aide d'attributs <code>ng-{eventName}</code>.</p>\n<p>Sur le papier, angular est donc très sympathique (je ne prendrais pas parti sur\nle dirty checking).</p>\n<h3 id=\"ember\"><a href=\"#ember\" class=\"phenomic-HeadingAnchor\">#</a>Ember</h3>\n<p><a href=\"http://emberjs.com\">Ember</a> est un framework très bien pensé et très travaillé.\nIl intègre très bien les concepts de <code>data-binding</code> à l'aide de <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/range\">DOM\nRanges</a>. Il propose des\nconventions fortes, et contrairement à la plupart des <em>a priori</em>, est très\nsimple à prendre en main. Les subviews sont très simples à utiliser à l'aide\nd'<code>{{outlet}}</code>.</p>\n<p>Pour résumer, ember et angular proposent de vraies solutions pour la gestion de\nl'UI. Cependant les deux conservent cette démarche :</p>\n<ul>\n<li>on <em>render</em> (génère et insère le bout de DOM) une fois</li>\n<li>on update les bindings</li>\n</ul>\n<h3 id=\"react\"><a href=\"#react\" class=\"phenomic-HeadingAnchor\">#</a>React</h3>\n<p><a href=\"http://facebook.github.io/react/\">React</a> change complètement d'approche. Il\npart d'un constat simple : le fait que le DOM ait constamment un état différent,\nc'est chiant à gérer.</p>\n<p>Du coup, et si on appelait <code>.render()</code> à chaque modification ? Ça a l'air\nstupide, hein ? Pas tant que ça en fait.</p>\n<p>React implémente un <strong>DOM virtuel</strong>, une représentation interne du DOM\nextrêmement rapide. La méthode <code>render</code> retourne des objets correspondant à la représentation\ninterne du DOM virtuel.</p>\n<p>Un composant React reçoit des <code>props</code>, ses paramètres, et peut avoir un <code>state</code>, un état local. Lorsque l'on définit un composant React, on peut y mettre un état par défaut en définissant une propriété <code>state</code> dans la <code>class</code>.</p>\n<p>Après cela, on peut mettre à jour l'état avec la méthode <code>this.setState</code>, en y passage les valeurs de l'état à changer afin de mettre à jour le DOM.</p>\n<p>Le principal avantage est que l'on est certain, du fait de l'appel systématique\nà <code>render</code>, que notre composant React aura la représentation attendue pour un\nétat donné, et ce à n'importe quel point dans le temps.</p>\n<p>Un des autres avantages de React est son algorithme de diff interne. Le DOM\nvirtuel va être comparé avec la version visible, et React effectue à l'aide\nd'opérations simples les seuls changements nécessaires.</p>\n<p>Cela résoud des problématiques comme la position du curseur dans un champ texte\nqui reçoit sa valeur de JavaScript; puisque l'algorithme n'y voit pas de\nchangement nécessaire, le champ texte n'est pas modifié et l'on garde donc le\nfocus. Du même fait, si vous avez un gif qui boucle, il ne se relancera pas\ninopinément.</p>\n<p>React peut être utilisé avec JSX, un <em>superset</em> de js qui permet d'écrire\nles templates avec une syntaxe XML (voir l'exemple plus bas), ce qui permet de le prendre en main très rapidement.</p>\n<h2 id=\"créons-un-component-react-\"><a href=\"#cr%C3%A9ons-un-component-react-\" class=\"phenomic-HeadingAnchor\">#</a>Créons un component react :</h2>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-keyword\">import</span> ReactDOM <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react-dom\"</span>;\n<span class=\"hljs-keyword\">import</span> cx <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"classnames\"</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">View</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">React</span>.<span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-comment\">// état initial</span>\n  state = {\n    <span class=\"hljs-attr\">checked</span>: <span class=\"hljs-literal\">false</span>\n  };\n  <span class=\"hljs-keyword\">static</span> defaultProps = {\n    <span class=\"hljs-attr\">label</span>: <span class=\"hljs-string\">\"?\"</span>\n  };\n  toggle = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {\n    <span class=\"hljs-comment\">// on crée un nouvel état (les états de react sont immutable)</span>\n    <span class=\"hljs-comment\">// et on déclenche le render</span>\n    <span class=\"hljs-keyword\">this</span>.setState({\n      <span class=\"hljs-attr\">checked</span>: !<span class=\"hljs-keyword\">this</span>.state.checked\n    });\n  }\n  render() {\n    <span class=\"hljs-comment\">// `cx` (classnames sur npm) permet de générer une chaîne \"className\" à</span>\n    <span class=\"hljs-comment\">// partir d'objets ayant pour clé un className et pour valeur un booléen</span>\n    <span class=\"hljs-keyword\">const</span> classes = cx({\n      <span class=\"hljs-string\">\"list-item\"</span>: <span class=\"hljs-literal\">true</span>,\n      <span class=\"hljs-string\">\"list-item--valid\"</span>: <span class=\"hljs-keyword\">this</span>.state.checked\n    });\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">className</span>=<span class=\"hljs-string\">{classes}</span>></span>\n        {/* notre binding tout simple */}\n        </span>&#x3C;input\n          checked={this.state.checked}\n          type=\"checkbox\"\n          onChange={this.toggle}\n        />\n        {this.props.label}\n      &#x3C;/div><span class=\"xml\">\n    );\n  }\n};\n\n// on mount le component, et on passe le label\nReactDOM.render(\n  </span>&#x3C;View label=\"HelloWorld\" />,\n  document.getElementById(\"id\")\n);</code></pre>\n<h2 id=\"sum-up-des-avantages-de-react\"><a href=\"#sum-up-des-avantages-de-react\" class=\"phenomic-HeadingAnchor\">#</a>Sum up des avantages de React</h2>\n<p>React a bien compris ces points :</p>\n<ul>\n<li>le DOM est lent, du moins en écriture, et limiter les interactions avec ce\ndernier est essentiel ;</li>\n<li>devoir continuellement penser à l'état du DOM à l'instant <code>n</code> n'est pas une\npréoccupation que nous devrions avoir en développant l'UI de nos composants ;</li>\n<li>les concepts d'immutabilité (un objet ne change pas, on en crée un nouveau à\nchaque changement) et de composition (composer une classe de différentes\nfonctionnalités sans devoir créer des chaînes d'héritage complexes) ont de\ngrands intérêts, trop peu utilisés en front-end.</li>\n</ul>\n<p>React n'impose pas de bibliothèque pour les data et la\ncommunication des modules. Il existe une bibliothèque nommée\n<a href=\"https://redux.js.org\">redux</a>, aujourd'hui standard, permettant de gérer ces aspecs facilement.</p>\n<p>Last but not least, vous pouvez render vos composants React depuis le serveur et\nla lib sera assez intelligente pour reconnaitre les composants déjà générés pour\nne pas les render systématiquement, c'est pas beau, ça ?</p>\n","rawBody":"\nCela fait maintenant un an que React est open-sourced. C'est l'occasion de\nprésenter le petit dernier de la vague MV\\*.\n\n## Les différentes approches d'UI\n\n### Backbone\n\n[Backbone](http://backbonejs.org) apporte une simplification dans la déclaration\nd'évenements, il reste cependant très peu impliqué dans le rendering. Le choix\nde laisser l'utilisateur décider de tout concernant `Backbone.View` est positif\npour de nombreux projets, mais rend la gestion du DOM pénible.\n\nPour faire du data-binding, `Backbone` ne propose naturellement rien, et l'on\ndoit faire appel à des mixins supplémentaires pour le mettre en place sans\ns'arracher les cheveux.\n\nDe plus, c'est souvent un moteur de templating comme Handlebars ou Jade qui\ngénére la vue originale. On se retrouve donc avec un joli\n`this.$el.html(this.template(data))` dans la méthode `render()` qui va provoquer\ndes jolies horreurs visuelles (ie. les images se rechargent, les videos sont\nréinitialisées).\n\nEn somme, Backbone est très sympathique pour structurer son code proprement,\nmais concernant l'UI, n'aide absolument pas à réduire la compléxité liée aux\nétats du DOM.\n\n### Angular\n\n[Angular](https://angularjs.org) propose une approche beaucoup plus travaillée,\nen imposant un moteur de templating HTML (on peut utiliser du preprocessing) et\non déclare ses bindings très simplement avec une syntaxe `{{mustache}}`.\n\nOn déclare les évenements à l'aide d'attributs `ng-{eventName}`.\n\nSur le papier, angular est donc très sympathique (je ne prendrais pas parti sur\nle dirty checking).\n\n### Ember\n\n[Ember](http://emberjs.com) est un framework très bien pensé et très travaillé.\nIl intègre très bien les concepts de `data-binding` à l'aide de [DOM\nRanges](https://developer.mozilla.org/en-US/docs/Web/API/range). Il propose des\nconventions fortes, et contrairement à la plupart des *a priori*, est très\nsimple à prendre en main. Les subviews sont très simples à utiliser à l'aide\nd'`{{outlet}}`.\n\nPour résumer, ember et angular proposent de vraies solutions pour la gestion de\nl'UI. Cependant les deux conservent cette démarche :\n\n* on _render_ (génère et insère le bout de DOM) une fois\n* on update les bindings\n\n### React\n\n[React](http://facebook.github.io/react/) change complètement d'approche. Il\npart d'un constat simple : le fait que le DOM ait constamment un état différent,\nc'est chiant à gérer.\n\nDu coup, et si on appelait `.render()` à chaque modification ? Ça a l'air\nstupide, hein ? Pas tant que ça en fait.\n\nReact implémente un **DOM virtuel**, une représentation interne du DOM\nextrêmement rapide. La méthode `render` retourne des objets correspondant à la représentation\ninterne du DOM virtuel.\n\nUn composant React reçoit des `props`, ses paramètres, et peut avoir un `state`, un état local. Lorsque l'on définit un composant React, on peut y mettre un état par défaut en définissant une propriété `state` dans la `class`.\n\nAprès cela, on peut mettre à jour l'état avec la méthode `this.setState`, en y passage les valeurs de l'état à changer afin de mettre à jour le DOM.\n\nLe principal avantage est que l'on est certain, du fait de l'appel systématique\nà `render`, que notre composant React aura la représentation attendue pour un\nétat donné, et ce à n'importe quel point dans le temps.\n\nUn des autres avantages de React est son algorithme de diff interne. Le DOM\nvirtuel va être comparé avec la version visible, et React effectue à l'aide\nd'opérations simples les seuls changements nécessaires.\n\nCela résoud des problématiques comme la position du curseur dans un champ texte\nqui reçoit sa valeur de JavaScript; puisque l'algorithme n'y voit pas de\nchangement nécessaire, le champ texte n'est pas modifié et l'on garde donc le\nfocus. Du même fait, si vous avez un gif qui boucle, il ne se relancera pas\ninopinément.\n\nReact peut être utilisé avec JSX, un *superset* de js qui permet d'écrire\nles templates avec une syntaxe XML (voir l'exemple plus bas), ce qui permet de le prendre en main très rapidement.\n\n## Créons un component react :\n\n```javascript\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport cx from \"classnames\";\n\nclass View extends React.Component {\n  // état initial\n  state = {\n    checked: false\n  };\n  static defaultProps = {\n    label: \"?\"\n  };\n  toggle = () => {\n    // on crée un nouvel état (les états de react sont immutable)\n    // et on déclenche le render\n    this.setState({\n      checked: !this.state.checked\n    });\n  }\n  render() {\n    // `cx` (classnames sur npm) permet de générer une chaîne \"className\" à\n    // partir d'objets ayant pour clé un className et pour valeur un booléen\n    const classes = cx({\n      \"list-item\": true,\n      \"list-item--valid\": this.state.checked\n    });\n    return (\n      <div className={classes}>\n        {/* notre binding tout simple */}\n        <input\n          checked={this.state.checked}\n          type=\"checkbox\"\n          onChange={this.toggle}\n        />\n        {this.props.label}\n      </div>\n    );\n  }\n};\n\n// on mount le component, et on passe le label\nReactDOM.render(\n  <View label=\"HelloWorld\" />,\n  document.getElementById(\"id\")\n);\n```\n\n## Sum up des avantages de React\n\nReact a bien compris ces points :\n\n* le DOM est lent, du moins en écriture, et limiter les interactions avec ce\n  dernier est essentiel ;\n* devoir continuellement penser à l'état du DOM à l'instant `n` n'est pas une\n  préoccupation que nous devrions avoir en développant l'UI de nos composants ;\n* les concepts d'immutabilité (un objet ne change pas, on en crée un nouveau à\n  chaque changement) et de composition (composer une classe de différentes\n  fonctionnalités sans devoir créer des chaînes d'héritage complexes) ont de\n  grands intérêts, trop peu utilisés en front-end.\n\nReact n'impose pas de bibliothèque pour les data et la\ncommunication des modules. Il existe une bibliothèque nommée\n[redux](https://redux.js.org), aujourd'hui standard, permettant de gérer ces aspecs facilement.\n\nLast but not least, vous pouvez render vos composants React depuis le serveur et\nla lib sera assez intelligente pour reconnaitre les composants déjà générés pour\nne pas les render systématiquement, c'est pas beau, ça ?\n","__filename":"fr/articles/js/react/index.md","__url":"/fr/articles/js/react/","__resourceUrl":"/fr/articles/js/react/index.html","__dataUrl":"/fr/articles/js/react/index.html.9c06343869f7ec9079955c0daa93ac7a.json"}