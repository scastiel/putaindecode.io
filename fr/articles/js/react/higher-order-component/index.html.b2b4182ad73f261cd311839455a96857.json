{"head":{"layout":"Post","comments":true,"date":"2016-06-14","title":"Les patterns Provider & Higher-Order Component avec React","tags":["javascript","react","higher-order-component"],"authors":["bloodyowl"],"description":"Le pattern provider Beaucoup de bibliotèques React ont besoin de faire passer des data au travers de tout l'arbre de composants de votre…"},"body":"<h2 id=\"le-pattern-provider\"><a href=\"#le-pattern-provider\" class=\"phenomic-HeadingAnchor\">#</a>Le pattern provider</h2>\n<p>Beaucoup de bibliotèques React ont besoin de faire passer des data au travers de\ntout l'arbre de composants de votre app. Par exemple Redux a besoin de passer\nson <em>store</em> et React Router doit passer l'objet <em>location</em>. Tout ça pourrait\npossiblement passer par du <em>shared mutable state</em> (état global mutable, ce qui\nest rarement une bonne idée). Le <em>shared mutable state</em> rend impossible une\napplication à plus d'un contexte. En d'autres mots, ça ne marcherait que sur le\nclient, où l'état global correspond à celui de l'utilisateur. Si vous décidez de\nrendre la page côté serveur, c'est impossible de reposer sur une telle\nimplémentation : cet état ne doit pas dépasser le scope de la requête courante\nau serveur.</p>\n<p>Coup de bol, l'API de React nous offre une solution à ce problème: le\n<a href=\"http://facebook.github.io/react/docs/context.html\"><code>context</code></a>. Si l'on résume\nsa nature, c'est comme l'objet global de votre arbre de composants.</p>\n<p>Le <code>context</code> fonctionne de la façon suivante:</p>\n<ul>\n<li>On définit haut dans notre app un <code>context</code> que l'on donne aux composants\ndescendants de l'app</li>\n<li>On récupère ce contexte dans les composants descendants.</li>\n</ul>\n<p>Du coup, pour <em>donner</em> ce <code>context</code>, on doit avoir un <code>Provider</code>. Son rôle est\nsimplement de fournir un <code>context</code> pour que les composants enfants y aient\naccès.</p>\n<p>On va illustrer ce pattern avec un use-case très simple : dans notre app, les\nutilisateurs peuvent customiser le thème.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> React, { Component, PropTypes, Children } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ThemeProvider</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n  <span class=\"hljs-comment\">// la méthode getChildContext est appelée pour fournir le `context`</span>\n  <span class=\"hljs-comment\">// dans notre cas, on le récupère des `props`</span>\n  getChildContext() {\n    <span class=\"hljs-keyword\">return</span> {\n      <span class=\"hljs-attr\">theme</span>: <span class=\"hljs-keyword\">this</span>.props.theme\n    };\n  }\n  <span class=\"hljs-comment\">// on render l'enfant</span>\n  render() {\n    <span class=\"hljs-keyword\">return</span> Children.only(<span class=\"hljs-keyword\">this</span>.props.children);\n  }\n}\n\nThemeProvider.propTypes = {\n  <span class=\"hljs-attr\">theme</span>: PropTypes.object.isRequired\n};\n\n<span class=\"hljs-comment\">// pour que React prenne en compte le context fourni,</span>\n<span class=\"hljs-comment\">// on doit définir les types des propriétés que l'on passe</span>\nThemeProvider.childContextTypes = {\n  <span class=\"hljs-attr\">theme</span>: PropTypes.object.isRequired\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> ThemeProvider;</code></pre>\n<p>Pour utiliser le provider, il suffit de wrapper notre app avec:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>;\n<span class=\"hljs-keyword\">import</span> ReactDOM <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react-dom\"</span>;\n\n<span class=\"hljs-keyword\">import</span> ThemeProvider <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"ThemeProvider\"</span>;\n<span class=\"hljs-keyword\">import</span> App <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"App\"</span>;\n\n<span class=\"hljs-keyword\">const</span> theme = {\n  <span class=\"hljs-attr\">color</span>: <span class=\"hljs-string\">\"#cc3300\"</span>,\n  <span class=\"hljs-attr\">fontFamily</span>: <span class=\"hljs-string\">\"Georgia\"</span>\n};\n\nReactDOM.render(\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">ThemeProvider</span> <span class=\"hljs-attr\">theme</span>=<span class=\"hljs-string\">{theme}</span>></span>\n    </span>&#x3C;App /><span class=\"xml\">\n  <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">ThemeProvider</span>></span></span>,\n  <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">\"#App\"</span>)\n);</code></pre>\n<p>Maintenant que notre <code>theme</code> est bien ajouté au <code>context</code>, on a besoin d'un\nmoyen simple pour que nos composants dans l'app puissent le consommer. Ça nous\namène au second pattern.</p>\n<h2 id=\"le-pattern-higher-order-component\"><a href=\"#le-pattern-higher-order-component\" class=\"phenomic-HeadingAnchor\">#</a>Le pattern Higher-Order Component</h2>\n<p>Afin de consommer le <code>context</code>, un component doit définir une propriété statique\n<code>contextTypes</code> stipulant quelles propriétés le composant souhaite récupérer. On\npourrait le définir sur chaque composant, mais cela serait une mauvaise idée\npour deux raisons :</p>\n<ul>\n<li><strong>La maintenabilité</strong> : si à un moment, on a besoin de refacto, avoir tous ces\n<code>contextTypes</code> éparpillés dans notre repository peut faire bien mal.</li>\n<li><strong>La complexité</strong>: L'API des <code>context</code> étant encore obscure pour beaucoup, il\nest préférable de faire une abstraction pour la masquer.</li>\n</ul>\n<p>Une autre solution serait d'utiliser l'héritage d'une sous-classe de\n<code>ReactComponent</code>. Ça ne marche pas pour deux raisons:</p>\n<ul>\n<li>Plus d'un niveau d'héritage est en général une idée de merde. Cela mène\nsouvent à des conflits entre méthodes, et force à vérifier toute la chaîne\nd'héritage à chaque fois que l'on souhaite modifier quelque chose. L'API des\n<code>mixins</code> de <code>React.createClass</code> réglait ce souci en définissant des\ncomportements de merge selon les méthodes, mais cela rend encore plus obscure\nla compréhension du fonctionnement de nos composants.</li>\n<li>Si l'on veut des APIs <strong>interopérables</strong>, on ne peut pas partir de l'héritage.\nReact offre trois moyens de définir un composant: <code>class extends React.Component {}</code>, <code>React.createClass({})</code> et <code>(props) => ReactElement</code>. Les\ndeux derniers ne peuvent pas bénéficier de l'héritage.</li>\n</ul>\n<p>La meilleure façon de créer une fonctionnalité réutilisable est d'utiliser le\npattern du <strong>Higher Order Component</strong> (ou <em>HOC</em>). Ce que ça veut dire, c'est\nqu'on va simplement wrapper un composant dans un autre, lequel a pour unique\nrôle d'injecter la fonctionnalité et de la passer via les <code>props</code>. Il s'agit\ntout bêtement du principe de composition : au lieu d'exporter <code>A</code>, vous exportez\n<code>Wrapped(A)</code>, et ce dernier retourne un composant React qui va appeler <code>A</code> dans\nsa méthode <code>render</code>.</p>\n<p>Pour le voir simplement, il s'agit d'un point intermédiaire dans l'arbre de vos\ncomposants, qui injecte quelques <code>props</code>. Il existe beaucoup d'avantages\napportés par ce pattern :</p>\n<ul>\n<li><strong>Isolation</strong> : Il n'y a pas de risque de collision de propriétés au sein du\ncomposant.</li>\n<li><strong>Interopérabilité</strong> : Ce principe s'adapte à tout composant React, peu\nimporte la façon dont il a été défini.</li>\n<li><strong>Maintenabilité</strong> : Le wrapper n'aura qu'une seule fonctionnalité, ce qui le\nrend plus simple à comprendre. De plus, si l'on utilise le <code>context</code>, on ne\ntrouvera le mapping <code>contextTypes</code> qu'à un seul endroit dans l'app.</li>\n</ul>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> React, { Component, PropTypes } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"react\"</span>\n\n<span class=\"hljs-keyword\">const</span> themed = <span class=\"hljs-function\">(<span class=\"hljs-params\">ComponentToWrap</span>) =></span> {\n  <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ThemeComponent</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n    render() {\n      <span class=\"hljs-keyword\">const</span> { theme } = <span class=\"hljs-keyword\">this</span>.context\n      <span class=\"hljs-comment\">// le component va render `ComponentToWrap`</span>\n      <span class=\"hljs-comment\">// mais il va y ajouter la prop `theme`, qu'il récupère du `context`</span>\n      <span class=\"hljs-keyword\">return</span> (\n        <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">ComponentToWrap</span> {…<span class=\"hljs-attr\">this.props</span>} <span class=\"hljs-attr\">theme</span>=<span class=\"hljs-string\">{theme}</span> /></span>\n      )\n    }\n  }\n  // on définit ce qu'on veut consommer du `context`\n  ThemeComponent.contextTypes = {\n    theme: PropTypes.object.isRequired,\n  }\n\n  // on retourne notre wrapper\n  return ThemeComponent\n}\nexport default themed</span></code></pre>\n<p>Pour utiliser notre HOC, il suffira d'exporter nos composants wrappés :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">import</span> React <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"React\"</span>;\n<span class=\"hljs-keyword\">import</span> themed <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"themed\"</span>;\n\n<span class=\"hljs-keyword\">const</span> MyStatelessComponent = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ text, theme }</span>) =></span> (\n  <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">{{</span> <span class=\"hljs-attr\">color:</span> <span class=\"hljs-attr\">theme.color</span> }}></span>{text}<span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n);\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> themed(MyStatelessComponent);</code></pre>\n<p>Puisqu'il s'agit simplement d'une fonction, on peut y passer des options à\nl'aide d'une simple closure.</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> defaultMergeProps = <span class=\"hljs-function\">(<span class=\"hljs-params\">ownProps, themeProps</span>) =></span> ({  ...ownProps, ...themeProps })\n\n<span class=\"hljs-keyword\">const</span> theme = <span class=\"hljs-function\">(<span class=\"hljs-params\">mergeProps = defaultMergeProps</span>) =></span>\n  (ComponentToWrap) => {\n    <span class=\"hljs-comment\">// …</span>\n    render() {\n      <span class=\"hljs-keyword\">const</span> { theme } = <span class=\"hljs-keyword\">this</span>.context\n      <span class=\"hljs-keyword\">const</span> props = mergeProps(<span class=\"hljs-keyword\">this</span>.props, { theme })\n      <span class=\"hljs-keyword\">return</span> (\n        <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">ComponentToWrap</span> {…<span class=\"hljs-attr\">props</span>} /></span>\n      )\n    }\n    // …\n  }</span></code></pre>\n<p>et l'utiliser de cette façon :</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> mergeProps = <span class=\"hljs-function\">(<span class=\"hljs-params\">ownProps, themeProps</span>) =></span> ({\n  ...themeProps,\n  <span class=\"hljs-attr\">color</span>: themeProps.theme.color\n});\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> theme(mergeProps)(MyComponent);</code></pre>\n<p>Une astuce sympathique lorsque vous utilisez plusieurs HOC, c'est de les\ncomposer, puisque <code>compose(A, B, C)(props)</code> vaudra <code>A(B(C(props)))</code>, par exemple\n:</p>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> composed = compose(connect(mapStateToProps), theme());\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> composed(MyComponent);</code></pre>\n<p>Bisous bisous.</p>\n","rawBody":"\n## Le pattern provider\n\nBeaucoup de bibliotèques React ont besoin de faire passer des data au travers de\ntout l'arbre de composants de votre app. Par exemple Redux a besoin de passer\nson _store_ et React Router doit passer l'objet *location*. Tout ça pourrait\npossiblement passer par du _shared mutable state_ (état global mutable, ce qui\nest rarement une bonne idée). Le _shared mutable state_ rend impossible une\napplication à plus d'un contexte. En d'autres mots, ça ne marcherait que sur le\nclient, où l'état global correspond à celui de l'utilisateur. Si vous décidez de\nrendre la page côté serveur, c'est impossible de reposer sur une telle\nimplémentation : cet état ne doit pas dépasser le scope de la requête courante\nau serveur.\n\nCoup de bol, l'API de React nous offre une solution à ce problème: le\n[`context`](http://facebook.github.io/react/docs/context.html). Si l'on résume\nsa nature, c'est comme l'objet global de votre arbre de composants.\n\nLe `context` fonctionne de la façon suivante:\n\n* On définit haut dans notre app un `context` que l'on donne aux composants\n  descendants de l'app\n* On récupère ce contexte dans les composants descendants.\n\nDu coup, pour _donner_ ce `context`, on doit avoir un `Provider`. Son rôle est\nsimplement de fournir un `context` pour que les composants enfants y aient\naccès.\n\nOn va illustrer ce pattern avec un use-case très simple : dans notre app, les\nutilisateurs peuvent customiser le thème.\n\n```javascript\nimport React, { Component, PropTypes, Children } from \"react\";\n\nclass ThemeProvider extends Component {\n  // la méthode getChildContext est appelée pour fournir le `context`\n  // dans notre cas, on le récupère des `props`\n  getChildContext() {\n    return {\n      theme: this.props.theme\n    };\n  }\n  // on render l'enfant\n  render() {\n    return Children.only(this.props.children);\n  }\n}\n\nThemeProvider.propTypes = {\n  theme: PropTypes.object.isRequired\n};\n\n// pour que React prenne en compte le context fourni,\n// on doit définir les types des propriétés que l'on passe\nThemeProvider.childContextTypes = {\n  theme: PropTypes.object.isRequired\n};\n\nexport default ThemeProvider;\n```\n\nPour utiliser le provider, il suffit de wrapper notre app avec:\n\n```javascript\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport ThemeProvider from \"ThemeProvider\";\nimport App from \"App\";\n\nconst theme = {\n  color: \"#cc3300\",\n  fontFamily: \"Georgia\"\n};\n\nReactDOM.render(\n  <ThemeProvider theme={theme}>\n    <App />\n  </ThemeProvider>,\n  document.querySelector(\"#App\")\n);\n```\n\nMaintenant que notre `theme` est bien ajouté au `context`, on a besoin d'un\nmoyen simple pour que nos composants dans l'app puissent le consommer. Ça nous\namène au second pattern.\n\n## Le pattern Higher-Order Component\n\nAfin de consommer le `context`, un component doit définir une propriété statique\n`contextTypes` stipulant quelles propriétés le composant souhaite récupérer. On\npourrait le définir sur chaque composant, mais cela serait une mauvaise idée\npour deux raisons :\n\n* **La maintenabilité** : si à un moment, on a besoin de refacto, avoir tous ces\n  `contextTypes` éparpillés dans notre repository peut faire bien mal.\n* **La complexité**: L'API des `context` étant encore obscure pour beaucoup, il\n  est préférable de faire une abstraction pour la masquer.\n\nUne autre solution serait d'utiliser l'héritage d'une sous-classe de\n`ReactComponent`. Ça ne marche pas pour deux raisons:\n\n* Plus d'un niveau d'héritage est en général une idée de merde. Cela mène\n  souvent à des conflits entre méthodes, et force à vérifier toute la chaîne\n  d'héritage à chaque fois que l'on souhaite modifier quelque chose. L'API des\n  `mixins` de `React.createClass` réglait ce souci en définissant des\n  comportements de merge selon les méthodes, mais cela rend encore plus obscure\n  la compréhension du fonctionnement de nos composants.\n* Si l'on veut des APIs **interopérables**, on ne peut pas partir de l'héritage.\n  React offre trois moyens de définir un composant: `class extends\n  React.Component {}`, `React.createClass({})` et `(props) => ReactElement`. Les\n  deux derniers ne peuvent pas bénéficier de l'héritage.\n\nLa meilleure façon de créer une fonctionnalité réutilisable est d'utiliser le\npattern du **Higher Order Component** (ou *HOC*). Ce que ça veut dire, c'est\nqu'on va simplement wrapper un composant dans un autre, lequel a pour unique\nrôle d'injecter la fonctionnalité et de la passer via les `props`. Il s'agit\ntout bêtement du principe de composition : au lieu d'exporter `A`, vous exportez\n`Wrapped(A)`, et ce dernier retourne un composant React qui va appeler `A` dans\nsa méthode `render`.\n\nPour le voir simplement, il s'agit d'un point intermédiaire dans l'arbre de vos\ncomposants, qui injecte quelques `props`. Il existe beaucoup d'avantages\napportés par ce pattern :\n\n* **Isolation** : Il n'y a pas de risque de collision de propriétés au sein du\n  composant.\n* **Interopérabilité** : Ce principe s'adapte à tout composant React, peu\n  importe la façon dont il a été défini.\n* **Maintenabilité** : Le wrapper n'aura qu'une seule fonctionnalité, ce qui le\n  rend plus simple à comprendre. De plus, si l'on utilise le `context`, on ne\n  trouvera le mapping `contextTypes` qu'à un seul endroit dans l'app.\n\n```javascript\nimport React, { Component, PropTypes } from \"react\"\n\nconst themed = (ComponentToWrap) => {\n  class ThemeComponent extends Component {\n    render() {\n      const { theme } = this.context\n      // le component va render `ComponentToWrap`\n      // mais il va y ajouter la prop `theme`, qu'il récupère du `context`\n      return (\n        <ComponentToWrap {…this.props} theme={theme} />\n      )\n    }\n  }\n  // on définit ce qu'on veut consommer du `context`\n  ThemeComponent.contextTypes = {\n    theme: PropTypes.object.isRequired,\n  }\n\n  // on retourne notre wrapper\n  return ThemeComponent\n}\nexport default themed\n```\n\nPour utiliser notre HOC, il suffira d'exporter nos composants wrappés :\n\n```javascript\nimport React from \"React\";\nimport themed from \"themed\";\n\nconst MyStatelessComponent = ({ text, theme }) => (\n  <div style={{ color: theme.color }}>{text}</div>\n);\n\nexport default themed(MyStatelessComponent);\n```\n\nPuisqu'il s'agit simplement d'une fonction, on peut y passer des options à\nl'aide d'une simple closure.\n\n```javascript\nconst defaultMergeProps = (ownProps, themeProps) => ({  ...ownProps, ...themeProps })\n\nconst theme = (mergeProps = defaultMergeProps) =>\n  (ComponentToWrap) => {\n    // …\n    render() {\n      const { theme } = this.context\n      const props = mergeProps(this.props, { theme })\n      return (\n        <ComponentToWrap {…props} />\n      )\n    }\n    // …\n  }\n```\n\net l'utiliser de cette façon :\n\n```javascript\nconst mergeProps = (ownProps, themeProps) => ({\n  ...themeProps,\n  color: themeProps.theme.color\n});\nexport default theme(mergeProps)(MyComponent);\n```\n\nUne astuce sympathique lorsque vous utilisez plusieurs HOC, c'est de les\ncomposer, puisque `compose(A, B, C)(props)` vaudra `A(B(C(props)))`, par exemple\n:\n\n```javascript\nconst composed = compose(connect(mapStateToProps), theme());\n\nexport default composed(MyComponent);\n```\n\nBisous bisous.\n","__filename":"fr/articles/js/react/higher-order-component/index.md","__url":"/fr/articles/js/react/higher-order-component/","__resourceUrl":"/fr/articles/js/react/higher-order-component/index.html","__dataUrl":"/fr/articles/js/react/higher-order-component/index.html.b2b4182ad73f261cd311839455a96857.json"}