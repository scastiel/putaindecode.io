{"head":{"layout":"Post","comments":true,"date":"2017-11-23","title":"Flow avancé - Première partie","tags":["javascript","flow","type"],"authors":["zoontek"],"description":"Ça y est: vos collègues ont enfin réussi à vous motiver à utiliser flow, l'outil de Facebook vous permettant d'ajouter du typage fort au…"},"body":"<p>Ça y est: vos collègues ont enfin réussi à vous motiver à utiliser <a href=\"https://flow.org/en/\">flow</a>, l'outil de Facebook vous permettant d'ajouter du typage fort au sein de vos fichiers JavaScript. Seulement voilà, vous avez utilisé des langages à typage dynamique faible toute votre vie (PHP, JavaScript, Ruby, Python…), et pour le moment vous vous contentez d'ajouter des annotations de types <code>Object</code>, <code>Function</code> ou encore <code>string</code>. Frustrés, vous ne pouvez vous empêcher de crier sur tous les toits que le typage, c'est quand même chiant et limite une perte de temps puisque flow continue de manquer un tas d'erreurs potentielles au sein de votre code. Cet article est là pour vous aider à comprendre de quoi le bouzin est réellement capable, et même si vous n'utilisez pas flow, il peut servir de chouette introduction un peu poussée à son utilisation.</p>\n<p>Nous utiliserons la dernière version en date à l'heure où j'écris ces lignes, c'est à dire la 0.59.\nPour l'ajouter au sein de votre projet, petit rappel:</p>\n<pre><code class=\"hljs language-sh\">npm install --save-dev flow-bin\nnpm install --save-dev flow-remove-types <span class=\"hljs-comment\"># pour les besoin du tuto - vous pouvez également utiliser babel et le couple babel-plugin-syntax-flow / babel-plugin-transform-flow-strip-types</span>\nnpx flow init <span class=\"hljs-comment\"># pour créer le fichier .flowconfig</span></code></pre>\n<p><em>Pour plus d'infos sur npx, c'est <a href=\"https://www.npmjs.com/package/npx\">par ici</a>. À noter que c'est livré de base avec npm maintenant.</em></p>\n<h2 id=\"rappels-sur-linférence-de-type\"><a href=\"#rappels-sur-linf%C3%A9rence-de-type\" class=\"phenomic-HeadingAnchor\">#</a>Rappels sur l'inférence de type</h2>\n<p>Flow est un outil intelligent: il est inutile de préciser quel type est utilisé si celui-ci est évident à l'usage.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow &#x3C;- le pragma nécessaire pour indiquer à flow d'analyser votre fichier. À noter que si vous l'ajoutez sur un projet tout neuf, vous pouvez le configurer pour que celui-ci ne soit pas nécessaire</span>\n\n<span class=\"hljs-keyword\">const</span> quote = <span class=\"hljs-string\">\"Thirouin rouin rouin rouin\"</span>;\n<span class=\"hljs-built_in\">Math</span>.round(quote); <span class=\"hljs-comment\">// erreur! le type attendu est un number</span>\n\n<span class=\"hljs-keyword\">const</span> sayHello = <span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =></span> <span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">${name}</span>`</span>; <span class=\"hljs-comment\">// inféré en (name: any) => string</span>\nsayHello(<span class=\"hljs-string\">\"Mathieu\"</span>); <span class=\"hljs-comment\">// pas d'erreur</span>\nsayHello(<span class=\"hljs-number\">42</span>); <span class=\"hljs-comment\">// pas d'erreur</span>\nsayHello([<span class=\"hljs-string\">\"Mathieu\"</span>, <span class=\"hljs-string\">\"zoontek\"</span>]); <span class=\"hljs-comment\">// erreur: ne peut être un array</span></code></pre>\n<p>Attention: En annotant la fonction <code>sayHello</code> du type <code>Function</code>, vous perdez carrément l'inférence. Comme quoi, parfois ne pas préciser le type d'une variable peut se montrer plus efficace que d'utiliser des types \"génériques\" tels que <code>Object</code> ou <code>Function</code> (d'ailleurs je vous encourage à ne jamais le faire).</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">const</span> sayHello: <span class=\"hljs-built_in\">Function</span> = <span class=\"hljs-function\"><span class=\"hljs-params\">name</span> =></span> <span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">${name}</span>`</span>; <span class=\"hljs-comment\">// inféré en (name: any) => any</span></code></pre>\n<p>Si vous désirez interpoler un string, la bonne façon de faire est bien sûr la suivante :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-keyword\">const</span> sayHello = <span class=\"hljs-function\">(<span class=\"hljs-params\">name: string</span>) =></span> <span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">${name}</span>`</span>; <span class=\"hljs-comment\">// (name: string) => string</span>\nsayHello(<span class=\"hljs-string\">\"Mathieu\"</span>); <span class=\"hljs-comment\">// pas d'erreur</span>\nsayHello(<span class=\"hljs-number\">42</span>); <span class=\"hljs-comment\">// pas d'erreur</span></code></pre>\n<h2 id=\"les-types-primitifs-et-litéraux\"><a href=\"#les-types-primitifs-et-lit%C3%A9raux\" class=\"phenomic-HeadingAnchor\">#</a>Les types primitifs et litéraux</h2>\n<p>Le nombre de types primitifs existants en JavaScript est assez restreint. Vous avez le nombre (<code>number</code>), la chaine de caractères (<code>string</code>), les booléens (<code>boolean</code>), et bien évidemment les valeurs nulles (<code>null</code>) et inexistantes (<code>void</code>).\nÀ noter que ES2015 a également apporté (<code>Symbol</code>), mais que ce dernier n'est pas encore supporté par flow.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">const</span> a: number = <span class=\"hljs-number\">42</span>;\n<span class=\"hljs-keyword\">const</span> b: string = <span class=\"hljs-string\">\"Je ne suis pas Coluche, certes\"</span>;\n<span class=\"hljs-keyword\">const</span> c: boolean = <span class=\"hljs-literal\">true</span>;\n<span class=\"hljs-keyword\">const</span> d: <span class=\"hljs-literal\">null</span> = <span class=\"hljs-literal\">null</span>;\n<span class=\"hljs-keyword\">const</span> e: <span class=\"hljs-keyword\">void</span> = <span class=\"hljs-literal\">undefined</span>;</code></pre>\n<p>Afin de vous montrer plus précis encore, vous pouvez également utiliser des valeurs litérales comme type. Après tout <code>string</code>, ça peut être tout et n'importe quoi. Si cela peut vous sembler stupide dans un premier temps, ceux-ci sont <strong>extrêmement</strong> utiles lorsque le système de typage est suffisamment perfectionné, commme vous le verrez par la suite.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">const</span> foo: <span class=\"hljs-string\">\"x\"</span> = <span class=\"hljs-string\">\"x\"</span>; <span class=\"hljs-comment\">// pas d'erreur</span>\n<span class=\"hljs-keyword\">const</span> bar: <span class=\"hljs-number\">2</span> = <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">// erreur! n'est pas égal à 2</span></code></pre>\n<h2 id=\"la-différence-entre-any-mixed-et-\"><a href=\"#la-diff%C3%A9rence-entre-any-mixed-et-\" class=\"phenomic-HeadingAnchor\">#</a>La différence entre <code>any</code>, <code>mixed</code> et <code>*</code></h2>\n<p>Comme expliqué au dessus, utiliser <code>any</code> revient à dire à flow qu'une variable peut être de n'importe quel type et cela est bien sûr extrêmement dangereux. Heureusement, il existe 2 alternatives plus sûres à connaître :</p>\n<ul>\n<li><code>mixed</code> qui dit que peu importe le type de la variable passée à une fonction, l'appel de celle-ci doit pouvoir se faire correctement: vous ne pourrez donc pas y appeler des méthodes spécifiques à un type de variable en particulier.</li>\n<li><code>*</code> qui laisse travailler l'inférence de type de flow.</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">arg: mixed</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(arg);\n} <span class=\"hljs-comment\">// pas d'erreur: peu importe le type réel du paramètre arg, l'appel se fera correctement</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bar</span>(<span class=\"hljs-params\">arg: mixed</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(arg.toUpperCase());\n} <span class=\"hljs-comment\">// erreur! arg pourrait ne pas être une string</span>\n\n<span class=\"hljs-keyword\">const</span> baz: <span class=\"hljs-built_in\">Array</span>&#x3C;*> = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]; <span class=\"hljs-comment\">// inféré en Array&#x3C;number></span>\nbaz.push(<span class=\"hljs-string\">\"Hello\"</span>); <span class=\"hljs-comment\">// \"foo\" est maintenant inféré en Array&#x3C;number | string> (tableau de string ou de numbers)</span></code></pre>\n<h2 id=\"les-types-optionnels-ou-maybe-types\"><a href=\"#les-types-optionnels-ou-maybe-types\" class=\"phenomic-HeadingAnchor\">#</a>Les types optionnels (ou maybe types)</h2>\n<p>Si vous avez déjà utilisé un langage qui essaye d'éviter <a href=\"https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare\">l'erreur à un milliard de dollars</a>, vous connaissez sûrement les types <code>Option</code> / <code>Maybe</code>. Ils représentent la possible absence d'une valeur et sont ici symbolisés à l'aide d'un point d'interrogation.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">let</span> foo: ?string; <span class=\"hljs-comment\">// peut-être une string, null ou undefined</span>\nfoo = <span class=\"hljs-string\">\"foo\"</span>; <span class=\"hljs-comment\">// pas d'erreur</span>\nfoo = <span class=\"hljs-literal\">undefined</span>; <span class=\"hljs-comment\">// pas d'erreur</span>\nfoo = <span class=\"hljs-literal\">null</span>; <span class=\"hljs-comment\">// pas d'erreur</span>\nfoo = <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">// erreur - number n'est ni une string, ni null, ni undefined</span>\n\ntype Bar = {\n  baz?: string; <span class=\"hljs-comment\">// baz sera forcément une string si elle est présente</span>\n};\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">wrongToUpperCase</span>(<span class=\"hljs-params\">str: ?string</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> str.toUpperCase(); <span class=\"hljs-comment\">// erreur, str est possiblement nul, vous devez traiter ce cas</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">correctToUpperCase</span>(<span class=\"hljs-params\">str: ?string</span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> str === <span class=\"hljs-string\">\"string\"</span>) {\n    <span class=\"hljs-keyword\">return</span> str.toUpperCase(); <span class=\"hljs-comment\">// pas d'erreur</span>\n  }\n}</code></pre>\n<h2 id=\"les-types-génériques-generics\"><a href=\"#les-types-g%C3%A9n%C3%A9riques-generics\" class=\"phenomic-HeadingAnchor\">#</a>Les types génériques (generics)</h2>\n<p>Vous souvenez-vous de la syntaxe des tableaux (<code>Array&#x3C;any></code>) croisée plus tôt? Il s'agit de ce qu'on appelle un type générique : un type construit depuis un autre type. Ainsi, si <code>Array&#x3C;any></code> symbolise un tableau de tout et n'importe quoi, <code>Array&#x3C;number></code> symbolisera un tableau de numbers, etc.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-comment\">// on crée un type Classement qui prend en \"paramètre\" un type générique qu'on nomme \"T\"</span>\ntype Classement&#x3C;T> = {\n  <span class=\"hljs-attr\">first</span>: T,\n  <span class=\"hljs-attr\">second</span>: T,\n  <span class=\"hljs-attr\">third</span>: T\n};\n\n<span class=\"hljs-keyword\">const</span> numberClassement: Classement&#x3C;number> = {\n  <span class=\"hljs-attr\">first</span>: <span class=\"hljs-number\">42</span>,\n  <span class=\"hljs-attr\">second</span>: <span class=\"hljs-number\">7</span>,\n  <span class=\"hljs-attr\">third</span>: <span class=\"hljs-number\">1</span>\n};</code></pre>\n<p>Voici quelques exemples de types génériques disponibles out-of-the-box :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">const</span> foo: <span class=\"hljs-built_in\">Array</span>&#x3C;number> = [];\n\n<span class=\"hljs-keyword\">const</span> bar: <span class=\"hljs-built_in\">Map</span>&#x3C;number, string> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>();\nbar.set(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">\"one\"</span>);\n\n<span class=\"hljs-keyword\">const</span> baz: <span class=\"hljs-built_in\">Set</span>&#x3C;number> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>();\nbaz.add(<span class=\"hljs-number\">1</span>);\n\n<span class=\"hljs-keyword\">const</span> p: <span class=\"hljs-built_in\">Promise</span>&#x3C;number> = <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-number\">42</span>);</code></pre>\n<h2 id=\"la-manipulation-dobjets\"><a href=\"#la-manipulation-dobjets\" class=\"phenomic-HeadingAnchor\">#</a>La manipulation d'objets</h2>\n<p>Avez vous remarqué que pour le moment, j'ai tenté de ne pas utiliser d'objets au sein de mes exemples (oui, c'était chiant)? C'est tout simplement car les possibilités de manipulation des types de ceux-ci sont très nombreuses. Je vous propose un exemple fleuve histoire d'y voir plus clair.</p>\n<p>Un type objet se définit de la sorte :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype User = {\n  <span class=\"hljs-attr\">name</span>: string,\n  <span class=\"hljs-attr\">pseudo</span>: string\n};\n\n<span class=\"hljs-keyword\">const</span> user: User = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"Mathieu\"</span>,\n  <span class=\"hljs-attr\">pseudo</span>: <span class=\"hljs-string\">\"zoontek\"</span>\n};\n\n<span class=\"hljs-comment\">// Ce qui n'exclut pas de faire</span>\n<span class=\"hljs-keyword\">const</span> newUser: User = {\n  ...user,\n  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">26</span>\n}; <span class=\"hljs-comment\">// pas d'erreur</span></code></pre>\n<p>Pour sceller les propriétés de notre objet, on utilise la notation <code>{||}</code> :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype User = {|\n  name: string,\n  <span class=\"hljs-attr\">pseudo</span>: string\n|};\n\n<span class=\"hljs-keyword\">const</span> user: User = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"Mathieu\"</span>,\n  <span class=\"hljs-attr\">pseudo</span>: <span class=\"hljs-string\">\"zoontek\"</span>\n};\n\n<span class=\"hljs-keyword\">const</span> newUser: User = {\n  ...user,\n  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">26</span>\n}; <span class=\"hljs-comment\">// erreur! la propriété age n'existe pas</span></code></pre>\n<p>Pour indiquer qu'une propriété de notre objet est immutable, on utilise la notation <code>+</code>. Un must-have pour vos reducers Redux.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype User = {\n  +name: string,\n  <span class=\"hljs-attr\">pseudo</span>: string\n};\n\n<span class=\"hljs-keyword\">const</span> user: User = {\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"Mathieu\"</span>,\n  <span class=\"hljs-attr\">pseudo</span>: <span class=\"hljs-string\">\"zoontek\"</span>\n};\n\nuser.name = <span class=\"hljs-string\">\"Jean-Michel\"</span>; <span class=\"hljs-comment\">// erreur! la valeur de name ne peut-être modifiée</span>\n\n<span class=\"hljs-keyword\">const</span> newUser: User = {\n  ...user,\n  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"Jean-Michel\"</span>\n}; <span class=\"hljs-comment\">// pas d'erreur</span></code></pre>\n<blockquote>\n<p>Le spreading c'est vraiment cool! Ça existe aussi pour les types?</p>\n</blockquote>\n<p>Yep.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype Foo = {| a: number, <span class=\"hljs-attr\">b</span>: string |};\ntype Bar = {| a: string |};\ntype Baz = {| ...Foo, ...Bar |}; <span class=\"hljs-comment\">// {| a: string, b: string |}</span></code></pre>\n<p>Un dernier petit trick sur les objets pour la route? Vous pouvez les utiliser comme maps :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">const</span> foo: { [key: string]: number } = {\n  <span class=\"hljs-attr\">bar</span>: <span class=\"hljs-number\">42</span>,\n  <span class=\"hljs-attr\">baz</span>: <span class=\"hljs-string\">\"whatever\"</span> <span class=\"hljs-comment\">// erreur! les valeurs des propriétés de cet objet doivent être de type number</span>\n};</code></pre>\n<h2 id=\"les-unions-et-intersections-de-types\"><a href=\"#les-unions-et-intersections-de-types\" class=\"phenomic-HeadingAnchor\">#</a>Les unions et intersections de types</h2>\n<p>Si vous avez remarqué la notation avec <code>|</code> plus tôt, vous vous posez sûrement la question de ce que ça représente. Il s'agit d'une union de types : la variable aura une valeur à plusieurs types possibles. Petit conseil : utilisez toujours une union de types litéraux à la place du simple <code>string</code> lorsque vous connaissez à l'avance les possibles valeurs de celui-ci.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sayHelloOrRound</span>(<span class=\"hljs-params\">arg: string | number</span>) </span>{ <span class=\"hljs-comment\">// arg peut être une string ou un number</span>\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">typeof</span> arg === <span class=\"hljs-string\">\"string\"</span> ? <span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">${arg}</span>`</span> : <span class=\"hljs-built_in\">Math</span>.round(arg);\n} <span class=\"hljs-comment\">// pas d'erreur</span>\n\ntype Color =\n  | <span class=\"hljs-string\">\"red\"</span>\n  | <span class=\"hljs-string\">\"green\"</span>\n  | <span class=\"hljs-string\">\"blue\"</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">toHexadecimal</span>(<span class=\"hljs-params\">color: Color</span>) </span>{\n  <span class=\"hljs-keyword\">switch</span> (color) {\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"red\"</span>:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"#FF0000\"</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"green\"</span>:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"#00FF00\"</span>;\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">\"blue\"</span>:\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"#0000FF\"</span>;\n  }\n}\n\ntoHexadecimal(<span class=\"hljs-string\">\"red\"</span>); <span class=\"hljs-comment\">// pas d'erreur</span>\ntoHexadecimal(<span class=\"hljs-string\">\"green\"</span>); <span class=\"hljs-comment\">// pas d'erreur</span>\ntoHexadecimal(<span class=\"hljs-string\">\"blue\"</span>); <span class=\"hljs-comment\">// pas d'erreur</span>\ntoHexadecimal(<span class=\"hljs-string\">\"pink\"</span>); <span class=\"hljs-comment\">// erreur! \"pink\" n'est pas une valeur possible</span>\ntoHexadecimal(<span class=\"hljs-string\">\"dog\"</span>); <span class=\"hljs-comment\">// erreur! \"dog\" n'est pas une valeur possible</span></code></pre>\n<p>Parfois, une union de types se montre également bien plus efficace pour modéliser ce que vous souhaitez, à contrario d'un tas de maybe types.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype ApiResponseBadlyTyped = {|\n  success: boolean,\n  value?: string, <span class=\"hljs-comment\">// value peut être présent</span>\n  error?: <span class=\"hljs-built_in\">Error</span> <span class=\"hljs-comment\">// error peut être présent</span>\n|};\n\n<span class=\"hljs-keyword\">const</span> foo: ApiResponseBadlyTyped = { <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">true</span> }; <span class=\"hljs-comment\">// pas d'erreur alors que j'attends une value</span>\n<span class=\"hljs-keyword\">const</span> bar: ApiResponseBadlyTyped = { <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">error</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">\"oups!\"</span>) }; <span class=\"hljs-comment\">// pas d'erreur non plus</span>\n\ntype ApiResponseCorrectlyTyped =\n  | {| success: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">value</span>: string |}\n  | {| success: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-attr\">error</span>: <span class=\"hljs-built_in\">Error</span> |};\n\n<span class=\"hljs-keyword\">const</span> foo: ApiResponseCorrectlyTyped = { <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">true</span> }; <span class=\"hljs-comment\">// erreur! il manque value</span>\n<span class=\"hljs-keyword\">const</span> bar: ApiResponseCorrectlyTyped = { <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">error</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">\"oups!\"</span>) }; <span class=\"hljs-comment\">// erreur! si success est à true, on ne doit pas trouver d'error dans notre objet</span>\n<span class=\"hljs-keyword\">const</span> baz: ApiResponseCorrectlyTyped = { <span class=\"hljs-attr\">success</span>: <span class=\"hljs-literal\">false</span>, <span class=\"hljs-attr\">error</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">\"oups!\"</span>) }; <span class=\"hljs-comment\">// pas d'erreur</span></code></pre>\n<p>Si les unions de types sont le <strong>OU</strong> logique du système de typage, les intersections de types en sont le <strong>ET</strong>. On les symbolise à l'aide d'un <code>&#x26;</code>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype Foo = { <span class=\"hljs-attr\">a</span>: number };\ntype Bar = { <span class=\"hljs-attr\">b</span>: string };\ntype Baz = { <span class=\"hljs-attr\">c</span>: boolean };\n\n<span class=\"hljs-keyword\">const</span> test: Foo &#x26; Bar &#x26; Baz = {\n  <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">42</span>,\n  <span class=\"hljs-attr\">b</span>: <span class=\"hljs-string\">\"whatever\"</span>,\n  <span class=\"hljs-attr\">c</span>: <span class=\"hljs-literal\">true</span>\n}; <span class=\"hljs-comment\">// pas d'erreur</span>\n\n<span class=\"hljs-keyword\">let</span> impossible: number &#x26; string; <span class=\"hljs-comment\">// sera forcément impossible à initialiser : une valeur ne pourra jamais être un number ET une string</span></code></pre>\n<p>C'est tout pour le moment! Vous vous doutez que l'on égratigne à peine la surface de ce qui nous est offert par flow et les systèmes de typage fort en général. Si vous êtes vraiment impatients de découvrir la suite, je vous renvoie vers la <a href=\"https://flow.org/en/docs/\">documentation de flow</a>, très bien foutue. Pour les autres, on devrait sortir très prochainement un article sur le même sujet (on y parlera classes, interfaces et peut être même types opaques si vous êtes sages).</p>\n<p>Stay tuned! La bise.</p>\n","rawBody":"\nÇa y est: vos collègues ont enfin réussi à vous motiver à utiliser [flow](https://flow.org/en/), l'outil de Facebook vous permettant d'ajouter du typage fort au sein de vos fichiers JavaScript. Seulement voilà, vous avez utilisé des langages à typage dynamique faible toute votre vie (PHP, JavaScript, Ruby, Python…), et pour le moment vous vous contentez d'ajouter des annotations de types `Object`, `Function` ou encore `string`. Frustrés, vous ne pouvez vous empêcher de crier sur tous les toits que le typage, c'est quand même chiant et limite une perte de temps puisque flow continue de manquer un tas d'erreurs potentielles au sein de votre code. Cet article est là pour vous aider à comprendre de quoi le bouzin est réellement capable, et même si vous n'utilisez pas flow, il peut servir de chouette introduction un peu poussée à son utilisation.\n\nNous utiliserons la dernière version en date à l'heure où j'écris ces lignes, c'est à dire la 0.59.\nPour l'ajouter au sein de votre projet, petit rappel:\n\n```sh\nnpm install --save-dev flow-bin\nnpm install --save-dev flow-remove-types # pour les besoin du tuto - vous pouvez également utiliser babel et le couple babel-plugin-syntax-flow / babel-plugin-transform-flow-strip-types\nnpx flow init # pour créer le fichier .flowconfig\n```\n\n*Pour plus d'infos sur npx, c'est [par ici](https://www.npmjs.com/package/npx). À noter que c'est livré de base avec npm maintenant.*\n\n## Rappels sur l'inférence de type\n\nFlow est un outil intelligent: il est inutile de préciser quel type est utilisé si celui-ci est évident à l'usage.\n\n```js\n// @flow <- le pragma nécessaire pour indiquer à flow d'analyser votre fichier. À noter que si vous l'ajoutez sur un projet tout neuf, vous pouvez le configurer pour que celui-ci ne soit pas nécessaire\n\nconst quote = \"Thirouin rouin rouin rouin\";\nMath.round(quote); // erreur! le type attendu est un number\n\nconst sayHello = name => `Hello ${name}`; // inféré en (name: any) => string\nsayHello(\"Mathieu\"); // pas d'erreur\nsayHello(42); // pas d'erreur\nsayHello([\"Mathieu\", \"zoontek\"]); // erreur: ne peut être un array\n```\n\nAttention: En annotant la fonction `sayHello` du type `Function`, vous perdez carrément l'inférence. Comme quoi, parfois ne pas préciser le type d'une variable peut se montrer plus efficace que d'utiliser des types \"génériques\" tels que `Object` ou `Function` (d'ailleurs je vous encourage à ne jamais le faire).\n\n```js\n// @flow\n\nconst sayHello: Function = name => `Hello ${name}`; // inféré en (name: any) => any\n```\n\nSi vous désirez interpoler un string, la bonne façon de faire est bien sûr la suivante :\n\n```js\n// @flow\nconst sayHello = (name: string) => `Hello ${name}`; // (name: string) => string\nsayHello(\"Mathieu\"); // pas d'erreur\nsayHello(42); // pas d'erreur\n```\n\n## Les types primitifs et litéraux\n\nLe nombre de types primitifs existants en JavaScript est assez restreint. Vous avez le nombre (`number`), la chaine de caractères (`string`), les booléens (`boolean`), et bien évidemment les valeurs nulles (`null`) et inexistantes (`void`).\nÀ noter que ES2015 a également apporté (`Symbol`), mais que ce dernier n'est pas encore supporté par flow.\n\n```js\n// @flow\n\nconst a: number = 42;\nconst b: string = \"Je ne suis pas Coluche, certes\";\nconst c: boolean = true;\nconst d: null = null;\nconst e: void = undefined;\n```\n\nAfin de vous montrer plus précis encore, vous pouvez également utiliser des valeurs litérales comme type. Après tout `string`, ça peut être tout et n'importe quoi. Si cela peut vous sembler stupide dans un premier temps, ceux-ci sont **extrêmement** utiles lorsque le système de typage est suffisamment perfectionné, commme vous le verrez par la suite.\n\n```js\n// @flow\n\nconst foo: \"x\" = \"x\"; // pas d'erreur\nconst bar: 2 = 3; // erreur! n'est pas égal à 2\n```\n\n## La différence entre `any`, `mixed` et `*`\n\nComme expliqué au dessus, utiliser `any` revient à dire à flow qu'une variable peut être de n'importe quel type et cela est bien sûr extrêmement dangereux. Heureusement, il existe 2 alternatives plus sûres à connaître :\n\n- `mixed` qui dit que peu importe le type de la variable passée à une fonction, l'appel de celle-ci doit pouvoir se faire correctement: vous ne pourrez donc pas y appeler des méthodes spécifiques à un type de variable en particulier.\n- `*` qui laisse travailler l'inférence de type de flow.\n\n```js\n// @flow\n\nfunction foo(arg: mixed) {\n  console.log(arg);\n} // pas d'erreur: peu importe le type réel du paramètre arg, l'appel se fera correctement\n\nfunction bar(arg: mixed) {\n  console.log(arg.toUpperCase());\n} // erreur! arg pourrait ne pas être une string\n\nconst baz: Array<*> = [1, 2, 3]; // inféré en Array<number>\nbaz.push(\"Hello\"); // \"foo\" est maintenant inféré en Array<number | string> (tableau de string ou de numbers)\n```\n\n## Les types optionnels (ou maybe types)\n\nSi vous avez déjà utilisé un langage qui essaye d'éviter [l'erreur à un milliard de dollars](https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare), vous connaissez sûrement les types `Option` / `Maybe`. Ils représentent la possible absence d'une valeur et sont ici symbolisés à l'aide d'un point d'interrogation.\n\n```js\n// @flow\n\nlet foo: ?string; // peut-être une string, null ou undefined\nfoo = \"foo\"; // pas d'erreur\nfoo = undefined; // pas d'erreur\nfoo = null; // pas d'erreur\nfoo = 3; // erreur - number n'est ni une string, ni null, ni undefined\n\ntype Bar = {\n  baz?: string; // baz sera forcément une string si elle est présente\n};\n\nfunction wrongToUpperCase(str: ?string) {\n  return str.toUpperCase(); // erreur, str est possiblement nul, vous devez traiter ce cas\n}\n\nfunction correctToUpperCase(str: ?string) {\n  if (typeof str === \"string\") {\n    return str.toUpperCase(); // pas d'erreur\n  }\n}\n```\n\n## Les types génériques (generics)\n\nVous souvenez-vous de la syntaxe des tableaux (`Array<any>`) croisée plus tôt? Il s'agit de ce qu'on appelle un type générique : un type construit depuis un autre type. Ainsi, si `Array<any>` symbolise un tableau de tout et n'importe quoi, `Array<number>` symbolisera un tableau de numbers, etc.\n\n```js\n// @flow\n\n// on crée un type Classement qui prend en \"paramètre\" un type générique qu'on nomme \"T\"\ntype Classement<T> = {\n  first: T,\n  second: T,\n  third: T\n};\n\nconst numberClassement: Classement<number> = {\n  first: 42,\n  second: 7,\n  third: 1\n};\n```\n\nVoici quelques exemples de types génériques disponibles out-of-the-box :\n\n```js\n// @flow\n\nconst foo: Array<number> = [];\n\nconst bar: Map<number, string> = new Map();\nbar.set(1, \"one\");\n\nconst baz: Set<number> = new Set();\nbaz.add(1);\n\nconst p: Promise<number> = Promise.resolve(42);\n```\n\n## La manipulation d'objets\n\nAvez vous remarqué que pour le moment, j'ai tenté de ne pas utiliser d'objets au sein de mes exemples (oui, c'était chiant)? C'est tout simplement car les possibilités de manipulation des types de ceux-ci sont très nombreuses. Je vous propose un exemple fleuve histoire d'y voir plus clair.\n\nUn type objet se définit de la sorte :\n\n```js\n// @flow\n\ntype User = {\n  name: string,\n  pseudo: string\n};\n\nconst user: User = {\n  name: \"Mathieu\",\n  pseudo: \"zoontek\"\n};\n\n// Ce qui n'exclut pas de faire\nconst newUser: User = {\n  ...user,\n  age: 26\n}; // pas d'erreur\n\n```\n\nPour sceller les propriétés de notre objet, on utilise la notation `{||}` :\n\n```js\n// @flow\n\ntype User = {|\n  name: string,\n  pseudo: string\n|};\n\nconst user: User = {\n  name: \"Mathieu\",\n  pseudo: \"zoontek\"\n};\n\nconst newUser: User = {\n  ...user,\n  age: 26\n}; // erreur! la propriété age n'existe pas\n```\n\nPour indiquer qu'une propriété de notre objet est immutable, on utilise la notation `+`. Un must-have pour vos reducers Redux.\n\n```js\n// @flow\n\ntype User = {\n  +name: string,\n  pseudo: string\n};\n\nconst user: User = {\n  name: \"Mathieu\",\n  pseudo: \"zoontek\"\n};\n\nuser.name = \"Jean-Michel\"; // erreur! la valeur de name ne peut-être modifiée\n\nconst newUser: User = {\n  ...user,\n  name: \"Jean-Michel\"\n}; // pas d'erreur\n```\n\n> Le spreading c'est vraiment cool! Ça existe aussi pour les types?\n\nYep.\n\n```js\n// @flow\n\ntype Foo = {| a: number, b: string |};\ntype Bar = {| a: string |};\ntype Baz = {| ...Foo, ...Bar |}; // {| a: string, b: string |}\n```\n\nUn dernier petit trick sur les objets pour la route? Vous pouvez les utiliser comme maps :\n\n```js\n// @flow\n\nconst foo: { [key: string]: number } = {\n  bar: 42,\n  baz: \"whatever\" // erreur! les valeurs des propriétés de cet objet doivent être de type number\n};\n```\n\n## Les unions et intersections de types\n\nSi vous avez remarqué la notation avec `|` plus tôt, vous vous posez sûrement la question de ce que ça représente. Il s'agit d'une union de types : la variable aura une valeur à plusieurs types possibles. Petit conseil : utilisez toujours une union de types litéraux à la place du simple `string` lorsque vous connaissez à l'avance les possibles valeurs de celui-ci.\n\n```js\n// @flow\n\nfunction sayHelloOrRound(arg: string | number) { // arg peut être une string ou un number\n  return typeof arg === \"string\" ? `Hello ${arg}` : Math.round(arg);\n} // pas d'erreur\n\ntype Color =\n  | \"red\"\n  | \"green\"\n  | \"blue\"\n\nfunction toHexadecimal(color: Color) {\n  switch (color) {\n    case \"red\":\n      return \"#FF0000\";\n    case \"green\":\n      return \"#00FF00\";\n    case \"blue\":\n      return \"#0000FF\";\n  }\n}\n\ntoHexadecimal(\"red\"); // pas d'erreur\ntoHexadecimal(\"green\"); // pas d'erreur\ntoHexadecimal(\"blue\"); // pas d'erreur\ntoHexadecimal(\"pink\"); // erreur! \"pink\" n'est pas une valeur possible\ntoHexadecimal(\"dog\"); // erreur! \"dog\" n'est pas une valeur possible\n```\n\nParfois, une union de types se montre également bien plus efficace pour modéliser ce que vous souhaitez, à contrario d'un tas de maybe types.\n\n```js\n// @flow\n\ntype ApiResponseBadlyTyped = {|\n  success: boolean,\n  value?: string, // value peut être présent\n  error?: Error // error peut être présent\n|};\n\nconst foo: ApiResponseBadlyTyped = { success: true }; // pas d'erreur alors que j'attends une value\nconst bar: ApiResponseBadlyTyped = { success: true, error: new Error(\"oups!\") }; // pas d'erreur non plus\n\ntype ApiResponseCorrectlyTyped =\n  | {| success: true, value: string |}\n  | {| success: false, error: Error |};\n\nconst foo: ApiResponseCorrectlyTyped = { success: true }; // erreur! il manque value\nconst bar: ApiResponseCorrectlyTyped = { success: true, error: new Error(\"oups!\") }; // erreur! si success est à true, on ne doit pas trouver d'error dans notre objet\nconst baz: ApiResponseCorrectlyTyped = { success: false, error: new Error(\"oups!\") }; // pas d'erreur\n```\n\nSi les unions de types sont le **OU** logique du système de typage, les intersections de types en sont le **ET**. On les symbolise à l'aide d'un `&`.\n\n```js\n// @flow\n\ntype Foo = { a: number };\ntype Bar = { b: string };\ntype Baz = { c: boolean };\n\nconst test: Foo & Bar & Baz = {\n  a: 42,\n  b: \"whatever\",\n  c: true\n}; // pas d'erreur\n\nlet impossible: number & string; // sera forcément impossible à initialiser : une valeur ne pourra jamais être un number ET une string\n```\n\nC'est tout pour le moment! Vous vous doutez que l'on égratigne à peine la surface de ce qui nous est offert par flow et les systèmes de typage fort en général. Si vous êtes vraiment impatients de découvrir la suite, je vous renvoie vers la [documentation de flow](https://flow.org/en/docs/), très bien foutue. Pour les autres, on devrait sortir très prochainement un article sur le même sujet (on y parlera classes, interfaces et peut être même types opaques si vous êtes sages).\n\nStay tuned! La bise.\n","__filename":"fr/articles/js/flow/advanced-part-1.md","__url":"/fr/articles/js/flow/advanced-part-1/","__resourceUrl":"/fr/articles/js/flow/advanced-part-1/index.html","__dataUrl":"/fr/articles/js/flow/advanced-part-1/index.html.76cab916ee4f62e03b078b2fed6f042e.json"}