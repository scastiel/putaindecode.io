{"head":{"layout":"Post","comments":true,"date":"2018-01-02","title":"Flow avancé - Seconde partie: les types opaques","tags":["javascript","flow","type"],"authors":["zoontek"],"description":"Vous avez digéré le premier article, peut-être même débuté avec flow depuis, mais vous mourez d'envie de découvrir ce que vous pouvez faire…"},"body":"<p>Vous avez digéré le premier article, peut-être même débuté avec <a href=\"https://flow.org/\">flow</a> depuis, mais vous mourez d'envie de découvrir ce que vous pouvez faire de plus avec votre nouvel outil préféré ? Tant mieux, puisque nous sommes là pour parler d'une fonctionnalité assez avancée, apparue avec la version 0.51 et, à l'heure où j'écris ces lignes, indisponible dans TypeScript: les types opaques.</p>\n<p>Si vous n'avez pas installé flow au sein de votre projet, je vous renvoie au <a href=\"/fr/articles/js/flow/advanced-part-1/\">premier article</a> qui vous expliquera très bien comment faire.</p>\n<h2 id=\"transparence-de-types\"><a href=\"#transparence-de-types\" class=\"phenomic-HeadingAnchor\">#</a>Transparence de types</h2>\n<p>Si on parle de types opaques, c'est bien parce que les types transparents existent. D'ailleurs par défaut, tout alias de type défini l'est. Mais que sont-ils ? Simple: ce sont des types compatibles entre eux et donc interchangeables.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\ntype FirstName = string;\ntype LastName = string;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">yellFirstName</span>(<span class=\"hljs-params\">firstName: FirstName</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(firstName.toUpperCase());\n}\n\n<span class=\"hljs-keyword\">const</span> name: LastName = <span class=\"hljs-string\">\"Acthernoene\"</span>;\nyellFirstName(name);</code></pre>\n<p>Dans cet exemple, les types <code>FirstName</code> et <code>LastName</code> étant tout deux des alias de <code>string</code>, on peut sans problème utiliser la variable <code>name</code> de type <code>LastName</code> là où la function <code>yellFirstName</code> attend un paramètre de type <code>FirstName</code>. Pas cool.</p>\n<h2 id=\"rendons-tout-cela-opaque\"><a href=\"#rendons-tout-cela-opaque\" class=\"phenomic-HeadingAnchor\">#</a>Rendons tout cela opaque</h2>\n<p>Nous allons donc modifier l'exemple précédent et…</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\nopaque type FirstName = string;\nopaque type LastName = string;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">yellFirstName</span>(<span class=\"hljs-params\">firstName: FirstName</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(firstName.toUpperCase());\n}\n\n<span class=\"hljs-keyword\">const</span> name: LastName = <span class=\"hljs-string\">\"Acthernoene\"</span>;\nyellFirstName(name);</code></pre>\n<p>…toujours pas d'erreur ? Du calme, c'est normal. Les types <code>FirstName</code> et <code>LastName</code> étant accessibles car dans le même module JS, flow sait que ceux-ci sont des alias de type <code>string</code>. Modifions l'exemple et créons un deuxième module.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// module.js</span>\n\nopaque type FirstName = string;\nopaque type LastName = string;\n\ntype User = {\n  <span class=\"hljs-attr\">firstName</span>: FirstName,\n  <span class=\"hljs-attr\">lastName</span>: LastName\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createUser</span>(<span class=\"hljs-params\">firstName: string, lastName: string</span>): <span class=\"hljs-title\">User</span> </span>{\n  <span class=\"hljs-keyword\">return</span> { firstName, lastName };\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">yellFirstName</span>(<span class=\"hljs-params\">firstName: FirstName</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(firstName.toUpperCase());\n}</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// usage.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createUser, yellFirstName } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./module\"</span>;\n\nyellFirstName(<span class=\"hljs-string\">\"Mathieu\"</span>); <span class=\"hljs-comment\">// ⚠️ Erreur: \"string. Ce type est incompatible avec le type de paramètre attendu FirstName\"</span>\n\n<span class=\"hljs-keyword\">const</span> user = createUser(<span class=\"hljs-string\">\"Acthernoene\"</span>, <span class=\"hljs-string\">\"Mathieu\"</span>);\nyellFirstName(user.firstName); <span class=\"hljs-comment\">// Pas d'erreur</span></code></pre>\n<p>On voit ici qu'il n'est en fait possible d'utiliser le type <code>FirstName</code> qu'après son assignation au sein du module où celui-ci est défini. Un autre exemple: si l'on venait à rendre le type <code>User</code> opaque, alors nous ne pourrions pas accéder à <code>user.firstName</code>, la propriété étant inaccessible autrement que par une fonction qui manipulera le type <code>User</code>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// module.js</span>\n\nopaque type FirstName = string;\nopaque type LastName = string;\n\nopaque type User = {\n  <span class=\"hljs-attr\">firstName</span>: FirstName,\n  <span class=\"hljs-attr\">lastName</span>: LastName\n};\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createUser</span>(<span class=\"hljs-params\">firstName: string, lastName: string</span>): <span class=\"hljs-title\">User</span> </span>{\n  <span class=\"hljs-keyword\">return</span> { firstName, lastName };\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">yellFirstName</span>(<span class=\"hljs-params\">firstName: FirstName</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(firstName.toUpperCase());\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">yellUserFirstName</span>(<span class=\"hljs-params\">user: User</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(user.firstName.toUpperCase());\n}</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// usage.js</span>\n\n<span class=\"hljs-keyword\">import</span> { createUser, yellFirstName, yellUserFirstName } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./module\"</span>;\n\n<span class=\"hljs-keyword\">const</span> user = createUser(<span class=\"hljs-string\">\"Acthernoene\"</span>, <span class=\"hljs-string\">\"Mathieu\"</span>);\nyellFirstName(user.firstName); <span class=\"hljs-comment\">// ⚠️ Erreur: \"Propriété `firstName`. La propriété n'est pas accessible sur le type User\"</span>\nyellUserFirstName(user); <span class=\"hljs-comment\">// Pas d'erreur</span></code></pre>\n<h2 id=\"tu-naurais-pas-un-exemple-plus-concret-\"><a href=\"#tu-naurais-pas-un-exemple-plus-concret-\" class=\"phenomic-HeadingAnchor\">#</a>Tu n'aurais pas un exemple plus concret ?</h2>\n<p>Bien sûr que si ! Nous pouvons utiliser les types opaques pour implémenter un type <code>UUID</code> très basique:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// uuid.js</span>\n\n<span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">import</span> uuidv4 <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"uuid/v4\"</span>; <span class=\"hljs-comment\">// On installe 2 packages</span>\n<span class=\"hljs-keyword\">import</span> validator <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"validator\"</span>;\n\n<span class=\"hljs-keyword\">export</span> opaque type UUID = string;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">create</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">UUID</span> </span>{\n  <span class=\"hljs-keyword\">return</span> uuidv4();\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">check</span>(<span class=\"hljs-params\">uuid: UUID</span>): <span class=\"hljs-title\">boolean</span> </span>{\n  <span class=\"hljs-keyword\">return</span> validator.isUUID(uuid);\n}</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// usage.js</span>\n\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> UUID <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./uuid\"</span>;\n\nUUID.check(<span class=\"hljs-string\">\"a duck\"</span>); <span class=\"hljs-comment\">// ⚠️ Erreur: \"string. Ce type est incompatible avec le type de paramètre attendu UUID\"</span>\nUUID.check(<span class=\"hljs-string\">\"df7cca36-3d7a-40f4-8f06-ae03cc22f045\"</span>); <span class=\"hljs-comment\">// ⚠️ Erreur: \"string. Ce type est incompatible avec le type de paramètre attendu UUID\"</span>\n\n<span class=\"hljs-keyword\">const</span> uuid = UUID.create();\nUUID.check(uuid); <span class=\"hljs-comment\">// Pas d'erreur</span>\n\nuuid.toUpperCase(); <span class=\"hljs-comment\">// ⚠️ Erreur: \"Appel de méthode `toUpperCase`. La méthode ne peut pas être appelée sur un type UUID\"</span></code></pre>\n<h1 id=\"cest-tout-de-même-assez-restrictifje-voudrais-ne-pas-devoir-tout-réimplémenter\"><a href=\"#cest-tout-de-m%C3%AAme-assez-restrictifje-voudrais-ne-pas-devoir-tout-r%C3%A9impl%C3%A9menter\" class=\"phenomic-HeadingAnchor\">#</a>C'est tout de même assez restrictif…je voudrais ne pas devoir tout réimplémenter</h1>\n<p>Ne vous inquiétez pas, les développeurs à l'origine de flow ont tout prévu et pour remédier à cela il existe ce qu'on appelle le sous-typage (ou <em>SubTyping</em> dans la langue de Shakespeare). Ainsi, nous allons dire à flow que chaque <code>UUID</code> est un <code>string</code> mais que la réciproque ce sera pas vraie pour autant.</p>\n<p>Reprenons l'exemple précédent.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n\n<span class=\"hljs-keyword\">import</span> uuidv4 <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"uuid/v4\"</span>;\n<span class=\"hljs-keyword\">import</span> validator <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"validator\"</span>;\n\n<span class=\"hljs-keyword\">export</span> opaque type UUID: string = string; <span class=\"hljs-comment\">// Seul cette ligne change, on y ajoute un sous-type string</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">create</span>(<span class=\"hljs-params\"></span>): <span class=\"hljs-title\">UUID</span> </span>{\n  <span class=\"hljs-keyword\">return</span> uuidv4();\n}\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">check</span>(<span class=\"hljs-params\">uuid: UUID</span>): <span class=\"hljs-title\">boolean</span> </span>{\n  <span class=\"hljs-keyword\">return</span> validator.isUUID(uuid);\n}</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// @flow</span>\n<span class=\"hljs-comment\">// usage.js</span>\n\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> UUID <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"./uuid\"</span>;\n\n<span class=\"hljs-keyword\">const</span> uuid = UUID.create();\nUUID.check(uuid); <span class=\"hljs-comment\">// Pas d'erreur</span>\n\nuuid.toUpperCase(); <span class=\"hljs-comment\">// Pas d'erreur: même si uuid est un UUID, il est utilisable comme un type string</span></code></pre>\n<h2 id=\"que-retenir-de-tout-ça-\"><a href=\"#que-retenir-de-tout-%C3%A7a-\" class=\"phenomic-HeadingAnchor\">#</a>Que retenir de tout ça ?</h2>\n<p>Comme on a pu le voir, les types opaques élèvent clairement le niveau du type-game dans le milieu du JavaScript. Forcément utiles pour imposer l'utilisation de fonctions pour créer / manipuler certaines données, ils s'avéreront assez vite indispensables pour structurer davantage votre JS et améliorer sa maintenabilité.</p>\n<p>Je vous encourage d'ailleurs à vous en servir quasiment partout (ça sera assez chiant au début, mais vous me remercierez plus tard) !</p>\n<p>La bise, et rendez-vous pour une troisième partie 😘</p>\n","rawBody":"\nVous avez digéré le premier article, peut-être même débuté avec [flow](https://flow.org/) depuis, mais vous mourez d'envie de découvrir ce que vous pouvez faire de plus avec votre nouvel outil préféré ? Tant mieux, puisque nous sommes là pour parler d'une fonctionnalité assez avancée, apparue avec la version 0.51 et, à l'heure où j'écris ces lignes, indisponible dans TypeScript: les types opaques.\n\nSi vous n'avez pas installé flow au sein de votre projet, je vous renvoie au [premier article](/fr/articles/js/flow/advanced-part-1/) qui vous expliquera très bien comment faire.\n\n## Transparence de types\n\nSi on parle de types opaques, c'est bien parce que les types transparents existent. D'ailleurs par défaut, tout alias de type défini l'est. Mais que sont-ils ? Simple: ce sont des types compatibles entre eux et donc interchangeables.\n\n```js\n// @flow\n\ntype FirstName = string;\ntype LastName = string;\n\nfunction yellFirstName(firstName: FirstName) {\n  console.log(firstName.toUpperCase());\n}\n\nconst name: LastName = \"Acthernoene\";\nyellFirstName(name);\n```\n\nDans cet exemple, les types `FirstName` et `LastName` étant tout deux des alias de `string`, on peut sans problème utiliser la variable `name` de type `LastName` là où la function `yellFirstName` attend un paramètre de type `FirstName`. Pas cool.\n\n## Rendons tout cela opaque\n\nNous allons donc modifier l'exemple précédent et…\n\n```js\n// @flow\n\nopaque type FirstName = string;\nopaque type LastName = string;\n\nfunction yellFirstName(firstName: FirstName) {\n  console.log(firstName.toUpperCase());\n}\n\nconst name: LastName = \"Acthernoene\";\nyellFirstName(name);\n```\n\n…toujours pas d'erreur ? Du calme, c'est normal. Les types `FirstName` et `LastName` étant accessibles car dans le même module JS, flow sait que ceux-ci sont des alias de type `string`. Modifions l'exemple et créons un deuxième module.\n\n```js\n// @flow\n// module.js\n\nopaque type FirstName = string;\nopaque type LastName = string;\n\ntype User = {\n  firstName: FirstName,\n  lastName: LastName\n};\n\nexport function createUser(firstName: string, lastName: string): User {\n  return { firstName, lastName };\n}\n\nexport function yellFirstName(firstName: FirstName) {\n  console.log(firstName.toUpperCase());\n}\n```\n\n```js\n// @flow\n// usage.js\n\nimport { createUser, yellFirstName } from \"./module\";\n\nyellFirstName(\"Mathieu\"); // ⚠️ Erreur: \"string. Ce type est incompatible avec le type de paramètre attendu FirstName\"\n\nconst user = createUser(\"Acthernoene\", \"Mathieu\");\nyellFirstName(user.firstName); // Pas d'erreur\n```\n\nOn voit ici qu'il n'est en fait possible d'utiliser le type `FirstName` qu'après son assignation au sein du module où celui-ci est défini. Un autre exemple: si l'on venait à rendre le type `User` opaque, alors nous ne pourrions pas accéder à `user.firstName`, la propriété étant inaccessible autrement que par une fonction qui manipulera le type `User`.\n\n```js\n// @flow\n// module.js\n\nopaque type FirstName = string;\nopaque type LastName = string;\n\nopaque type User = {\n  firstName: FirstName,\n  lastName: LastName\n};\n\nexport function createUser(firstName: string, lastName: string): User {\n  return { firstName, lastName };\n}\n\nexport function yellFirstName(firstName: FirstName) {\n  console.log(firstName.toUpperCase());\n}\n\nexport function yellUserFirstName(user: User) {\n  console.log(user.firstName.toUpperCase());\n}\n```\n\n```js\n// @flow\n// usage.js\n\nimport { createUser, yellFirstName, yellUserFirstName } from \"./module\";\n\nconst user = createUser(\"Acthernoene\", \"Mathieu\");\nyellFirstName(user.firstName); // ⚠️ Erreur: \"Propriété `firstName`. La propriété n'est pas accessible sur le type User\"\nyellUserFirstName(user); // Pas d'erreur\n```\n\n## Tu n'aurais pas un exemple plus concret ?\n\nBien sûr que si ! Nous pouvons utiliser les types opaques pour implémenter un type `UUID` très basique:\n\n```js\n// @flow\n// uuid.js\n\n// @flow\n\nimport uuidv4 from \"uuid/v4\"; // On installe 2 packages\nimport validator from \"validator\";\n\nexport opaque type UUID = string;\n\nexport function create(): UUID {\n  return uuidv4();\n}\n\nexport function check(uuid: UUID): boolean {\n  return validator.isUUID(uuid);\n}\n```\n\n```js\n// @flow\n// usage.js\n\nimport * as UUID from \"./uuid\";\n\nUUID.check(\"a duck\"); // ⚠️ Erreur: \"string. Ce type est incompatible avec le type de paramètre attendu UUID\"\nUUID.check(\"df7cca36-3d7a-40f4-8f06-ae03cc22f045\"); // ⚠️ Erreur: \"string. Ce type est incompatible avec le type de paramètre attendu UUID\"\n\nconst uuid = UUID.create();\nUUID.check(uuid); // Pas d'erreur\n\nuuid.toUpperCase(); // ⚠️ Erreur: \"Appel de méthode `toUpperCase`. La méthode ne peut pas être appelée sur un type UUID\"\n```\n\n# C'est tout de même assez restrictif…je voudrais ne pas devoir tout réimplémenter\n\nNe vous inquiétez pas, les développeurs à l'origine de flow ont tout prévu et pour remédier à cela il existe ce qu'on appelle le sous-typage (ou _SubTyping_ dans la langue de Shakespeare). Ainsi, nous allons dire à flow que chaque `UUID` est un `string` mais que la réciproque ce sera pas vraie pour autant.\n\nReprenons l'exemple précédent.\n\n```js\n// @flow\n\nimport uuidv4 from \"uuid/v4\";\nimport validator from \"validator\";\n\nexport opaque type UUID: string = string; // Seul cette ligne change, on y ajoute un sous-type string\n\nexport function create(): UUID {\n  return uuidv4();\n}\n\nexport function check(uuid: UUID): boolean {\n  return validator.isUUID(uuid);\n}\n```\n\n```js\n// @flow\n// usage.js\n\nimport * as UUID from \"./uuid\";\n\nconst uuid = UUID.create();\nUUID.check(uuid); // Pas d'erreur\n\nuuid.toUpperCase(); // Pas d'erreur: même si uuid est un UUID, il est utilisable comme un type string\n```\n\n## Que retenir de tout ça ?\n\nComme on a pu le voir, les types opaques élèvent clairement le niveau du type-game dans le milieu du JavaScript. Forcément utiles pour imposer l'utilisation de fonctions pour créer / manipuler certaines données, ils s'avéreront assez vite indispensables pour structurer davantage votre JS et améliorer sa maintenabilité.\n\nJe vous encourage d'ailleurs à vous en servir quasiment partout (ça sera assez chiant au début, mais vous me remercierez plus tard) !\n\nLa bise, et rendez-vous pour une troisième partie 😘\n","__filename":"fr/articles/js/flow/advanced-part-2.md","__url":"/fr/articles/js/flow/advanced-part-2/","__resourceUrl":"/fr/articles/js/flow/advanced-part-2/index.html","__dataUrl":"/fr/articles/js/flow/advanced-part-2/index.html.e402a3436b617a7c3aaf1acbaef8f668.json"}