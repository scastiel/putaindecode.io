{"head":{"layout":"Post","comments":true,"date":"2016-04-12","title":"Angular 1.5 : un pas de plus vers les web-components","tags":["javascript","angular","web-component"],"authors":["Freezystem"],"description":"Ce post a été écrit à la lumière du changelog d'Angular 1.5.0 rc1.\\\\ Toutes information est succeptible d'évoluer au cours des publications…"},"body":"<p>Ce post a été écrit à la lumière du <a href=\"https://github.com/angular/angular.js/blob/master/CHANGELOG.md#150-rc1-quantum-fermentation-2016-01-15\">changelog d'Angular 1.5.0\nrc1</a>.<br>\nToutes information est succeptible d'évoluer au cours des publications de nouvelles\nversions du framework.</p>\n<h2 id=\"le-petit-nouveau--component\"><a href=\"#le-petit-nouveau--component\" class=\"phenomic-HeadingAnchor\">#</a>Le petit nouveau : <code>.component()</code></h2>\n<p>Avec l'arrivée imminente de la version 2, Angular commence lentement à préparer\nla transition et apporte de nombreux changements à la v1 pour tenter de combler\nl'écart entre les deux et rendre les changements moins pénibles.</p>\n<p>On voit donc progressivement apparaitre de nouvelles fonctionnalités comme :</p>\n<ul>\n<li><del>un <a href=\"https://angular.github.io/router/\">nouveau router</a> ?</del></li>\n<li>la possibilité d'<a href=\"https://docs.angularjs.org/api/ngResource/service/$resource#cancelling-requests\">annuler une\nresource</a></li>\n<li>les transclusions multiples</li>\n<li>la compilation paresseuse des transclusions</li>\n</ul>\n<p>Mais le point qui nous intéresse particulièrement ici n'est autre que le nouveau\n<em>helper</em> permettant la déclaration de similis <a href=\"https://fr.wikipedia.org/wiki/Composants_web\">composants\nweb</a>, aka web-components.</p>\n<p>Les habitués connaissaient déjà\n<a href=\"https://docs.angularjs.org/api/ng/service/$compile\"><code>angular.directive()</code></a>, un\n<em>helper</em> permettant la déclaration de composants réutilisables.\n<code>angular.directive()</code> s'est donc enrichi au cours des années en faisant un atout\nincontournable du framework de par sa flexibilité et sa simplicité.</p>\n<p>Mais toutes ces possibilités de déclaration n'étaient plus vraiment en phase\navec les spécifications du W3C, <code>angular.component()</code> se présente donc un retour\naux sources.</p>\n<h2 id=\"de-directive-à-component\"><a href=\"#de-directive-%C3%A0-component\" class=\"phenomic-HeadingAnchor\">#</a>De <code>.directive()</code> à <code>.component()</code></h2>\n<p>Pour comprendre à quoi on arrive, il faut savoir de quoi on est parti. De toute\névidence vous ne pourrez pas transformer toutes vos vieilles directives en\ncomposants web, du moins, pas sans compromis.</p>\n<p>Pour rappel une directive Angular est définie par un objet JavaScript pouvant\ncomporter les attributs suivants :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> directiveObj = {\n  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">\"&#x3C;div>&#x3C;/div>\"</span>,\n  <span class=\"hljs-attr\">transclude</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">restrict</span>: <span class=\"hljs-string\">\"EA\"</span>,\n  <span class=\"hljs-attr\">scope</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">bindToController</span>: <span class=\"hljs-literal\">false</span>,\n  <span class=\"hljs-attr\">controller</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{},\n  <span class=\"hljs-attr\">controllerAs</span>: <span class=\"hljs-string\">\"stringIdentifier\"</span>\n};</code></pre>\n<h3 id=\"restriction-à-la-forme-élémentaire\"><a href=\"#restriction-%C3%A0-la-forme-%C3%A9l%C3%A9mentaire\" class=\"phenomic-HeadingAnchor\">#</a>Restriction à la forme élémentaire</h3>\n<p>Ceux qui utilisent les directives Angular de manière régulière ne sont pas sans\nsavoir qu'il est possible de les instancier de 4 manières différentes dans son\nHTML en modifiant l'attribut <code>restrict</code> :</p>\n<ul>\n<li>comme un élément avec <code>restrict : 'E'</code></li>\n<li>comme un attribut avec <code>restrict : 'A'</code></li>\n<li>comme une classe avec <code>restrict : 'C'</code> (déconseillé)</li>\n<li>comme un commentaire avec <code>restrict : 'M'</code> (fortement déconseillé)</li>\n</ul>\n<p>On peut aussi autoriser l'utilisation mixe en combinant les lettres : <code>restrict : 'EAC'</code></p>\n<p><code>restrict</code> n'est donc plus configurable et est restreint <em>(sans mauvais jeu de\nmot)</em> à la forme <code>'E'</code> en faisant un composant de façon claire.</p>\n<h3 id=\"isolement-du-scope\"><a href=\"#isolement-du-scope\" class=\"phenomic-HeadingAnchor\">#</a>Isolement du scope</h3>\n<p>Contrairement à <code>.directive()</code>, <code>.component()</code> force l'isolement du scope, ainsi\non colle à la specification : le composant web est agnostique du contexte.</p>\n<p>l'attribut <code>scope</code> est donc forcé à <code>{}</code> et n'est plus configurable.</p>\n<h3 id=\"passage-de-paramètres-via-bindings\"><a href=\"#passage-de-param%C3%A8tres-via-bindings\" class=\"phenomic-HeadingAnchor\">#</a>Passage de paramètres via <code>bindings</code></h3>\n<p>La propriété <code>scope</code> n'étant plus disponible <code>component</code>. Il faut à présent\nutiliser la propriété <code>bindings</code>. La syntaxe de celle-ci est équivalent à celle\nde la propriété <code>scope</code>. Mais les éléments passés sont automatiquement attachés\nà l'instance du contrôleur lié au <code>component</code>.</p>\n<p>Notons, que s'il reste possible d'utiliser la syntaxe <code>=</code> (two-way data\nbinding), celle-ci est déconseillée au profit de la syntaxe <code>&#x3C;</code> (one-way data\nbinding).</p>\n<h3 id=\"utilisation-forcée-de-controlleras\"><a href=\"#utilisation-forc%C3%A9e-de-controlleras\" class=\"phenomic-HeadingAnchor\">#</a>Utilisation <em>forcée</em> de <code>controllerAs</code></h3>\n<p>Déjà présenté comme une <em><a href=\"https://toddmotto.com/digging-into-angulars-controller-as-syntax/\">best\npractice</a></em>,\n<code>controllerAs</code> fait son chemin de manière évidente jusqu'au nouveau <em>helper</em>\n<code>.component()</code> son utilisation va de pair avec celle de <code>bindings</code>.</p>\n<p>L'attribut, qui prend une chaine de caractères pour valeur, est à présent\nfacultatif. S'il est omit le controller est automatiquement aliassé par l'objet\n<code>$ctrl</code>.</p>\n<h2 id=\"exemple-de-migration\"><a href=\"#exemple-de-migration\" class=\"phenomic-HeadingAnchor\">#</a>Exemple de migration</h2>\n<p>Prenons l'exemple d'une directive simple et transformons la en composant Angular\npour mettre en évidence l'ensemble des changements :</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">hello-world</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"World\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">hello-world</span>></span></code></pre>\n<p>La syntaxe <em>directive</em> :</p>\n<pre><code class=\"hljs language-js\">angular.directive(<span class=\"hljs-string\">\"helloWorld\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">helloWorld</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">return</span> {\n    <span class=\"hljs-attr\">restrict</span>: <span class=\"hljs-string\">\"E\"</span>,\n    <span class=\"hljs-attr\">scope</span>: {},\n    <span class=\"hljs-attr\">bindToController</span>: {\n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"@\"</span>\n    },\n    <span class=\"hljs-attr\">controller</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">helloWorldCtrl</span>(<span class=\"hljs-params\"></span>) </span>{\n      <span class=\"hljs-keyword\">this</span>.logName = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n        <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.name);\n      };\n    },\n    <span class=\"hljs-attr\">controllerAs</span>: <span class=\"hljs-string\">\"hw\"</span>,\n    <span class=\"hljs-attr\">template</span>:\n      <span class=\"hljs-string\">'&#x3C;div>&#x3C;span ng-click=\"hw.logName()\">Hello {{hw.name}}!&#x3C;/span>&#x3C;/div>'</span>\n  };\n});</code></pre>\n<p>La syntaxe <em>component</em> :</p>\n<pre><code class=\"hljs language-js\">angular.component(<span class=\"hljs-string\">\"helloWorld\"</span>, {\n  <span class=\"hljs-attr\">bindings</span>: {\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">\"@\"</span>\n  },\n  <span class=\"hljs-attr\">controller</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">helloWorldCtrl</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-keyword\">this</span>.logName = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>.name);\n    };\n  },\n  <span class=\"hljs-attr\">template</span>:\n    <span class=\"hljs-string\">'&#x3C;div>&#x3C;span ng-click=\"$ctrl.logName()\">Hi {{$ctrl.name}}!&#x3C;/span>&#x3C;/div>'</span>\n});</code></pre>\n<p>Les changements sont légers mais permettent une lecture améliorée des attributs.\nLe composant est donc une version simplifiée de la directive, plus en phase avec\nla logique d'Angular 2.</p>\n<p>Ce nouveau <em>helper</em> permet donc l'introduction progressive des <em>web-components</em>\nau sein d'Angular en vue de leur intégration et utilisation active dans la\nversion 2.</p>\n","rawBody":"\nCe post a été écrit à la lumière du [changelog d'Angular 1.5.0\nrc1](https://github.com/angular/angular.js/blob/master/CHANGELOG.md#150-rc1-quantum-fermentation-2016-01-15).\\\nToutes information est succeptible d'évoluer au cours des publications de nouvelles\nversions du framework.\n\n## Le petit nouveau : `.component()`\n\nAvec l'arrivée imminente de la version 2, Angular commence lentement à préparer\nla transition et apporte de nombreux changements à la v1 pour tenter de combler\nl'écart entre les deux et rendre les changements moins pénibles.\n\nOn voit donc progressivement apparaitre de nouvelles fonctionnalités comme :\n\n* ~~un [nouveau router](https://angular.github.io/router/) ?~~\n* la possibilité d'[annuler une\n  resource](https://docs.angularjs.org/api/ngResource/service/$resource#cancelling-requests)\n* les transclusions multiples\n* la compilation paresseuse des transclusions\n\nMais le point qui nous intéresse particulièrement ici n'est autre que le nouveau\n_helper_ permettant la déclaration de similis [composants\nweb](https://fr.wikipedia.org/wiki/Composants_web), aka web-components.\n\nLes habitués connaissaient déjà\n[`angular.directive()`](https://docs.angularjs.org/api/ng/service/$compile), un\n_helper_ permettant la déclaration de composants réutilisables.\n`angular.directive()` s'est donc enrichi au cours des années en faisant un atout\nincontournable du framework de par sa flexibilité et sa simplicité.\n\nMais toutes ces possibilités de déclaration n'étaient plus vraiment en phase\navec les spécifications du W3C, `angular.component()` se présente donc un retour\naux sources.\n\n## De `.directive()` à `.component()`\n\nPour comprendre à quoi on arrive, il faut savoir de quoi on est parti. De toute\névidence vous ne pourrez pas transformer toutes vos vieilles directives en\ncomposants web, du moins, pas sans compromis.\n\nPour rappel une directive Angular est définie par un objet JavaScript pouvant\ncomporter les attributs suivants :\n\n```js\nvar directiveObj = {\n  template: \"<div></div>\",\n  transclude: false,\n  restrict: \"EA\",\n  scope: false,\n  bindToController: false,\n  controller: function() {},\n  controllerAs: \"stringIdentifier\"\n};\n```\n\n### Restriction à la forme élémentaire\n\nCeux qui utilisent les directives Angular de manière régulière ne sont pas sans\nsavoir qu'il est possible de les instancier de 4 manières différentes dans son\nHTML en modifiant l'attribut `restrict` :\n\n* comme un élément avec `restrict : 'E'`\n* comme un attribut avec `restrict : 'A'`\n* comme une classe avec `restrict : 'C'` (déconseillé)\n* comme un commentaire avec `restrict : 'M'` (fortement déconseillé)\n\nOn peut aussi autoriser l'utilisation mixe en combinant les lettres : `restrict\n: 'EAC'`\n\n`restrict` n'est donc plus configurable et est restreint _(sans mauvais jeu de\nmot)_ à la forme `'E'` en faisant un composant de façon claire.\n\n### Isolement du scope\n\nContrairement à `.directive()`, `.component()` force l'isolement du scope, ainsi\non colle à la specification : le composant web est agnostique du contexte.\n\nl'attribut `scope` est donc forcé à `{}` et n'est plus configurable.\n\n### Passage de paramètres via `bindings`\n\nLa propriété `scope` n'étant plus disponible `component`. Il faut à présent\nutiliser la propriété `bindings`. La syntaxe de celle-ci est équivalent à celle\nde la propriété `scope`. Mais les éléments passés sont automatiquement attachés\nà l'instance du contrôleur lié au `component`.\n\nNotons, que s'il reste possible d'utiliser la syntaxe `=` (two-way data\nbinding), celle-ci est déconseillée au profit de la syntaxe `<` (one-way data\nbinding).\n\n### Utilisation _forcée_ de `controllerAs`\n\nDéjà présenté comme une *[best\npractice](https://toddmotto.com/digging-into-angulars-controller-as-syntax/)*,\n`controllerAs` fait son chemin de manière évidente jusqu'au nouveau _helper_\n`.component()` son utilisation va de pair avec celle de `bindings`.\n\nL'attribut, qui prend une chaine de caractères pour valeur, est à présent\nfacultatif. S'il est omit le controller est automatiquement aliassé par l'objet\n`$ctrl`.\n\n## Exemple de migration\n\nPrenons l'exemple d'une directive simple et transformons la en composant Angular\npour mettre en évidence l'ensemble des changements :\n\n```html\n<hello-world name=\"World\"></hello-world>\n```\n\nLa syntaxe _directive_ :\n\n```js\nangular.directive(\"helloWorld\", function helloWorld() {\n  return {\n    restrict: \"E\",\n    scope: {},\n    bindToController: {\n      name: \"@\"\n    },\n    controller: function helloWorldCtrl() {\n      this.logName = function() {\n        console.log(this.name);\n      };\n    },\n    controllerAs: \"hw\",\n    template:\n      '<div><span ng-click=\"hw.logName()\">Hello {{hw.name}}!</span></div>'\n  };\n});\n```\n\nLa syntaxe _component_ :\n\n```js\nangular.component(\"helloWorld\", {\n  bindings: {\n    name: \"@\"\n  },\n  controller: function helloWorldCtrl() {\n    this.logName = function() {\n      console.log(this.name);\n    };\n  },\n  template:\n    '<div><span ng-click=\"$ctrl.logName()\">Hi {{$ctrl.name}}!</span></div>'\n});\n```\n\nLes changements sont légers mais permettent une lecture améliorée des attributs.\nLe composant est donc une version simplifiée de la directive, plus en phase avec\nla logique d'Angular 2.\n\nCe nouveau _helper_ permet donc l'introduction progressive des _web-components_\nau sein d'Angular en vue de leur intégration et utilisation active dans la\nversion 2.\n","__filename":"fr/articles/js/angular/components/index.md","__url":"/fr/articles/js/angular/components/","__resourceUrl":"/fr/articles/js/angular/components/index.html","__dataUrl":"/fr/articles/js/angular/components/index.html.d7127fde42f55169fc1017d235c5280d.json"}