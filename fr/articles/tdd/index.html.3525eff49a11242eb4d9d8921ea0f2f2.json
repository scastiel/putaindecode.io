{"head":{"layout":"Post","comments":true,"date":"2017-10-31","title":"Se lancer dans le TDD","tags":["tdd","bdd","ci"],"authors":["Freezystem"],"description":"Introduction Tout commence en octobre 1999 lorsque Kent Beck présente une nouvelle méthode de programmation agile : l'eXtreme Programmming…"},"body":"<h2 id=\"introduction\"><a href=\"#introduction\" class=\"phenomic-HeadingAnchor\">#</a>Introduction</h2>\n<p>Tout commence en octobre 1999 lorsque <a href=\"https://fr.wikipedia.org/wiki/Kent_Beck\">Kent Beck</a>\nprésente une nouvelle méthode de programmation agile : l'eXtreme Programmming abrégé <em>XP</em>.<br>\nl'<em>XP</em> définit des pratiques de développement optimisées qui améliorent la production et\nla robustesse du code.<br>\nParmi les principes les plus connus de sa méthode on pourra citer <strong>l'intégration continue</strong>\naussi appelée <em>CI</em> pour <em>Continuous Integration</em> et <strong>la programmation en binôme</strong>\nou <em>pair programming</em> en anglais.</p>\n<p>L'aspect qui nous intéresse ici est un autre pilier de la méthode qui consiste à piloter\nle développement par les tests alias <em>TDD</em>.</p>\n<p>Le TDD est une pratique controversée car coûteuse à mettre en place.\nPopularisée par les développeurs elle peine à émerger.</p>\n<p>Avec la multiplication des environnements d'execution, la complexité des applications web\net l'essor des projets Open-source, les développeurs se heurtent à des problèmes de\ncompatibilités croisées et d'inconsistances.<br>\nAujourd’hui les standards sont de plus en plus permissifs et favorisent\nainsi les comportements à risque. La plupart du temps, les systèmes sont capables de\ncorriger vos erreurs, des fois sans même vous en avertir.</p>\n<p>Dans ce contexte :</p>\n<ul>\n<li>Comment écrire un code multi-plateforme fonctionnel ?</li>\n<li>Comment être sûr que les ajouts ne cassent pas le code plus ancien ?</li>\n<li>Comment être sûr que le code se comporte comme voulu ?</li>\n</ul>\n<p>Commencer par vous imposer des pratiques de développement rigoureuses est impératif\nmais les tests seront un complément indispensable à la qualité de votre code.</p>\n<p>Heureusement, le TDD apporte alors une réponse élégante à l'ensemble de ces problématiques.</p>\n<h2 id=\"tdd-vous-avez-dit-tdd-\"><a href=\"#tdd-vous-avez-dit-tdd-\" class=\"phenomic-HeadingAnchor\">#</a>TDD, vous avez dit TDD ?</h2>\n<p>Le Test Driven Development <em>(Développement Dirigé par les Tests)</em>,\nest une technique de développement qui impose l’écriture de tests\navant même l’écriture de la première ligne de code.</p>\n<p>Dans la théorie, la méthode requiert l’intervention d’au moins\ndeux intervenants différents, une personne écrit les tests, l’autre\nle code testé. Cela permet d’éviter les problèmes liés à la subjectivité.</p>\n<p>Dans la pratique les choses sont plus compliquées,\nparfois on développe seul ou on écrit soi-même les tests qui\ngarantissent l’intégrité d'une nouvelle fonctionnalité dans un projet collaboratif.</p>\n<blockquote>\n<p>Quoi qu’il arrive, un test peu efficace vaudra toujours mieux que pas de test du tout.\nLe but étant de prendre l’habitude d’en écrire et d’être objectif dans leur rédaction.</p>\n</blockquote>\n<p>Le TDD tend à se démocratiser et requiert l’effort de chacun pour devenir un standard.\nTout développeur soucieux de son environnement et de son héritage doit se poser sérieusement\nla question.<br>\nLes frameworks de tests, les guides et les documentations sur le sujet fleurissent,\nvous pouvez donc vous lancer sans crainte.</p>\n<p>On peut découper le TDD en 5 étapes distinctes :</p>\n<ol>\n<li>Écrire un test,</li>\n<li>Vérifier qu’il échoue,</li>\n<li>Écrire le code <strong>suffisant</strong> pour que le test passe,</li>\n<li>Vérifier que le test passe,</li>\n<li>Optimiser le code et vérifier qu’il n’y ait pas de régression.</li>\n</ol>\n<p>Pour simplifier cette logique on peut regrouper ces cinq étapes en trois grandes idées :</p>\n<ul>\n<li><strong>Tester d’abord</strong>, qui correspond aux deux premières étapes.</li>\n<li><strong>Rendre fonctionnel</strong>, qui englobe les points 3 et 4.</li>\n<li><strong>Rendre meilleur</strong>, qui n’est autre que l’étape 5.</li>\n</ul>\n<p>Bill Wake définit ainsi la méthode <a href=\"http://xp123.com/articles/3a-arrange-act-assert/\">3A</a>,\npour Arrange, Act, Assert <em>(Arranger, Agir, Affirmer)</em>.<br>\nIl insiste sur le fait que la méthode ne définit pas un ordre immuable,\nl’<em>affirmation</em> peut ainsi venir avant l’<em>action</em>, etc...</p>\n<ul>\n<li><strong>Arranger</strong> : Phase de préparation de l’environnement de test dans laquelle\non déclare les variables et les fonctions.</li>\n<li><strong>Agir</strong> : Phase qui met à l’épreuve notre environnement en lui faisant subir des mutations.</li>\n<li><strong>Affirmer</strong> : On formule des attentes à propos de l'environnement\n(variables, fonctions, paramètres).</li>\n</ul>\n<h2 id=\"tdd--concepts-de-base\"><a href=\"#tdd--concepts-de-base\" class=\"phenomic-HeadingAnchor\">#</a>TDD : concepts de base</h2>\n<p>Pour la série de tests suivante on utilisera EcmaScript 6 et la méthode\n<a href=\"https://developer.mozilla.org/fr/docs/Web/API/Console/assert\"><code>.assert()</code></a>\nde la console navigateur: Vous pourrez ainsi reproduire ces tests vous-même.</p>\n<p>Objectif : Ecrire une fonction <code>countWords()</code> qui compte les mots d'une phrase.</p>\n<p><strong>ITERATION 1</strong> : écriture et échec du test initial</p>\n<p>On écrit tout d'abord une affirmation de base.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">''</span>) === <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">'test 0: le texte ne contient aucun mot'</span>);</code></pre>\n<blockquote>\n<p><code>Uncaught ReferenceError: countWords is not defined</code></p>\n</blockquote>\n<p>Après exécution la console rejette le test.\nOn doit d'abord définir <code>countWords()</code>.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> countWords = <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {};\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">''</span>) === <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">'test 0: le texte ne contient aucun mot'</span>);</code></pre>\n<blockquote>\n<p><code>Assertion failed: test 0: le texte ne contient aucun mot</code></p>\n</blockquote>\n<p><code>countWords()</code> est définie et le test échoue mais l'erreur a changé.<br>\nIl faut à présent définir la logique du cœur de notre fonction.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> countWords = <span class=\"hljs-function\"><span class=\"hljs-params\">text</span> =></span> text || <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">''</span>) === <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">'test 0: le texte ne contient aucun mot'</span>);</code></pre>\n<blockquote>\n<p><code>undefined</code></p>\n</blockquote>\n<p>La console ne renvoie rien, le test est donc passé.  </p>\n<blockquote>\n<p><code>countWords()</code> étant très simple nous omettrons les phases d'optimisation.\nOn peut aussi considérer les itérations suivantes comme des optimisations.</p>\n</blockquote>\n<p><strong>ITERATION 2</strong> : test pour les phrases d'un seul mot</p>\n<p>Très bien. Essayons à présent une phrase d'un seul mot.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> countWords = <span class=\"hljs-function\"><span class=\"hljs-params\">text</span> =></span> text || <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">''</span>) === <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">'test 0: le texte ne contient aucun mot'</span>);\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">'nope'</span>) === <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'test 1: le texte contient 1 mot'</span>);</code></pre>\n<blockquote>\n<p><code>Assertion failed: test 1: le texte contient 1 mot</code></p>\n</blockquote>\n<p><code>countWords()</code> ne compte pas correctement, ajoutons le code suffisant pour passer le test.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> countWords = <span class=\"hljs-function\"><span class=\"hljs-params\">text</span> =></span> text ? text.split(<span class=\"hljs-string\">' '</span>).length : <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">''</span>) === <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">'test 0: le texte ne contient aucun mot'</span>);\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">'nope'</span>) === <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'test 1: le texte contient 1 mot'</span>);</code></pre>\n<blockquote>\n<p><code>undefined</code></p>\n</blockquote>\n<p>Le test est passé, ajoutons un autre cas standard.</p>\n<p><strong>ITERATION 3</strong> : test pour les phrases de plusieurs mots</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> countWords = <span class=\"hljs-function\"><span class=\"hljs-params\">text</span> =></span> text ? text.split(<span class=\"hljs-string\">' '</span>).length : <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">''</span>) === <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">'test 0: le texte ne contient aucun mot'</span>);\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">'nope'</span>) === <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'test 1: le texte contient 1 mot'</span>);\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">'tdd is so fun'</span>) === <span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">'test 2: le texte contient 4 mots'</span>);</code></pre>\n<blockquote>\n<p><code>undefined</code></p>\n</blockquote>\n<p>Le nouveau test passe sans modification, on peut continuer.</p>\n<p><strong>ITERATION 4</strong> : test pour les phrases contenant des espaces au début et à la fin</p>\n<p>Vérifions à présent la robustesse de la fonction.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> countWords = <span class=\"hljs-function\"><span class=\"hljs-params\">text</span> =></span> text ? text.split(<span class=\"hljs-string\">' '</span>).length : <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">''</span>) === <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">'test 0: le texte ne contient aucun mot'</span>);\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">'nope'</span>) === <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'test 1: le texte contient 1 mot'</span>);\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">'tdd is so fun'</span>) === <span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">'test 2: le texte contient 4 mots'</span>);\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">' so is skateboarding '</span>) === <span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">'test 3: le texte contient 3 mots'</span>);</code></pre>\n<blockquote>\n<p><code>Assertion failed: test 3: le texte contient 3 mots</code></p>\n</blockquote>\n<p>Aïe… notre fonction n'est pas assez solide. Corrigeons-la pour capter ce nouveau cas en supprimant les\nespaces inutiles avant et après le texte.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> countWords = <span class=\"hljs-function\"><span class=\"hljs-params\">text</span> =></span> text ? text.trim().split(<span class=\"hljs-string\">' '</span>).length : <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">''</span>) === <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">'test 0: le texte ne contient aucun mot'</span>);\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">'nope'</span>) === <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'test 1: le texte contient 1 mot'</span>);\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">'tdd is so fun'</span>) === <span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">'test 2: le texte contient 4 mots'</span>);\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">' so is skateboarding '</span>) === <span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">'test 3: le texte contient 3 mots'</span>);</code></pre>\n<blockquote>\n<p><code>undefined</code></p>\n</blockquote>\n<p>Parfait, La fonction est améliorée ! Ajoutons quand même un dernier test pour être sur.</p>\n<p><strong>ITERATION 5</strong> : test pour les phrases contenant un nombre inégal d'espaces entre les mots</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> countWords = <span class=\"hljs-function\"><span class=\"hljs-params\">text</span> =></span> text ? text.trim().split(<span class=\"hljs-string\">' '</span>).length : <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">''</span>) === <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">'test 0: le texte ne contient aucun mot'</span>);\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">'nope'</span>) === <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'test 1: le texte contient 1 mot'</span>);\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">'tdd is so fun'</span>) === <span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">'test 2: le texte contient 4 mots'</span>);\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">' so is skateboarding '</span>) === <span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">'test 3: le texte contient 3 mots'</span>);\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">`  I'm 28, I love $#@! and    multi-spaces  `</span>) === <span class=\"hljs-number\">7</span>, <span class=\"hljs-string\">'test 4: le texte contient 7 mots'</span>);</code></pre>\n<blockquote>\n<p><code>Assertion failed: test 4: le texte contient 7 mots</code></p>\n</blockquote>\n<p>Et mince… Encore un cas particulier, modifions l'algorithme en conséquence.\nOn doit ici retirer les espaces inutiles entre les mots.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> countWords = <span class=\"hljs-function\"><span class=\"hljs-params\">text</span> =></span> text ? text.trim().replace(<span class=\"hljs-regexp\">/\\s+/g</span>, <span class=\"hljs-string\">' '</span>).split(<span class=\"hljs-string\">' '</span>).length : <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">''</span>) === <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">'test 0: le texte ne contient aucun mot'</span>);\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">'nope'</span>) === <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">'test 1: le texte contient 1 mot'</span>);\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">'tdd is so fun'</span>) === <span class=\"hljs-number\">4</span>, <span class=\"hljs-string\">'test 2: le texte contient 4 mots'</span>);\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">' so is skateboarding '</span>) === <span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">'test 3: le texte contient 3 mots'</span>);\n<span class=\"hljs-built_in\">console</span>.assert(countWords(<span class=\"hljs-string\">`  I'm 28, I love $#@! and    multi-spaces  `</span>) === <span class=\"hljs-number\">7</span>, <span class=\"hljs-string\">'test 4: le texte contient 7 mots'</span>);</code></pre>\n<blockquote>\n<p><code>undefined</code></p>\n</blockquote>\n<p>Le test final est passé sans que les précédents n'échouent.</p>\n<p>On notera que l'écriture de tests est un processus itératif.<br>\nLa phase d'optimisation implique l'écriture d'un nouveau test qui échoue\net relance donc une nouvelle itération.</p>\n<p>Evidemment <code>countWords()</code> est très largement sous-optimisée et ne couvre pas tous les cas spéciaux.\nOn aurait pu ajouter une vérification sur le paramètre <code>text</code> et compter avec une expression régulière comme ceci :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> countWords = <span class=\"hljs-function\"><span class=\"hljs-params\">text</span> =></span> <span class=\"hljs-keyword\">typeof</span> text === <span class=\"hljs-string\">'string'</span> &#x26;&#x26; text.trim() ? text.match(<span class=\"hljs-regexp\">/\\S+\\s{0,1}/g</span>).length : <span class=\"hljs-number\">0</span>;</code></pre>\n<p>L'idée ici est que coder est un processus incrémental et que chaque nouveau cycle doit être initié\npar un besoin spécifique défini par un test dédié.  </p>\n<p>L'écriture des tests est simple : on décompose notre script en une suite d'affirmations\ncorrespondant chacune à une fonctionnalité précise de notre algorithme.</p>\n<p>Grâce à ce processus on évite :</p>\n<ul>\n<li><strong>les régressions</strong>: la suite valide de tests est la garantie que le code reste\nfonctionnel malgré les évolutions de l'algorithme.</li>\n<li><strong>le code mort</strong>: chaque morceau de code écrit est testé et a son utilité.</li>\n<li><strong>le code non documenté</strong>: chaque comportement est décrit de manière fonctionnelle.</li>\n</ul>\n<h2 id=\"bdd--des-tests-pour-tous\"><a href=\"#bdd--des-tests-pour-tous\" class=\"phenomic-HeadingAnchor\">#</a>BDD : Des tests pour tous</h2>\n<p>Une variante plus agnostique de la logique du développeur existe et permet à des\nintervenants externes de faire partie intégrante du processus créatif.</p>\n<p>le BDD, Behaviour Driven Development (Développement Dirigé par le Comportement),\npermet de définir de manière compréhensible pour tous les intervenants les\nspécifications d’une fonctionnalité. Cela permet aussi aux développeurs de comprendre\nle comportement général sans évoquer les détails techniques.\nLa discussion est donc facilitée entre les différents acteurs.  </p>\n<p>Pour illustrer cette variante adaptons l'exemple précédent :</p>\n<blockquote>\n<p>Note : Pour exécuter ce type de code vous aurez besoin d'un <em>test-runner</em> comme\n<a href=\"https://facebook.github.io/jest/\">Jest</a>, <a href=\"https://mochajs.org\">Mocha</a> ou <a href=\"https://karma-runner.github.io\">Karma</a>.</p>\n</blockquote>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> countWords = <span class=\"hljs-function\"><span class=\"hljs-params\">text</span> =></span> text ? text.trim().replace(<span class=\"hljs-regexp\">/\\s+/g</span>, <span class=\"hljs-string\">' '</span>).split(<span class=\"hljs-string\">' '</span>).length : <span class=\"hljs-number\">0</span>;\n\ndescribe(<span class=\"hljs-string\">'countWords()'</span>, () => {\n  it(<span class=\"hljs-string\">'doit traiter un texte vide'</span>, () => {\n    expect(countWords(<span class=\"hljs-string\">''</span>)).toBe(<span class=\"hljs-number\">0</span>);\n  });\n\n  it(<span class=\"hljs-string\">'doit traiter un texte d\\'un seul mot'</span>, () => {\n    expect(countWords(<span class=\"hljs-string\">'nope'</span>)).toBe(<span class=\"hljs-number\">1</span>);\n  });\n\n  it(<span class=\"hljs-string\">'doit traiter un texte de n mots'</span>, () => {\n    expect(countWords(<span class=\"hljs-string\">'tdd is so fun'</span>)).toBe(<span class=\"hljs-number\">4</span>);\n  });\n\n  it(<span class=\"hljs-string\">'doit traiter un texte avec des espaces aux extrémités'</span>, () => {\n    expect(countWords(<span class=\"hljs-string\">' so is skateboarding '</span>)).toBe(<span class=\"hljs-number\">3</span>);\n  });\n\n  it(<span class=\"hljs-string\">'doit traiter un texte avec des espaces inégaux entre les mots'</span>, () => {\n    expect(countWords(<span class=\"hljs-string\">`  I'm 28, I love $#@! and    multi-spaces  `</span>)).toBe(<span class=\"hljs-number\">7</span>);\n  });\n});</code></pre>\n<p>Voici le résultat du run :</p>\n<p><img src=\"./testrunner.png\" alt=\"résultat du run de tests\"></p>\n<p>La relecture est simplifiée pour tous les participants non techniques.</p>\n<h2 id=\"conclusion\"><a href=\"#conclusion\" class=\"phenomic-HeadingAnchor\">#</a>Conclusion</h2>\n<p>Le TDD est destiné à être incorporé à un processus d'<a href=\"http://putaindecode.io/fr/articles/ci/\">Intégration Continue</a>\npour s'assurer du bon fonctionnement de l'application sur tous les environnements\nde production après chaque nouveau <code>commit</code>.  </p>\n<p>J'espère vous avez apprécié la démo et que ça vous a donné envie de\ntester le TDD pour apporter équilibre et harmonie à votre code.  </p>\n<p>Dans tous les cas, je peux vous certifier que les autres codeurs vous\nen seront reconnaissants, croyez-moi.</p>\n","rawBody":"\n## Introduction\n\nTout commence en octobre 1999 lorsque [Kent Beck](https://fr.wikipedia.org/wiki/Kent_Beck)\nprésente une nouvelle méthode de programmation agile : l'eXtreme Programmming abrégé _XP_.  \nl'_XP_ définit des pratiques de développement optimisées qui améliorent la production et\nla robustesse du code.  \nParmi les principes les plus connus de sa méthode on pourra citer **l'intégration continue**\naussi appelée _CI_ pour _Continuous Integration_ et **la programmation en binôme**\nou _pair programming_ en anglais.\n\nL'aspect qui nous intéresse ici est un autre pilier de la méthode qui consiste à piloter\nle développement par les tests alias _TDD_.\n\nLe TDD est une pratique controversée car coûteuse à mettre en place.\nPopularisée par les développeurs elle peine à émerger.\n\nAvec la multiplication des environnements d'execution, la complexité des applications web\net l'essor des projets Open-source, les développeurs se heurtent à des problèmes de\ncompatibilités croisées et d'inconsistances.  \nAujourd’hui les standards sont de plus en plus permissifs et favorisent\nainsi les comportements à risque. La plupart du temps, les systèmes sont capables de\ncorriger vos erreurs, des fois sans même vous en avertir.\n\nDans ce contexte :\n- Comment écrire un code multi-plateforme fonctionnel ?\n- Comment être sûr que les ajouts ne cassent pas le code plus ancien ?\n- Comment être sûr que le code se comporte comme voulu ?\n\nCommencer par vous imposer des pratiques de développement rigoureuses est impératif\nmais les tests seront un complément indispensable à la qualité de votre code.\n\nHeureusement, le TDD apporte alors une réponse élégante à l'ensemble de ces problématiques.\n\n## TDD, vous avez dit TDD ?\n\nLe Test Driven Development _(Développement Dirigé par les Tests)_,\nest une technique de développement qui impose l’écriture de tests\navant même l’écriture de la première ligne de code.\n\nDans la théorie, la méthode requiert l’intervention d’au moins\ndeux intervenants différents, une personne écrit les tests, l’autre\nle code testé. Cela permet d’éviter les problèmes liés à la subjectivité.\n\nDans la pratique les choses sont plus compliquées,\nparfois on développe seul ou on écrit soi-même les tests qui\ngarantissent l’intégrité d'une nouvelle fonctionnalité dans un projet collaboratif.\n\n> Quoi qu’il arrive, un test peu efficace vaudra toujours mieux que pas de test du tout.\n> Le but étant de prendre l’habitude d’en écrire et d’être objectif dans leur rédaction.\n\nLe TDD tend à se démocratiser et requiert l’effort de chacun pour devenir un standard.\nTout développeur soucieux de son environnement et de son héritage doit se poser sérieusement\nla question.  \nLes frameworks de tests, les guides et les documentations sur le sujet fleurissent,\nvous pouvez donc vous lancer sans crainte.\n\nOn peut découper le TDD en 5 étapes distinctes :\n\n1. Écrire un test,\n2. Vérifier qu’il échoue,\n3. Écrire le code **suffisant** pour que le test passe,\n4. Vérifier que le test passe,\n5. Optimiser le code et vérifier qu’il n’y ait pas de régression.\n\nPour simplifier cette logique on peut regrouper ces cinq étapes en trois grandes idées :\n\n- **Tester d’abord**, qui correspond aux deux premières étapes.\n- **Rendre fonctionnel**, qui englobe les points 3 et 4.\n- **Rendre meilleur**, qui n’est autre que l’étape 5.\n\nBill Wake définit ainsi la méthode [3A](http://xp123.com/articles/3a-arrange-act-assert/),\npour Arrange, Act, Assert _(Arranger, Agir, Affirmer)_.  \nIl insiste sur le fait que la méthode ne définit pas un ordre immuable,\nl’_affirmation_ peut ainsi venir avant l’_action_, etc...\n\n- **Arranger** : Phase de préparation de l’environnement de test dans laquelle\non déclare les variables et les fonctions.\n- **Agir** : Phase qui met à l’épreuve notre environnement en lui faisant subir des mutations.\n- **Affirmer** : On formule des attentes à propos de l'environnement\n(variables, fonctions, paramètres).\n\n## TDD : concepts de base\n\nPour la série de tests suivante on utilisera EcmaScript 6 et la méthode\n[`.assert()`](https://developer.mozilla.org/fr/docs/Web/API/Console/assert)\nde la console navigateur: Vous pourrez ainsi reproduire ces tests vous-même.\n\nObjectif : Ecrire une fonction `countWords()` qui compte les mots d'une phrase.\n\n**ITERATION 1** : écriture et échec du test initial\n\nOn écrit tout d'abord une affirmation de base.\n```js\nconsole.assert(countWords('') === 0, 'test 0: le texte ne contient aucun mot');\n```\n> `Uncaught ReferenceError: countWords is not defined`\n\nAprès exécution la console rejette le test.\nOn doit d'abord définir `countWords()`.\n\n```js\nconst countWords = () => {};\nconsole.assert(countWords('') === 0, 'test 0: le texte ne contient aucun mot');\n```\n> `Assertion failed: test 0: le texte ne contient aucun mot`\n\n`countWords()` est définie et le test échoue mais l'erreur a changé.  \nIl faut à présent définir la logique du cœur de notre fonction.\n\n```js\nconst countWords = text => text || 0;\nconsole.assert(countWords('') === 0, 'test 0: le texte ne contient aucun mot');\n```\n> `undefined`\n\nLa console ne renvoie rien, le test est donc passé.  \n\n> `countWords()` étant très simple nous omettrons les phases d'optimisation.\n> On peut aussi considérer les itérations suivantes comme des optimisations.\n\n**ITERATION 2** : test pour les phrases d'un seul mot\n\nTrès bien. Essayons à présent une phrase d'un seul mot.\n\n```js\nconst countWords = text => text || 0;\nconsole.assert(countWords('') === 0, 'test 0: le texte ne contient aucun mot');\nconsole.assert(countWords('nope') === 1, 'test 1: le texte contient 1 mot');\n```\n> `Assertion failed: test 1: le texte contient 1 mot`\n\n`countWords()` ne compte pas correctement, ajoutons le code suffisant pour passer le test.\n\n```js\nconst countWords = text => text ? text.split(' ').length : 0;\nconsole.assert(countWords('') === 0, 'test 0: le texte ne contient aucun mot');\nconsole.assert(countWords('nope') === 1, 'test 1: le texte contient 1 mot');\n```\n> `undefined`\n\nLe test est passé, ajoutons un autre cas standard.\n\n**ITERATION 3** : test pour les phrases de plusieurs mots\n\n```js\nconst countWords = text => text ? text.split(' ').length : 0;\nconsole.assert(countWords('') === 0, 'test 0: le texte ne contient aucun mot');\nconsole.assert(countWords('nope') === 1, 'test 1: le texte contient 1 mot');\nconsole.assert(countWords('tdd is so fun') === 4, 'test 2: le texte contient 4 mots');\n```\n> `undefined`\n\nLe nouveau test passe sans modification, on peut continuer.\n\n**ITERATION 4** : test pour les phrases contenant des espaces au début et à la fin\n\nVérifions à présent la robustesse de la fonction.\n\n```js\nconst countWords = text => text ? text.split(' ').length : 0;\nconsole.assert(countWords('') === 0, 'test 0: le texte ne contient aucun mot');\nconsole.assert(countWords('nope') === 1, 'test 1: le texte contient 1 mot');\nconsole.assert(countWords('tdd is so fun') === 4, 'test 2: le texte contient 4 mots');\nconsole.assert(countWords(' so is skateboarding ') === 3, 'test 3: le texte contient 3 mots');\n```\n> `Assertion failed: test 3: le texte contient 3 mots`\n\nAïe… notre fonction n'est pas assez solide. Corrigeons-la pour capter ce nouveau cas en supprimant les\nespaces inutiles avant et après le texte.\n\n```js\nconst countWords = text => text ? text.trim().split(' ').length : 0;\nconsole.assert(countWords('') === 0, 'test 0: le texte ne contient aucun mot');\nconsole.assert(countWords('nope') === 1, 'test 1: le texte contient 1 mot');\nconsole.assert(countWords('tdd is so fun') === 4, 'test 2: le texte contient 4 mots');\nconsole.assert(countWords(' so is skateboarding ') === 3, 'test 3: le texte contient 3 mots');\n```\n> `undefined`\n\nParfait, La fonction est améliorée ! Ajoutons quand même un dernier test pour être sur.\n\n**ITERATION 5** : test pour les phrases contenant un nombre inégal d'espaces entre les mots\n\n```js\nconst countWords = text => text ? text.trim().split(' ').length : 0;\nconsole.assert(countWords('') === 0, 'test 0: le texte ne contient aucun mot');\nconsole.assert(countWords('nope') === 1, 'test 1: le texte contient 1 mot');\nconsole.assert(countWords('tdd is so fun') === 4, 'test 2: le texte contient 4 mots');\nconsole.assert(countWords(' so is skateboarding ') === 3, 'test 3: le texte contient 3 mots');\nconsole.assert(countWords(`  I'm 28, I love $#@! and    multi-spaces  `) === 7, 'test 4: le texte contient 7 mots');\n```\n> `Assertion failed: test 4: le texte contient 7 mots`\n\nEt mince… Encore un cas particulier, modifions l'algorithme en conséquence.\nOn doit ici retirer les espaces inutiles entre les mots.\n\n```js\nconst countWords = text => text ? text.trim().replace(/\\s+/g, ' ').split(' ').length : 0;\nconsole.assert(countWords('') === 0, 'test 0: le texte ne contient aucun mot');\nconsole.assert(countWords('nope') === 1, 'test 1: le texte contient 1 mot');\nconsole.assert(countWords('tdd is so fun') === 4, 'test 2: le texte contient 4 mots');\nconsole.assert(countWords(' so is skateboarding ') === 3, 'test 3: le texte contient 3 mots');\nconsole.assert(countWords(`  I'm 28, I love $#@! and    multi-spaces  `) === 7, 'test 4: le texte contient 7 mots');\n```\n> `undefined`\n\nLe test final est passé sans que les précédents n'échouent.\n\nOn notera que l'écriture de tests est un processus itératif.  \nLa phase d'optimisation implique l'écriture d'un nouveau test qui échoue\net relance donc une nouvelle itération.\n\nEvidemment `countWords()` est très largement sous-optimisée et ne couvre pas tous les cas spéciaux.\nOn aurait pu ajouter une vérification sur le paramètre `text` et compter avec une expression régulière comme ceci :\n\n```js\nconst countWords = text => typeof text === 'string' && text.trim() ? text.match(/\\S+\\s{0,1}/g).length : 0;\n```\nL'idée ici est que coder est un processus incrémental et que chaque nouveau cycle doit être initié\npar un besoin spécifique défini par un test dédié.  \n\nL'écriture des tests est simple : on décompose notre script en une suite d'affirmations\ncorrespondant chacune à une fonctionnalité précise de notre algorithme.\n\nGrâce à ce processus on évite :\n- **les régressions**: la suite valide de tests est la garantie que le code reste\nfonctionnel malgré les évolutions de l'algorithme.\n- **le code mort**: chaque morceau de code écrit est testé et a son utilité.\n- **le code non documenté**: chaque comportement est décrit de manière fonctionnelle.\n\n## BDD : Des tests pour tous\n\nUne variante plus agnostique de la logique du développeur existe et permet à des\nintervenants externes de faire partie intégrante du processus créatif.\n\nle BDD, Behaviour Driven Development (Développement Dirigé par le Comportement),\npermet de définir de manière compréhensible pour tous les intervenants les\nspécifications d’une fonctionnalité. Cela permet aussi aux développeurs de comprendre\nle comportement général sans évoquer les détails techniques.\nLa discussion est donc facilitée entre les différents acteurs.  \n\nPour illustrer cette variante adaptons l'exemple précédent :\n\n> Note : Pour exécuter ce type de code vous aurez besoin d'un _test-runner_ comme\n> [Jest](https://facebook.github.io/jest/), [Mocha](https://mochajs.org) ou [Karma](https://karma-runner.github.io).\n\n```js\nconst countWords = text => text ? text.trim().replace(/\\s+/g, ' ').split(' ').length : 0;\n\ndescribe('countWords()', () => {\n  it('doit traiter un texte vide', () => {\n    expect(countWords('')).toBe(0);\n  });\n\n  it('doit traiter un texte d\\'un seul mot', () => {\n    expect(countWords('nope')).toBe(1);\n  });\n\n  it('doit traiter un texte de n mots', () => {\n    expect(countWords('tdd is so fun')).toBe(4);\n  });\n\n  it('doit traiter un texte avec des espaces aux extrémités', () => {\n    expect(countWords(' so is skateboarding ')).toBe(3);\n  });\n\n  it('doit traiter un texte avec des espaces inégaux entre les mots', () => {\n    expect(countWords(`  I'm 28, I love $#@! and    multi-spaces  `)).toBe(7);\n  });\n});\n```\n\nVoici le résultat du run :\n\n![résultat du run de tests](./testrunner.png)\n\nLa relecture est simplifiée pour tous les participants non techniques.\n\n## Conclusion\n\nLe TDD est destiné à être incorporé à un processus d'[Intégration Continue](http://putaindecode.io/fr/articles/ci/)\npour s'assurer du bon fonctionnement de l'application sur tous les environnements\nde production après chaque nouveau `commit`.  \n\nJ'espère vous avez apprécié la démo et que ça vous a donné envie de\ntester le TDD pour apporter équilibre et harmonie à votre code.  \n\nDans tous les cas, je peux vous certifier que les autres codeurs vous\nen seront reconnaissants, croyez-moi.\n","__filename":"fr/articles/tdd/index.md","__url":"/fr/articles/tdd/","__resourceUrl":"/fr/articles/tdd/index.html","__dataUrl":"/fr/articles/tdd/index.html.3525eff49a11242eb4d9d8921ea0f2f2.json"}