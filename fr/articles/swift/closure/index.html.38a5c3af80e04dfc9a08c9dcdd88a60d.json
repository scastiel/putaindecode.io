{"head":{"layout":"Post","comments":true,"date":"2017-10-26","title":"Swift - la fonction: une closure particulière","tags":["swift","function","closure"],"authors":["leolelego"],"reviewers":["bloodyowl","MoOx"],"header":{"image":"swift.jpg","linearGradient":"0deg, rgba(249,82,51, .9), rgba(252, 136, 63, .7)"},"description":"Swift est un langage simple pour les débutants, tout en offrant de grandes possibilitées aux développeurs expérimentés. Les fonctions Swift…"},"body":"<p><strong>Swift</strong> est un langage simple pour les débutants, tout en offrant de grandes possibilitées aux développeurs expérimentés. Les <em>fonctions</em> Swift sont un bon exemple de cette façon d’avoir pensé le langage.</p>\n<h2 id=\"les-fonctions\"><a href=\"#les-fonctions\" class=\"phenomic-HeadingAnchor\">#</a>Les fonctions</h2>\n<h3 id=\"déclaration-simple\"><a href=\"#d%C3%A9claration-simple\" class=\"phenomic-HeadingAnchor\">#</a>Déclaration simple</h3>\n<p>La déclaration et l’utilisation de <em>fonctions</em> est simple. On commence avec le mot clé <code>func</code> suivi du <em>nom</em>, puis des <em>paramètres</em> entre parenthèses (a.k.a. <code>input</code>) :</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(name:String, age:UInt)</span></span>{\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello <span class=\"hljs-subst\">\\(name)</span>, you are <span class=\"hljs-subst\">\\(age)</span>\"</span>)\n}</code></pre>\n<p>L’appel se fait aussi simplement que ça : <code>sayHello(name:\"Bob\", age: 32)</code>. Le mot clé <code>_</code> permet d'enlever le label du paramètre dans l'appel si besoin :</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-comment\">// Declaration</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(name:String,<span class=\"hljs-number\">_</span> age:UInt)</span></span>{\n <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello <span class=\"hljs-subst\">\\(name)</span>, you are <span class=\"hljs-subst\">\\(age)</span>\"</span>)\n}\n<span class=\"hljs-comment\">// Appel</span>\nsayHello(name:<span class=\"hljs-string\">\"Bob\"</span>, <span class=\"hljs-number\">32</span>)</code></pre>\n<p>Mais vous perdrez en clarté de code suivant les cas. Par exemple, avec <code>min(3,6)</code> on voit tout de suite ce que fait la fonction. Alors que <code>sayHelloTo(\"Bob\", 32)</code>, le <code>32</code> pourrait être beaucoup de choses.</p>\n<blockquote>\n<p>Les paramètres sont obligatoirement typés, mais peuvent être optionnels (en autorisant la valeur nil) avec la notation ? (e.g. Int?, String?).</p>\n</blockquote>\n<p>Vous pouvez aussi définir des valeurs par défauts pour les paramètres :</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-comment\">// Declaration</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">sayHello</span><span class=\"hljs-params\">(name:String, <span class=\"hljs-number\">_</span> age:UInt? = <span class=\"hljs-literal\">nil</span>)</span></span>{\n    <span class=\"hljs-keyword\">if</span> age == <span class=\"hljs-literal\">nil</span> {\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello <span class=\"hljs-subst\">\\(name)</span>\"</span>)\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Hello <span class=\"hljs-subst\">\\(name)</span>, you are <span class=\"hljs-subst\">\\(age!)</span>\"</span>) <span class=\"hljs-comment\">//! permet de pas afficher Optinal(value)</span>\n    }\n}\n<span class=\"hljs-comment\">// Appel</span>\nsayHello(name:<span class=\"hljs-string\">\"Bob\"</span>) <span class=\"hljs-comment\">// -> Hello Bob</span>\nsayHello(name:<span class=\"hljs-string\">\"Bob\"</span>, <span class=\"hljs-number\">32</span>) <span class=\"hljs-comment\">// ->  Hello Bob, you are 32</span></code></pre>\n<p>La plupart du temps nos fonctions servent à nous retourner des informations. Pour cela on utilise <code>-></code> en signe de retour suivi du type de la valeur retournée.</p>\n<pre><code>func formatHelloSentence(name:String, age:UInt? = nil) -> String {\n    if age == nil {\n        return \"Hello \\(name)\"\n    } else {\n        return \"Hello \\(name), you are \\(age)\"\n    }\n}\n// Appel\nlet helloSentence = formatHelloSentence(name:\"Bob\", age: 32)\n</code></pre>\n<h3 id=\"retours-multiples-ou-tuples\"><a href=\"#retours-multiples-ou-tuples\" class=\"phenomic-HeadingAnchor\">#</a>Retours multiples ou Tuples</h3>\n<p>Apple n’est pas connu pour sa générosité, mais dans Swift ils en ont fait autrement <code>:troll:</code> : on peut retourner plusieurs valeurs avec une seule fonction. Pour cela on utilise un <code>Tuple</code> : un collection de variables ordonnées.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">hardFunction</span><span class=\"hljs-params\">(fInputs:[Float])</span></span>->(<span class=\"hljs-type\">Int</span>,<span class=\"hljs-type\">Int</span>,<span class=\"hljs-type\">Float</span>,<span class=\"hljs-type\">String</span>) {    \n    <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">var</span> f : <span class=\"hljs-type\">Float</span> = <span class=\"hljs-number\">0.0</span>\n    <span class=\"hljs-keyword\">var</span> str = <span class=\"hljs-string\">\"\"</span>\n    <span class=\"hljs-comment\">//...</span>\n    <span class=\"hljs-keyword\">return</span> (a,b,f,str)\n}</code></pre>\n<p>Ici cette fonction prend en paramètres un tableau de <code>Float</code> et retourne un <em>Tuple</em> composé de deux <code>Int</code>, un <code>Float</code> et un <code>String</code> dans cet ordre. Vous pouvez alors utiliser le <em>Tuple</em> comme une structure en utilisant l’index des éléments du <em>Tuple</em> comme nom de variable (ex: <code>0</code>pour le premier <code>Int</code>, <code>3</code> pour le <code>String</code>).</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">let</span> myTuple = hardFunction([<span class=\"hljs-number\">2.4</span>,<span class=\"hljs-number\">2.6</span>,<span class=\"hljs-number\">1.8</span>])\n<span class=\"hljs-keyword\">let</span> myTupleString = myTuple.<span class=\"hljs-number\">3</span></code></pre>\n<p>Mais ceci reste assez confus, alors on peut nommer les éléments.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">hardFunction</span><span class=\"hljs-params\">(fInputs:[Float])</span></span>->(valSup:<span class=\"hljs-type\">Int</span>,\n        valMax:<span class=\"hljs-type\">Int</span>,\n        average:<span class=\"hljs-type\">Float</span>,\n        errorString:<span class=\"hljs-type\">String</span>) {\n    <span class=\"hljs-comment\">//...</span>\n}\n\n<span class=\"hljs-comment\">//utilisation</span>\n<span class=\"hljs-keyword\">let</span> myTuple = hardFunction([<span class=\"hljs-number\">2.4</span>,<span class=\"hljs-number\">2.6</span>,<span class=\"hljs-number\">1.8</span>])\n<span class=\"hljs-keyword\">let</span> myTupleString = myTuple.errorString <span class=\"hljs-comment\">// myTuple.3 marche encore</span></code></pre>\n<p>L'exécution du code permettant d'avoir les valeurs <em>Tuple</em> n'est effectuée qu'à la demande de ces valeurs. Dans l'exemple ci-dessus, le code de <code>hardFunction</code> ne sera appelé qu'à la dernière ligne, car c'est là qu'on a besoin de <code>errorString</code>, pas avant.</p>\n<p> Et la notion de <em>Closure</em> fait son entrée!</p>\n<h2 id=\"la-closure-la-variable-fonction\"><a href=\"#la-closure-la-variable-fonction\" class=\"phenomic-HeadingAnchor\">#</a>La closure: la variable-fonction</h2>\n<h3 id=\"quésaco\"><a href=\"#qu%C3%A9saco\" class=\"phenomic-HeadingAnchor\">#</a>Quésaco</h3>\n<p><strong>Une <em>closure</em> est une partie de code, avec paramètres et sorties, qui peut être encapsulé dans une variable, et exécutée à la demande</strong>. Si vous développez en C++ ou Objective-C vous connaissez peut-être déjà les <em>blocks</em> et en Java ou C# les <em>lambdas</em> qui sont des <em>features</em> très (très) proches.</p>\n<h3 id=\"déclaration\"><a href=\"#d%C3%A9claration\" class=\"phenomic-HeadingAnchor\">#</a>Déclaration</h3>\n<p>Une <em>closure</em>  se déclare grâce au <code>{}</code> et peut être appelée (exécutée) grâce aux parenthèses :</p>\n<pre><code class=\"hljs language-swift\"> <span class=\"hljs-keyword\">let</span> helloClosure = {\n     <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"hello, I’m a closure\"</span>)\n }\n\n helloClosure() <span class=\"hljs-comment\">// Le code est exécuté ici</span></code></pre>\n<p>Ça vous rappelle rien ? L’appel d’une <em>fonction</em> ! En réalité, la <em>fonction</em> est une <em>closure</em> particulière associé à un contexte (Object, environnement, Bundle...) pour réaliser des optimisations et une meilleur compréhension du code.</p>\n<blockquote>\n<p>Pour une <em>closure</em> \"à l’air libre\", on dit d’elle, qu’elle est <em>Self Contained</em> alors qu’une fonction est contenue par un contexte (<code>class</code> par exemple)</p>\n</blockquote>\n<p>Comme les fonctions, les <em>closures</em>  ont des paramètres d’entrée et de retour:  </p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">let</span> complexClosure = {(name:<span class=\"hljs-type\">String</span>, age:<span class=\"hljs-type\">Float</span>) -> <span class=\"hljs-type\">Bool</span> <span class=\"hljs-keyword\">in</span>\n    <span class=\"hljs-comment\">// Code</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n}\n<span class=\"hljs-keyword\">let</span> success = complexClosure(<span class=\"hljs-string\">\"Louis\"</span>,<span class=\"hljs-number\">32</span>)\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Louis has <span class=\"hljs-subst\">\\(success)</span>\"</span>)</code></pre>\n<p>Ainsi, les valeurs dans la première partie après la <code>{</code> sont les paramètres d’entrées et après la <code>-></code> ce sont les paramètres de sortie. Le code à exécuter est après le <code>in</code>.</p>\n<blockquote>\n<p>Comme vous avez dû le remarquer, les <em>closures</em> n’ont pas de paramètres nominatif. IL faut passer les paramètres d'entrée dans l'ordre de la déclaration.</p>\n</blockquote>\n<h3 id=\"closure-et-type\"><a href=\"#closure-et-type\" class=\"phenomic-HeadingAnchor\">#</a>Closure et Type</h3>\n<p>Toute variable est typée en <em>Swift</em>, implicitement ou explicitement. Pour les <em>closures</em> le type est souvent implicite, aussi bien qu’on en oublie souvent qu’elles sont typées. Le type d’une closure va être défini par ses paramètres d’entrée et de sortie. Ainsi la <em>complexClosure</em>  ci-dessus est du type : <code>((String, Float)) -> (Bool)</code>.</p>\n<p>Je peux alors écrire ce code puisque les closures sont du même type :</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">let</span> otherComplexClosure = { (surname:<span class=\"hljs-type\">String</span>,size:<span class=\"hljs-type\">Float</span>) -> <span class=\"hljs-type\">Bool</span> <span class=\"hljs-keyword\">in</span>\n    <span class=\"hljs-comment\">// Other complexe Code</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n}\ncomplexClosure = otherComplexClosure</code></pre>\n<h3 id=\"utilisation-du-contexte\"><a href=\"#utilisation-du-contexte\" class=\"phenomic-HeadingAnchor\">#</a>Utilisation du contexte</h3>\n<p>Les <em>closures</em> ont une connaissance du contexte qui l’entoure. Ce qui veut dire que si la closure est créé dans une méthode, elle aura accès :</p>\n<ul>\n<li>au contexte de classe en passant par <code>self</code> (variables, autre fonctions...)</li>\n<li>au contexte de la fonction (paramètres, fonctions internes...)</li>\n</ul>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Animal</span> </span>{\n    <span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">\"Boby\"</span>\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">crier</span><span class=\"hljs-params\">(cri:String)</span></span>{\n        <span class=\"hljs-keyword\">let</span> uselessClosure = {\n            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"<span class=\"hljs-subst\">\\(<span class=\"hljs-keyword\">self</span>.name)</span> cri <span class=\"hljs-subst\">\\(cri)</span>\"</span>)\n        }\n        uselessClosure()\n    }\n}</code></pre>\n<h3 id=\"trailing-closure\"><a href=\"#trailing-closure\" class=\"phenomic-HeadingAnchor\">#</a>Trailing Closure</h3>\n<p>Pour finir, un peu d'esthétisme car on aime tous le <em>beau</em> code. La <em>Trailing Closure</em> est une syntaxe d'appel de fonction qui permet de rendre le code plus facile à lire.</p>\n<p>Prenant la fonction suivante, prenant une <code>URL</code> est une closure de type <code>Void->Void</code> :</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">doLongTask</span><span class=\"hljs-params\">(on file:URL,\n        completion:<span class=\"hljs-params\">()</span></span></span> -> ()){\n    <span class=\"hljs-comment\">//long task</span>\n    completion()\n}</code></pre>\n<p>On alors l'appeler cette fonction comme ceci :</p>\n<pre><code class=\"hljs language-swift\">doLongTask(on: aFileURL, completion:{\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Task Applied on <span class=\"hljs-subst\">\\(aFileURL)</span>\"</span>)\n})</code></pre>\n<p>Avec du code plus complexe, ça commence à devenir difficile à lire. Or si le dernier paramètre d'une fonction est une <em>closure</em>, on peut alors écrire l'appel comme ceci :</p>\n<pre><code class=\"hljs language-swift\">doLongTask(on: aFileURL){\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Task Applied on <span class=\"hljs-subst\">\\(aFileURL)</span>\"</span>)\n}</code></pre>\n<h2 id=\"pro-tip\"><a href=\"#pro-tip\" class=\"phenomic-HeadingAnchor\">#</a>Pro Tip</h2>\n<p>Imaginons une classe <code>A</code> ayant une variable <code>event</code>  et un classe <code>B</code> ayant une fonction <code>awesomeEvent</code> ayant le même type que la variable <code>event</code> de la classe <code>A</code>. Je peux alors allouer, à la variable <code>event</code>, le code de <code>awesomeEvent</code>.</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span> </span>{\n    <span class=\"hljs-keyword\">var</span> event : ((<span class=\"hljs-type\">String</span>)-><span class=\"hljs-type\">Void</span>)?\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">B</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">awesome</span><span class=\"hljs-params\">(name:String)</span></span>{\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"Awesome <span class=\"hljs-subst\">\\(name)</span>\"</span>)\n    }\n}\n\n<span class=\"hljs-keyword\">let</span> b = <span class=\"hljs-type\">B</span>()\n<span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-type\">A</span>()\n\na.event = b.awesome\na.event?(<span class=\"hljs-string\">\"Mate\"</span>)</code></pre>\n<p><a href=\"http://swift.sandbox.bluemix.net/#/repl/59ecdb8508529b23242b5696\">Exécutez ce code sur IBM Swift Sandbox c'est magique!</a></p>\n<h2 id=\"conclusion\"><a href=\"#conclusion\" class=\"phenomic-HeadingAnchor\">#</a>Conclusion</h2>\n<p>Voilà vous savez tout, ou presque, sur les fonctions et les closures. Les closures ont vraiment la part belle en Swift, donc apprenez à les utiliser et les comprendre pour simplifiez votre code. Elles sont partout dans les API iOS et macOS.</p>\n<p>Et un petit conseil: faite attention à l'état de vos <em>closures</em> dans vos <code>Thread</code> si vous ne voulez pas de fuite 😊</p>\n","rawBody":"\n**Swift** est un langage simple pour les débutants, tout en offrant de grandes possibilitées aux développeurs expérimentés. Les *fonctions* Swift sont un bon exemple de cette façon d’avoir pensé le langage.\n\n## Les fonctions\n\n### Déclaration simple\n\nLa déclaration et l’utilisation de *fonctions* est simple. On commence avec le mot clé `func` suivi du *nom*, puis des *paramètres* entre parenthèses (a.k.a. `input`) :\n\n```swift\nfunc sayHello(name:String, age:UInt){\n    print(\"Hello \\(name), you are \\(age)\")\n}\n```\n\nL’appel se fait aussi simplement que ça : `sayHello(name:\"Bob\", age: 32)`. Le mot clé `_` permet d'enlever le label du paramètre dans l'appel si besoin :\n\n```swift\n// Declaration\nfunc sayHello(name:String,_ age:UInt){\n print(\"Hello \\(name), you are \\(age)\")\n}\n// Appel\nsayHello(name:\"Bob\", 32)\n```\n\nMais vous perdrez en clarté de code suivant les cas. Par exemple, avec `min(3,6)` on voit tout de suite ce que fait la fonction. Alors que `sayHelloTo(\"Bob\", 32)`, le `32` pourrait être beaucoup de choses.\n\n> Les paramètres sont obligatoirement typés, mais peuvent être optionnels (en autorisant la valeur nil) avec la notation ? (e.g. Int?, String?).\n\nVous pouvez aussi définir des valeurs par défauts pour les paramètres :\n\n```swift\n// Declaration\nfunc sayHello(name:String, _ age:UInt? = nil){\n    if age == nil {\n        print(\"Hello \\(name)\")\n    } else {\n        print(\"Hello \\(name), you are \\(age!)\") //! permet de pas afficher Optinal(value)\n    }\n}\n// Appel\nsayHello(name:\"Bob\") // -> Hello Bob\nsayHello(name:\"Bob\", 32) // ->  Hello Bob, you are 32\n```\n\nLa plupart du temps nos fonctions servent à nous retourner des informations. Pour cela on utilise `->` en signe de retour suivi du type de la valeur retournée.\n\n```\nfunc formatHelloSentence(name:String, age:UInt? = nil) -> String {\n    if age == nil {\n        return \"Hello \\(name)\"\n    } else {\n        return \"Hello \\(name), you are \\(age)\"\n    }\n}\n// Appel\nlet helloSentence = formatHelloSentence(name:\"Bob\", age: 32)\n```\n\n### Retours multiples ou Tuples\n\nApple n’est pas connu pour sa générosité, mais dans Swift ils en ont fait autrement `:troll:` : on peut retourner plusieurs valeurs avec une seule fonction. Pour cela on utilise un `Tuple` : un collection de variables ordonnées.\n\n```swift\nfunc hardFunction(fInputs:[Float])->(Int,Int,Float,String) {    \n    var a = 0\n    var b = 0\n    var f : Float = 0.0\n    var str = \"\"\n    //...\n    return (a,b,f,str)\n}\n```\n\nIci cette fonction prend en paramètres un tableau de `Float` et retourne un *Tuple* composé de deux `Int`, un `Float` et un `String` dans cet ordre. Vous pouvez alors utiliser le *Tuple* comme une structure en utilisant l’index des éléments du *Tuple* comme nom de variable (ex: `0`pour le premier `Int`, `3` pour le `String`).\n\n```swift\nlet myTuple = hardFunction([2.4,2.6,1.8])\nlet myTupleString = myTuple.3\n```\n\nMais ceci reste assez confus, alors on peut nommer les éléments.\n\n```swift\nfunc hardFunction(fInputs:[Float])->(valSup:Int,\n        valMax:Int,\n        average:Float,\n        errorString:String) {\n    //...\n}\n\n//utilisation\nlet myTuple = hardFunction([2.4,2.6,1.8])\nlet myTupleString = myTuple.errorString // myTuple.3 marche encore\n```\n\nL'exécution du code permettant d'avoir les valeurs *Tuple* n'est effectuée qu'à la demande de ces valeurs. Dans l'exemple ci-dessus, le code de `hardFunction` ne sera appelé qu'à la dernière ligne, car c'est là qu'on a besoin de `errorString`, pas avant.\n\n Et la notion de *Closure* fait son entrée!\n\n## La closure: la variable-fonction\n\n### Quésaco\n\n**Une *closure* est une partie de code, avec paramètres et sorties, qui peut être encapsulé dans une variable, et exécutée à la demande**. Si vous développez en C++ ou Objective-C vous connaissez peut-être déjà les *blocks* et en Java ou C# les *lambdas* qui sont des *features* très (très) proches.\n\n### Déclaration\n\nUne *closure*  se déclare grâce au `{}` et peut être appelée (exécutée) grâce aux parenthèses :\n\n```swift\n let helloClosure = {\n     print(\"hello, I’m a closure\")\n }\n\n helloClosure() // Le code est exécuté ici\n```\n\nÇa vous rappelle rien ? L’appel d’une *fonction* ! En réalité, la *fonction* est une *closure* particulière associé à un contexte (Object, environnement, Bundle...) pour réaliser des optimisations et une meilleur compréhension du code.\n\n> Pour une *closure* \"à l’air libre\", on dit d’elle, qu’elle est *Self Contained* alors qu’une fonction est contenue par un contexte (`class` par exemple)\n\nComme les fonctions, les *closures*  ont des paramètres d’entrée et de retour:  \n\n```swift\nlet complexClosure = {(name:String, age:Float) -> Bool in\n    // Code\n    return false\n}\nlet success = complexClosure(\"Louis\",32)\nprint(\"Louis has \\(success)\")\n```\n\nAinsi, les valeurs dans la première partie après la `{` sont les paramètres d’entrées et après la `->` ce sont les paramètres de sortie. Le code à exécuter est après le `in`.\n\n> Comme vous avez dû le remarquer, les *closures* n’ont pas de paramètres nominatif. IL faut passer les paramètres d'entrée dans l'ordre de la déclaration.\n\n### Closure et Type\n\nToute variable est typée en *Swift*, implicitement ou explicitement. Pour les *closures* le type est souvent implicite, aussi bien qu’on en oublie souvent qu’elles sont typées. Le type d’une closure va être défini par ses paramètres d’entrée et de sortie. Ainsi la *complexClosure*  ci-dessus est du type : `((String, Float)) -> (Bool)`.\n\nJe peux alors écrire ce code puisque les closures sont du même type :\n\n```swift\nlet otherComplexClosure = { (surname:String,size:Float) -> Bool in\n    // Other complexe Code\n    return true\n}\ncomplexClosure = otherComplexClosure\n```\n\n### Utilisation du contexte\n\nLes *closures* ont une connaissance du contexte qui l’entoure. Ce qui veut dire que si la closure est créé dans une méthode, elle aura accès :\n\n- au contexte de classe en passant par `self` (variables, autre fonctions...)\n- au contexte de la fonction (paramètres, fonctions internes...)\n\n```swift\nclass Animal {\n    var name = \"Boby\"\n\n    func crier(cri:String){\n        let uselessClosure = {\n            print(\"\\(self.name) cri \\(cri)\")\n        }\n        uselessClosure()\n    }\n}\n```\n\n### Trailing Closure\n\nPour finir, un peu d'esthétisme car on aime tous le *beau* code. La *Trailing Closure* est une syntaxe d'appel de fonction qui permet de rendre le code plus facile à lire.\n\nPrenant la fonction suivante, prenant une `URL` est une closure de type `Void->Void` :\n\n```swift\nfunc doLongTask(on file:URL,\n        completion:() -> ()){\n    //long task\n    completion()\n}\n```\n\nOn alors l'appeler cette fonction comme ceci :\n\n```swift\ndoLongTask(on: aFileURL, completion:{\n    print(\"Task Applied on \\(aFileURL)\")\n})\n```\n\nAvec du code plus complexe, ça commence à devenir difficile à lire. Or si le dernier paramètre d'une fonction est une *closure*, on peut alors écrire l'appel comme ceci :\n\n```swift\ndoLongTask(on: aFileURL){\n    print(\"Task Applied on \\(aFileURL)\")\n}\n```\n\n## Pro Tip\n\nImaginons une classe `A` ayant une variable `event`  et un classe `B` ayant une fonction `awesomeEvent` ayant le même type que la variable `event` de la classe `A`. Je peux alors allouer, à la variable `event`, le code de `awesomeEvent`.\n\n```swift\nclass A {\n    var event : ((String)->Void)?\n}\n\nclass B {\n    func awesome(name:String){\n        print(\"Awesome \\(name)\")\n    }\n}\n\nlet b = B()\nlet a = A()\n\na.event = b.awesome\na.event?(\"Mate\")\n```\n\n[Exécutez ce code sur IBM Swift Sandbox c'est magique!](http://swift.sandbox.bluemix.net/#/repl/59ecdb8508529b23242b5696)\n\n## Conclusion\n\nVoilà vous savez tout, ou presque, sur les fonctions et les closures. Les closures ont vraiment la part belle en Swift, donc apprenez à les utiliser et les comprendre pour simplifiez votre code. Elles sont partout dans les API iOS et macOS.\n\nEt un petit conseil: faite attention à l'état de vos *closures* dans vos `Thread` si vous ne voulez pas de fuite 😊\n","__filename":"fr/articles/swift/closure/index.md","__url":"/fr/articles/swift/closure/","__resourceUrl":"/fr/articles/swift/closure/index.html","__dataUrl":"/fr/articles/swift/closure/index.html.38a5c3af80e04dfc9a08c9dcdd88a60d.json"}