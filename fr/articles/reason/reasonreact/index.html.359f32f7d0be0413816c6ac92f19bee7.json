{"head":{"layout":"Post","comments":true,"date":"2017-11-09","title":"ReasonReact, pour une UI qu'elle est bien typ√©e","tags":["reasonml","ocaml","react"],"authors":["bloodyowl"],"header":{"image":"index.png","linearGradient":null},"description":"Si comme moi, depuis l‚Äôapparition de React, vous vous √™tes de plus en int√©ress√©s au typage pour vos applications front (c'est √ßa de‚Ä¶"},"body":"<p>Si comme moi, depuis l‚Äôapparition de React, vous vous √™tes de plus en int√©ress√©s au typage pour vos applications front (c'est √ßa de commencer avec JS‚Ä¶), vous avez certainement utilis√© les <code>propTypes</code> au d√©but en vous disant \"putain c'est cool de v√©rifier les types, √ßa m'√©vite bien des probl√®mes\". Puis c‚Äô√©tait sympa mais bon, faut quand m√™me ex√©cuter le bout de code qui p√®te et il est peut-√™tre super chiant d'y acc√©der dans l'app. Du coup, vous vous √™tes s√ªrement tourn√©s vers Flow ou TypeScript.</p>\n<p>Dans cet article, on va d√©couvrir la <em>next-step</em> dans ce cheminement : √©crire nos composants React dans un langage statiquement et fortement typ√©: Reason üöÄ. Reason, c'est OCaml, avec son type-system puissant et une syntaxe plus simple quand on vient du JS. Si vous n‚Äôavez pas lu <a href=\"/fr/articles/reason/introduction-reason/\">l‚Äôintroduction √† ce langage</a>, c‚Äôest le moment.</p>\n<p>L√†, je vais vous pr√©senter <strong>ReasonReact</strong>, des bindings API par dessus React support√©s officiellement par l'√©quipe de Reason. Facebook <em>dogfood</em> la solution puisqu'elle est utilis√©e sur messenger.com pour la majeure partie de ses composants.</p>\n<h2 id=\"stateless\"><a href=\"#stateless\" class=\"phenomic-HeadingAnchor\">#</a>Stateless</h2>\n<p>Commen√ßons par le traditionnel HelloWorld‚Ñ¢ :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">/* Un composant ReasonReact se cr√©e en deux temps: d'abord on cr√©e le `component`\n   √† partir d‚Äôun appel √† `statelessComponent` ou `reducerComponent` (il existe d'autres\n   cas plus avanc√©s, mais on s'y attardera pas dans cet article d'introduction). */</span>\n<span class=\"hljs-keyword\">let</span> component = ReasonReact.statelessComponent(<span class=\"hljs-string\">\"HelloWorld\"</span>);\n\n<span class=\"hljs-comment\">/* Ensuite, on d√©clare une fonction `make` qui prend des arguments nomm√©s\n   (qui √©quivalent aux `props` de React) et un dernier argument non-nomm√©,\n   contenant les `children`. Cette fonction doit retourner un record, dans\n   lequel on spread notre `component` et dans lequel on d√©finit une propri√©t√©\n   `render` qui prend comme param√®tre `self` (√©quivalent du `this`) et qui retourne\n   un √©l√©ment React. L√†-dessus √ßa devrait pas trop vous chambouler de ce que\n   vous connaissez de React.\n   On peut remarquer que les props sont les arguments de la fonction `make`,\n   comme avec les composants fonctionnels de React.*/</span>\n<span class=\"hljs-keyword\">let</span> make = <span class=\"hljs-function\">(<span class=\"hljs-params\">~message, _children</span>) =></span> {\n  ...component,\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">_self</span>) =></span>\n    &#x3C;div>\n      (ReasonReact.stringToElement message)\n    &#x3C;<span class=\"hljs-regexp\">/div>\n};</span></code></pre>\n<p>Et pour monter le composant :</p>\n<pre><code class=\"hljs language-js\">ReactDOMRe.renderToElementWithId(<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">HelloWorld</span> <span class=\"hljs-attr\">message</span>=<span class=\"hljs-string\">\"Helloworld\"</span> /></span>, \"root\");</span></code></pre>\n<p>Un des gros avantages √† utiliser Reason, c‚Äôest que le langage est capable d‚Äôinf√©rer la grande majorit√© des types et sera en mesure de d√©tecter dans toute l‚Äôapp si quelque chose n‚Äôest pas pass√© correctement : pour le langage, il s‚Äòagit simplement de fonctions qui appellent d‚Äôautres fonctions, et les langages fonctionnels statiquement et fortement typ√©s sont plut√¥t pas d√©gueulasses pour √ßa.</p>\n<h2 id=\"stateful\"><a href=\"#stateful\" class=\"phenomic-HeadingAnchor\">#</a>Stateful</h2>\n<p>La petite particularit√© de ReasonReact vis √† vis des composants stateful, c‚Äôest que les mises √† jour d'√©tats doivent passer par un reducer, comme si chaque composant embarquait sa petite impl√©mentation de redux.</p>\n<p>Maintenant, comment qu'on fait pour cr√©er un composant stateful ?</p>\n<p>On commence par d√©finir le type du state : contrairement √† JS, il ne s'agit pas forc√©ment d'un objet, √ßa peut √™tre une cha√Æne de caract√®re, un entier, un variant, un boolean, un arbuste, une map, un jus de fruits frais, un tableau, whatever.</p>\n<pre><code class=\"hljs language-js\">type state = {\n  <span class=\"hljs-attr\">counter</span>: int\n};</code></pre>\n<p>On va d√©finir notre type action, sous la forme de variants: chaque variant repr√©sente un des type d‚Äôaction possible. Pour bien se repr√©senter ce qu'est une action, c‚Äôest un token, contenant possiblement des param√®tres, qu‚Äôon va envoyer √† notre fameux reducer qui, lui, retournera une r√©action √† cette action.</p>\n<pre><code class=\"hljs language-js\">type action =\n  | Increment\n  | Decrement;</code></pre>\n<p>Dans le composant retourn√© par <code>make</code>, on ajoute une fonction <code>initialState</code> qui retourne‚Ä¶ l'√©tat initial (c'est bien, vous suivez), et une fonction <code>reducer</code>, qui effectue un pattern-matching sur l‚Äôaction et retourne une update.\nCette fonction prend deux param√®tres: l'<code>action</code> √† traiter et le <code>state</code> √† jour (comme lorsque l'on passe un callback √† <code>setState</code> dans l'√©quivalent JavaScript <code>setState(state => newState)</code>).</p>\n<p>L‚Äôupdate retourn√©e indique au component comment il doit se mettre √† jour (ici sont list√©s les cas courants) :</p>\n<ul>\n<li><code>NoUpdate</code>, pour ne rien faire</li>\n<li><code>Update</code>, pour mettre √† jour l‚Äô√©tat et re-rendre le composant</li>\n<li><code>SideEffect</code> pour lancer un effet de bord (e.g. une requ√™te r√©seau)</li>\n<li><code>UpdateWithSideEffect</code>, pour changer le state et lancer un effet de bord (e.g. afficher un loader et lancer une requ√™te)</li>\n</ul>\n<p><em>Wrapping up</em> :</p>\n<pre><code class=\"hljs language-js\">type state = {<span class=\"hljs-attr\">counter</span>: int};\n\ntype action =\n  | Increment\n  | Decrement;\n\n<span class=\"hljs-comment\">/* Il faut bien d√©finir le `component` **apr√®s** les types `state` et `action`, pour qu'il puisse les lire */</span>\n<span class=\"hljs-keyword\">let</span> component = ReasonReact.reducerComponent(<span class=\"hljs-string\">\"Count\"</span>);\n\n<span class=\"hljs-keyword\">let</span> make = <span class=\"hljs-function\">(<span class=\"hljs-params\">~initialCounter=<span class=\"hljs-number\">0</span>, _</span>) =></span> {\n  ...component,\n  <span class=\"hljs-attr\">initialState</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {<span class=\"hljs-attr\">counter</span>: initialCounter},\n  <span class=\"hljs-attr\">reducer</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">action, state</span>) =></span>\n    <span class=\"hljs-comment\">/* Toutes mes updates passent par l√†, bien pratique pour qu'une\n      personne puisse aborder rapidement le composant */</span>\n    <span class=\"hljs-keyword\">switch</span> action {\n    | <span class=\"hljs-function\"><span class=\"hljs-params\">Increment</span> =></span> ReasonReact.Update({<span class=\"hljs-attr\">counter</span>: state.counter + <span class=\"hljs-number\">1</span>})\n    | <span class=\"hljs-function\"><span class=\"hljs-params\">Decrement</span> =></span> ReasonReact.Update({<span class=\"hljs-attr\">counter</span>: max(<span class=\"hljs-number\">0</span>, state.counter - <span class=\"hljs-number\">1</span>)})\n    },\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">{state, reduce}</span>) =></span>\n    &#x3C;div>\n      (ReasonReact.stringToElement(state.counter |> string_of_int))\n      <span class=\"hljs-comment\">/* La fonction reduce prend une fonction qui retourne l'action.\n           Il s'agit d'une fonction pour lire les propri√©t√©s des\n           events (qui sont pooled dans React) de mani√®re synchrone, alors\n           que le reducer est appel√© de mani√®re asynchrone.\n         */</span>\n      &#x3C;button onClick=<span class=\"hljs-function\">(<span class=\"hljs-params\">reduce((_event</span>) =></span> Decrement))> (ReasonReact.stringToElement(<span class=\"hljs-string\">\"-\"</span>)) &#x3C;<span class=\"hljs-regexp\">/button>\n      &#x3C;button onClick=(reduce((_event) => Increment))> (ReasonReact.stringToElement(\"+\")) &#x3C;/</span>button>\n    <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n};</code></pre>\n<p>et hop:</p>\n<pre><code class=\"hljs language-js\">ReactDOM.renderToElementWithId(<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">Count</span> <span class=\"hljs-attr\">initialCount</span>=<span class=\"hljs-string\">0</span> /></span>, \"App\");</span></code></pre>\n<h2 id=\"with-side-effects\"><a href=\"#with-side-effects\" class=\"phenomic-HeadingAnchor\">#</a>With side-effects</h2>\n<p>Bien que √ßa puisse para√Ætre un peu lourd de devoir faire un <code>reducer</code> pour g√©rer ses updates, √ßa apporte quand m√™me:</p>\n<ul>\n<li>Un seul endroit par composant o√π toutes les updates passent</li>\n<li>La possibilit√© pour le compiler de d√©tecter si l'on oublie de g√©rer des actions</li>\n<li>De g√©rer lisiblement et uniform√©ment les effets de bord</li>\n</ul>\n<p><img src=\"./terminal.png\" alt=\"\" /></p>\n<p>Exemple ici avec un composant o√π on va faire comme si on r√©cup√©rait l'utilisateur connect√© sur une API.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> resolveAfter = <span class=\"hljs-function\">(<span class=\"hljs-params\">ms</span>) =></span>\n  Js.Promise.make(\n    <span class=\"hljs-function\">(<span class=\"hljs-params\">~resolve, ~reject <span class=\"hljs-keyword\">as</span> _</span>) =></span> ignore(Js.Global.setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> [@bs] resolve(ms), ms))\n  );\n\n<span class=\"hljs-built_in\">module</span> User = {\n  type t = {<span class=\"hljs-attr\">username</span>: string};\n  <span class=\"hljs-comment\">/* faisons comme si on avait un appel serveur\n     (je le fais comme √ßa pour que vous puissiez copier/coller le code\n     pour essayer chez vous) */</span>\n  <span class=\"hljs-keyword\">let</span> getUser = <span class=\"hljs-function\">(<span class=\"hljs-params\">_</span>) =></span>\n    resolveAfter(<span class=\"hljs-number\">1000</span>)\n    |> Js.Promise.then_(\n         <span class=\"hljs-function\">(<span class=\"hljs-params\">_</span>) =></span>\n           Js.Promise.resolve({\n             <span class=\"hljs-attr\">username</span>: <span class=\"hljs-string\">\"MyUsername\"</span> ++ string_of_int(Js.Math.random_int(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">9999</span>))\n           })\n       );\n};\n\n<span class=\"hljs-comment\">/* Le \"user\" distant peut avoir 4 √©tats possibles ici */</span>\ntype resource(<span class=\"hljs-string\">'a) =\n  | Inactive\n  | Loading\n  | Idle('</span>a)\n  | Errored;\n\ntype action =\n  | Load\n  | Receive(resource(User.t));\n\ntype state = {<span class=\"hljs-attr\">user</span>: resource(User.t)};\n\n<span class=\"hljs-keyword\">let</span> component = ReasonReact.reducerComponent(<span class=\"hljs-string\">\"User\"</span>);\n\n<span class=\"hljs-keyword\">let</span> getUser = <span class=\"hljs-function\">(<span class=\"hljs-params\">credentials, {ReasonReact.reduce}</span>) =></span>\n  ignore(\n    User.getUser(credentials)\n    <span class=\"hljs-comment\">/* Si tout s'est bien pass√© */</span>\n    |> Js.Promise.then_(\n         <span class=\"hljs-comment\">/* On peut utiliser les actions en dehors du `make`: c'est juste des variants */</span>\n         (payload) => Js.Promise.resolve(reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">payload</span>) =></span> Receive(Idle(payload)), payload))\n       )\n    <span class=\"hljs-comment\">/* Si √ßa a merd√© */</span>\n    |> Js.Promise.catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">_</span>) =></span> Js.Promise.resolve(reduce(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> Receive(Errored), ())))\n  );\n\n<span class=\"hljs-keyword\">let</span> make = <span class=\"hljs-function\">(<span class=\"hljs-params\">~credentials, _</span>) =></span> {\n  ...component,\n  <span class=\"hljs-attr\">initialState</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> {<span class=\"hljs-attr\">user</span>: Inactive},\n  <span class=\"hljs-attr\">reducer</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">action, _state</span>) =></span>\n    <span class=\"hljs-keyword\">switch</span> action {\n    <span class=\"hljs-comment\">/* UpdateWithSideEffects met √† jour l'√©tat, puis lance l'effet de bord,\n       tr√®s pratique pour ce genre de cas */</span>\n    | <span class=\"hljs-function\"><span class=\"hljs-params\">Load</span> =></span> ReasonReact.UpdateWithSideEffects({<span class=\"hljs-attr\">user</span>: Loading}, getUser(credentials))\n    | Receive(user) => ReasonReact.Update({<span class=\"hljs-attr\">user</span>: user})\n    },\n  <span class=\"hljs-attr\">didMount</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">{reduce}</span>) =></span> {\n    reduce(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =></span> Load, ());\n    ReasonReact.NoUpdate\n  },\n  <span class=\"hljs-attr\">render</span>: <span class=\"hljs-function\">(<span class=\"hljs-params\">{state, reduce}</span>) =></span>\n    &#x3C;div>\n      (\n        ReasonReact.stringToElement(\n          <span class=\"hljs-keyword\">switch</span> state.user {\n          | Inactive\n          | <span class=\"hljs-function\"><span class=\"hljs-params\">Loading</span> =></span> <span class=\"hljs-string\">\"Loading ...\"</span>\n          | Idle(user) => <span class=\"hljs-string\">\"Hello \"</span> ++ user.username\n          | <span class=\"hljs-function\"><span class=\"hljs-params\">Errored</span> =></span> <span class=\"hljs-string\">\"An error occured\"</span>\n          }\n        )\n      )\n      &#x3C;div>\n        <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">button</span>\n          <span class=\"hljs-attr\">disabled</span>=<span class=\"hljs-string\">(</span>\n            <span class=\"hljs-attr\">switch</span> <span class=\"hljs-attr\">state.user</span> {\n            | <span class=\"hljs-attr\">Idle</span>(<span class=\"hljs-attr\">_</span>) =></span> Js.false_\n            | _ => Js.true_\n            }\n          )\n          onClick=(reduce((_) => Load))>\n          (ReasonReact.stringToElement(\"Reload\"))\n        <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">button</span>></span></span>\n      &#x3C;<span class=\"hljs-regexp\">/div>\n    &#x3C;/</span>div>\n};</code></pre>\n<h2 id=\"oui-mais-est-ce-que-je-peux-lutiliser-aujourdhui-alors-que-jai-d√©j√†-une-grosse-codebase-react-\"><a href=\"#oui-mais-est-ce-que-je-peux-lutiliser-aujourdhui-alors-que-jai-d%C3%A9j%C3%A0-une-grosse-codebase-react-\" class=\"phenomic-HeadingAnchor\">#</a>Oui mais est-ce que je peux l'utiliser aujourd'hui alors que j'ai d√©j√† une grosse codebase React ?</h2>\n<p><img src=\"./tenor.gif\" alt=\"\" /></p>\n<p>Pour utiliser des composants ReasonReact avec React</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">let</span> jsComponent =\n  ReasonReact.wrapReasonForJs(\n    ~component,\n    (jsProps) =>\n      make(\n        ~credentials=jsProps##credentials,\n        [||]\n      )\n  );</code></pre>\n<p>et</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> MyComponent = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">\"path/to/reason/output\"</span>).jsComponent;</code></pre>\n<p>√Ä l'inverse, pour utiliser des composants React avec ReasonReact</p>\n<pre><code class=\"hljs language-js\">[@bs.module <span class=\"hljs-string\">\"path/to/good/old/reactjs/component\"</span>] external myJsComponent : ReasonReact.reactClass = <span class=\"hljs-string\">\"default\"</span>;\n\n<span class=\"hljs-keyword\">let</span> make = <span class=\"hljs-function\">(<span class=\"hljs-params\">~message: string, _children</span>) =></span>\n  ReasonReact.wrapJsForReason(\n    ~reactClass=myJsComponent,\n    ~props={<span class=\"hljs-string\">\"message\"</span>: message},\n    [||]\n ¬†);</code></pre>\n<p>Voil√† pour les <em>basics</em> de ReasonReact. Pour en savoir plus, y a <a href=\"https://reasonml.github.io/reason-react/\">la petite doc qui va bien</a>, et on vous pr√©parera un petit article sur les aspects un peu plus avanc√©s de l'usage.</p>\n<p>Bisous bisous.</p>\n","rawBody":"\nSi comme moi, depuis l‚Äôapparition de React, vous vous √™tes de plus en int√©ress√©s au typage pour vos applications front (c'est √ßa de commencer avec JS‚Ä¶), vous avez certainement utilis√© les `propTypes` au d√©but en vous disant \"putain c'est cool de v√©rifier les types, √ßa m'√©vite bien des probl√®mes\". Puis c‚Äô√©tait sympa mais bon, faut quand m√™me ex√©cuter le bout de code qui p√®te et il est peut-√™tre super chiant d'y acc√©der dans l'app. Du coup, vous vous √™tes s√ªrement tourn√©s vers Flow ou TypeScript.\n\nDans cet article, on va d√©couvrir la *next-step* dans ce cheminement : √©crire nos composants React dans un langage statiquement et fortement typ√©: Reason üöÄ. Reason, c'est OCaml, avec son type-system puissant et une syntaxe plus simple quand on vient du JS. Si vous n‚Äôavez pas lu [l‚Äôintroduction √† ce langage](/fr/articles/reason/introduction-reason/), c‚Äôest le moment.\n\nL√†, je vais vous pr√©senter **ReasonReact**, des bindings API par dessus React support√©s officiellement par l'√©quipe de Reason. Facebook *dogfood* la solution puisqu'elle est utilis√©e sur messenger.com pour la majeure partie de ses composants.\n\n## Stateless\n\nCommen√ßons par le traditionnel HelloWorld‚Ñ¢ :\n\n```js\n/* Un composant ReasonReact se cr√©e en deux temps: d'abord on cr√©e le `component`\n   √† partir d‚Äôun appel √† `statelessComponent` ou `reducerComponent` (il existe d'autres\n   cas plus avanc√©s, mais on s'y attardera pas dans cet article d'introduction). */\nlet component = ReasonReact.statelessComponent(\"HelloWorld\");\n\n/* Ensuite, on d√©clare une fonction `make` qui prend des arguments nomm√©s\n   (qui √©quivalent aux `props` de React) et un dernier argument non-nomm√©,\n   contenant les `children`. Cette fonction doit retourner un record, dans\n   lequel on spread notre `component` et dans lequel on d√©finit une propri√©t√©\n   `render` qui prend comme param√®tre `self` (√©quivalent du `this`) et qui retourne\n   un √©l√©ment React. L√†-dessus √ßa devrait pas trop vous chambouler de ce que\n   vous connaissez de React.\n   On peut remarquer que les props sont les arguments de la fonction `make`,\n   comme avec les composants fonctionnels de React.*/\nlet make = (~message, _children) => {\n  ...component,\n  render: (_self) =>\n    <div>\n      (ReasonReact.stringToElement message)\n    </div>\n};\n```\n\nEt pour monter le composant :\n\n```js\nReactDOMRe.renderToElementWithId(<HelloWorld message=\"Helloworld\" />, \"root\");\n```\n\nUn des gros avantages √† utiliser Reason, c‚Äôest que le langage est capable d‚Äôinf√©rer la grande majorit√© des types et sera en mesure de d√©tecter dans toute l‚Äôapp si quelque chose n‚Äôest pas pass√© correctement : pour le langage, il s‚Äòagit simplement de fonctions qui appellent d‚Äôautres fonctions, et les langages fonctionnels statiquement et fortement typ√©s sont plut√¥t pas d√©gueulasses pour √ßa.\n\n## Stateful\n\nLa petite particularit√© de ReasonReact vis √† vis des composants stateful, c‚Äôest que les mises √† jour d'√©tats doivent passer par un reducer, comme si chaque composant embarquait sa petite impl√©mentation de redux.\n\nMaintenant, comment qu'on fait pour cr√©er un composant stateful ?\n\nOn commence par d√©finir le type du state : contrairement √† JS, il ne s'agit pas forc√©ment d'un objet, √ßa peut √™tre une cha√Æne de caract√®re, un entier, un variant, un boolean, un arbuste, une map, un jus de fruits frais, un tableau, whatever.\n\n```js\ntype state = {\n  counter: int\n};\n```\n\nOn va d√©finir notre type action, sous la forme de variants: chaque variant repr√©sente un des type d‚Äôaction possible. Pour bien se repr√©senter ce qu'est une action, c‚Äôest un token, contenant possiblement des param√®tres, qu‚Äôon va envoyer √† notre fameux reducer qui, lui, retournera une r√©action √† cette action.\n\n```js\ntype action =\n  | Increment\n  | Decrement;\n```\n\nDans le composant retourn√© par `make`, on ajoute une fonction `initialState` qui retourne‚Ä¶ l'√©tat initial (c'est bien, vous suivez), et une fonction `reducer`, qui effectue un pattern-matching sur l‚Äôaction et retourne une update.\nCette fonction prend deux param√®tres: l'`action` √† traiter et le `state` √† jour (comme lorsque l'on passe un callback √† `setState` dans l'√©quivalent JavaScript `setState(state => newState)`).\n\nL‚Äôupdate retourn√©e indique au component comment il doit se mettre √† jour (ici sont list√©s les cas courants) :\n\n- `NoUpdate`, pour ne rien faire\n- `Update`, pour mettre √† jour l‚Äô√©tat et re-rendre le composant\n- `SideEffect` pour lancer un effet de bord (e.g. une requ√™te r√©seau)\n- `UpdateWithSideEffect`, pour changer le state et lancer un effet de bord (e.g. afficher un loader et lancer une requ√™te)\n\n*Wrapping up* :\n\n```js\ntype state = {counter: int};\n\ntype action =\n  | Increment\n  | Decrement;\n\n/* Il faut bien d√©finir le `component` **apr√®s** les types `state` et `action`, pour qu'il puisse les lire */\nlet component = ReasonReact.reducerComponent(\"Count\");\n\nlet make = (~initialCounter=0, _) => {\n  ...component,\n  initialState: () => {counter: initialCounter},\n  reducer: (action, state) =>\n    /* Toutes mes updates passent par l√†, bien pratique pour qu'une\n      personne puisse aborder rapidement le composant */\n    switch action {\n    | Increment => ReasonReact.Update({counter: state.counter + 1})\n    | Decrement => ReasonReact.Update({counter: max(0, state.counter - 1)})\n    },\n  render: ({state, reduce}) =>\n    <div>\n      (ReasonReact.stringToElement(state.counter |> string_of_int))\n      /* La fonction reduce prend une fonction qui retourne l'action.\n           Il s'agit d'une fonction pour lire les propri√©t√©s des\n           events (qui sont pooled dans React) de mani√®re synchrone, alors\n           que le reducer est appel√© de mani√®re asynchrone.\n         */\n      <button onClick=(reduce((_event) => Decrement))> (ReasonReact.stringToElement(\"-\")) </button>\n      <button onClick=(reduce((_event) => Increment))> (ReasonReact.stringToElement(\"+\")) </button>\n    </div>\n};\n```\n\net hop:\n\n```js\nReactDOM.renderToElementWithId(<Count initialCount=0 />, \"App\");\n```\n\n## With side-effects\n\nBien que √ßa puisse para√Ætre un peu lourd de devoir faire un `reducer` pour g√©rer ses updates, √ßa apporte quand m√™me:\n\n- Un seul endroit par composant o√π toutes les updates passent\n- La possibilit√© pour le compiler de d√©tecter si l'on oublie de g√©rer des actions\n- De g√©rer lisiblement et uniform√©ment les effets de bord\n\n<img src=\"./terminal.png\" alt=\"\" />\n\nExemple ici avec un composant o√π on va faire comme si on r√©cup√©rait l'utilisateur connect√© sur une API.\n\n```js\nlet resolveAfter = (ms) =>\n  Js.Promise.make(\n    (~resolve, ~reject as _) => ignore(Js.Global.setTimeout(() => [@bs] resolve(ms), ms))\n  );\n\nmodule User = {\n  type t = {username: string};\n  /* faisons comme si on avait un appel serveur\n     (je le fais comme √ßa pour que vous puissiez copier/coller le code\n     pour essayer chez vous) */\n  let getUser = (_) =>\n    resolveAfter(1000)\n    |> Js.Promise.then_(\n         (_) =>\n           Js.Promise.resolve({\n             username: \"MyUsername\" ++ string_of_int(Js.Math.random_int(0, 9999))\n           })\n       );\n};\n\n/* Le \"user\" distant peut avoir 4 √©tats possibles ici */\ntype resource('a) =\n  | Inactive\n  | Loading\n  | Idle('a)\n  | Errored;\n\ntype action =\n  | Load\n  | Receive(resource(User.t));\n\ntype state = {user: resource(User.t)};\n\nlet component = ReasonReact.reducerComponent(\"User\");\n\nlet getUser = (credentials, {ReasonReact.reduce}) =>\n  ignore(\n    User.getUser(credentials)\n    /* Si tout s'est bien pass√© */\n    |> Js.Promise.then_(\n         /* On peut utiliser les actions en dehors du `make`: c'est juste des variants */\n         (payload) => Js.Promise.resolve(reduce((payload) => Receive(Idle(payload)), payload))\n       )\n    /* Si √ßa a merd√© */\n    |> Js.Promise.catch((_) => Js.Promise.resolve(reduce(() => Receive(Errored), ())))\n  );\n\nlet make = (~credentials, _) => {\n  ...component,\n  initialState: () => {user: Inactive},\n  reducer: (action, _state) =>\n    switch action {\n    /* UpdateWithSideEffects met √† jour l'√©tat, puis lance l'effet de bord,\n       tr√®s pratique pour ce genre de cas */\n    | Load => ReasonReact.UpdateWithSideEffects({user: Loading}, getUser(credentials))\n    | Receive(user) => ReasonReact.Update({user: user})\n    },\n  didMount: ({reduce}) => {\n    reduce(() => Load, ());\n    ReasonReact.NoUpdate\n  },\n  render: ({state, reduce}) =>\n    <div>\n      (\n        ReasonReact.stringToElement(\n          switch state.user {\n          | Inactive\n          | Loading => \"Loading ...\"\n          | Idle(user) => \"Hello \" ++ user.username\n          | Errored => \"An error occured\"\n          }\n        )\n      )\n      <div>\n        <button\n          disabled=(\n            switch state.user {\n            | Idle(_) => Js.false_\n            | _ => Js.true_\n            }\n          )\n          onClick=(reduce((_) => Load))>\n          (ReasonReact.stringToElement(\"Reload\"))\n        </button>\n      </div>\n    </div>\n};\n```\n\n## Oui mais est-ce que je peux l'utiliser aujourd'hui alors que j'ai d√©j√† une grosse codebase React ?\n\n<img src=\"./tenor.gif\" alt=\"\" />\n\nPour utiliser des composants ReasonReact avec React\n\n```js\nlet jsComponent =\n  ReasonReact.wrapReasonForJs(\n    ~component,\n    (jsProps) =>\n      make(\n        ~credentials=jsProps##credentials,\n        [||]\n      )\n  );\n```\n\net\n\n```js\nconst MyComponent = require(\"path/to/reason/output\").jsComponent;\n```\n\n√Ä l'inverse, pour utiliser des composants React avec ReasonReact\n\n```js\n[@bs.module \"path/to/good/old/reactjs/component\"] external myJsComponent : ReasonReact.reactClass = \"default\";\n\nlet make = (~message: string, _children) =>\n  ReasonReact.wrapJsForReason(\n    ~reactClass=myJsComponent,\n    ~props={\"message\": message},\n    [||]\n ¬†);\n```\n\nVoil√† pour les *basics* de ReasonReact. Pour en savoir plus, y a [la petite doc qui va bien](https://reasonml.github.io/reason-react/), et on vous pr√©parera un petit article sur les aspects un peu plus avanc√©s de l'usage.\n\nBisous bisous.\n","__filename":"fr/articles/reason/reasonreact/index.md","__url":"/fr/articles/reason/reasonreact/","__resourceUrl":"/fr/articles/reason/reasonreact/index.html","__dataUrl":"/fr/articles/reason/reasonreact/index.html.359f32f7d0be0413816c6ac92f19bee7.json"}