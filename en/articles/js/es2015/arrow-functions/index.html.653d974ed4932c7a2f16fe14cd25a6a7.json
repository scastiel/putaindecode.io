{"head":{"layout":"Post","comments":true,"date":"2015-12-15","title":"ES6, ES2015 : Arrow functions","tags":["JavaScript","ES6","ES2015"],"authors":["MoOx"],"description":"ES2015 brings us some new syntax sugar that will likely make you stop using Function.prototype.bind(). Arrow functions are just a function…"},"body":"<p>ES2015 brings us some new syntax sugar that will likely make you stop using\n<code>Function.prototype.bind()</code>.</p>\n<p>Arrow functions are just a function shorthand using the <code>=></code> syntax.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// es5</span>\n<span class=\"hljs-keyword\">var</span> myFn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">x</span>) </span>{\n  <span class=\"hljs-keyword\">return</span> x + <span class=\"hljs-number\">1</span>;\n};\n\n<span class=\"hljs-comment\">// es6</span>\n<span class=\"hljs-keyword\">const</span> myFn = <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> {\n  <span class=\"hljs-keyword\">return</span> x + <span class=\"hljs-number\">1</span>;\n};</code></pre>\n<p>Arrow functions are syntactically similar to the related feature that exists in\nother languages like CoffeeScript, Java (8+), C#…</p>\n<p>They support both expression and statement bodies. In our example above, we have\nseen a classic statement. But for simple function, we can use an simple\nexpression, to make things shorter. That means that the previous example can be\nalso written like this:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> myFn = <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> x + <span class=\"hljs-number\">1</span>;</code></pre>\n<p>Note that when you have only one argument, you can omit parenthesis around it.\nSo we can also wrote the example like this</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> myFn = <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> x + <span class=\"hljs-number\">1</span>;</code></pre>\n<p>And you can also wrap the body in parenthesis if you want to make a multiline\nexpression</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> myFn = <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> x + <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// that can be multilines, you can imagine some JSX here ;)</span></code></pre>\n<p>So this examples are all the same :</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> myFn = <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> {\n  <span class=\"hljs-keyword\">return</span> x + <span class=\"hljs-number\">1</span>;\n};\n<span class=\"hljs-comment\">// ===</span>\n<span class=\"hljs-keyword\">const</span> myFn = <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> x + <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-comment\">// ===</span>\n<span class=\"hljs-keyword\">const</span> myFn = <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> x + <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-comment\">// ===</span>\n<span class=\"hljs-keyword\">const</span> myFn = <span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =></span> x + <span class=\"hljs-number\">1</span>;</code></pre>\n<p>In practice you will use this small functions in method like Array\nreduce/filter/map etc.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> nums = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];\n<span class=\"hljs-keyword\">const</span> odds = nums.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =></span> v % <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// [1, 3, 5]</span>\n<span class=\"hljs-keyword\">const</span> oddsSum = odds.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">sum, v</span>) =></span> sum + v, <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// 9</span></code></pre>\n<h2 id=\"arrow-functions-dont-have-a-this\"><a href=\"#arrow-functions-dont-have-a-this\" class=\"phenomic-HeadingAnchor\">#</a>Arrow functions don’t have a <code>this</code></h2>\n<p>Yes your read correctly: unlike functions, arrows function share the same\nlexical this as their surrounding code. So that means the <code>this</code> you might use\nuse in the body of an arrow function refer to the parent scope:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> Someone = {\n  <span class=\"hljs-attr\">name</span>: “MoOx”,\n  <span class=\"hljs-attr\">friends</span>: [], <span class=\"hljs-comment\">// he got no friends atm :(</span>\n  printFriends() {\n    <span class=\"hljs-keyword\">this</span>._friends.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">f</span> =></span>\n      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-keyword\">this</span>._name + <span class=\"hljs-string\">\" knows \"</span> + f)\n      <span class=\"hljs-comment\">// `this` is not the function of the forEach !</span>\n    )\n  }\n}</code></pre>\n<p>By reading this code, you might understand that you are likely to stop using\n<code>bind()</code>:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> React, { Component } <span class=\"hljs-keyword\">from</span> “react”\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Stuff</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Component</span> </span>{\n\n  <span class=\"hljs-comment\">// old way</span>\n  onClick(e) {\n    <span class=\"hljs-keyword\">this</span>.setState({ <span class=\"hljs-attr\">omg</span>: <span class=\"hljs-literal\">false</span> })\n  }\n\n  render() {\n    <span class=\"hljs-keyword\">return</span> (\n      <span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span>></span>\n        { /* old way */ }\n        </span>&#x3C;button onClick={ this.onClick.bind(this) }>\n          Old binded call\n        &#x3C;/button><span class=\"xml\">\n\n        { /* LOOK MA', NO BIND ! */ }\n        </span>&#x3C;button onClick={ (e) => this.onClick(e) }>\n          I don’t need `bind` anymore !\n        &#x3C;/button><span class=\"xml\">\n\n        { /* Simpler way */ }\n        </span>&#x3C;button onClick={ (e) => this.setState({ omg: true }) }>\n          Hell yeah\n        &#x3C;/button><span class=\"xml\">\n      <span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n    )\n  }\n}</code></pre>\n<h2 id=\"note-about-expression-body-and-object\"><a href=\"#note-about-expression-body-and-object\" class=\"phenomic-HeadingAnchor\">#</a>Note about expression body and Object</h2>\n<p>If you want to return an object you might be surprised to get <code>undefined</code> with\nthis code:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> aFn = <span class=\"hljs-function\"><span class=\"hljs-params\">obj</span> =></span> {\n  <span class=\"hljs-attr\">key</span>: obj.value;\n};</code></pre>\n<p>Indeed the above snippet could be translated into ES5 this way:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">var</span> aFn = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">obj</span>) </span>{\n  <span class=\"hljs-comment\">// Defines a label named `key`</span>\n  key: obj.value; <span class=\"hljs-comment\">// Gets `obj.value`</span>\n  <span class=\"hljs-comment\">// Implicit returns `undefined`</span>\n};</code></pre>\n<p>Keep in mind that in this context, a brace is to start a statement body, not an\nobject. So you will need this:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> aFn = <span class=\"hljs-function\"><span class=\"hljs-params\">obj</span> =></span> {\n  <span class=\"hljs-keyword\">return</span> { <span class=\"hljs-attr\">key</span>: obj.value };\n};</code></pre>\n<p>But wait, there is a trick: a stupid couple of parenthesis.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> aFn = <span class=\"hljs-function\"><span class=\"hljs-params\">obj</span> =></span> ({ <span class=\"hljs-attr\">key</span>: obj.value }); <span class=\"hljs-comment\">// It works!</span></code></pre>\n<h2 id=\"conclusion\"><a href=\"#conclusion\" class=\"phenomic-HeadingAnchor\">#</a>Conclusion</h2>\n<p>Take a look to the <a href=\"https://kangax.github.io/compat-table/es6/#test-arrow_functions\">compatibility\ntable</a>. You\nwill see that arrow functions are already supported by most browsers but you\nmight need <a href=\"http://babeljs.io\">Babel</a> to use it today.</p>\n<p>You will probably use this more and more. Even if <code>function</code> keyword is not\ndead, arrow functions <code>=></code> are probably going to be a thing !</p>\n","rawBody":"\nES2015 brings us some new syntax sugar that will likely make you stop using\n`Function.prototype.bind()`.\n\nArrow functions are just a function shorthand using the `=>` syntax.\n\n```js\n// es5\nvar myFn = function(x) {\n  return x + 1;\n};\n\n// es6\nconst myFn = x => {\n  return x + 1;\n};\n```\n\nArrow functions are syntactically similar to the related feature that exists in\nother languages like CoffeeScript, Java (8+), C#…\n\nThey support both expression and statement bodies. In our example above, we have\nseen a classic statement. But for simple function, we can use an simple\nexpression, to make things shorter. That means that the previous example can be\nalso written like this:\n\n```js\nconst myFn = x => x + 1;\n```\n\nNote that when you have only one argument, you can omit parenthesis around it.\nSo we can also wrote the example like this\n\n```js\nconst myFn = x => x + 1;\n```\n\nAnd you can also wrap the body in parenthesis if you want to make a multiline\nexpression\n\n```js\nconst myFn = x => x + 1; // that can be multilines, you can imagine some JSX here ;)\n```\n\nSo this examples are all the same :\n\n```js\nconst myFn = x => {\n  return x + 1;\n};\n// ===\nconst myFn = x => x + 1;\n// ===\nconst myFn = x => x + 1;\n// ===\nconst myFn = x => x + 1;\n```\n\nIn practice you will use this small functions in method like Array\nreduce/filter/map etc.\n\n```js\nconst nums = [1, 2, 3, 4, 5];\nconst odds = nums.filter(v => v % 2); // [1, 3, 5]\nconst oddsSum = odds.reduce((sum, v) => sum + v, 0); // 9\n```\n\n## Arrow functions don’t have a `this`\n\nYes your read correctly: unlike functions, arrows function share the same\nlexical this as their surrounding code. So that means the `this` you might use\nuse in the body of an arrow function refer to the parent scope:\n\n```js\nconst Someone = {\n  name: “MoOx”,\n  friends: [], // he got no friends atm :(\n  printFriends() {\n    this._friends.forEach(f =>\n      console.log(this._name + \" knows \" + f)\n      // `this` is not the function of the forEach !\n    )\n  }\n}\n```\n\nBy reading this code, you might understand that you are likely to stop using\n`bind()`:\n\n```js\nimport React, { Component } from “react”\nclass Stuff extends Component {\n\n  // old way\n  onClick(e) {\n    this.setState({ omg: false })\n  }\n\n  render() {\n    return (\n      <div>\n        { /* old way */ }\n        <button onClick={ this.onClick.bind(this) }>\n          Old binded call\n        </button>\n\n        { /* LOOK MA', NO BIND ! */ }\n        <button onClick={ (e) => this.onClick(e) }>\n          I don’t need `bind` anymore !\n        </button>\n\n        { /* Simpler way */ }\n        <button onClick={ (e) => this.setState({ omg: true }) }>\n          Hell yeah\n        </button>\n      </div>\n    )\n  }\n}\n```\n\n## Note about expression body and Object\n\nIf you want to return an object you might be surprised to get `undefined` with\nthis code:\n\n```js\nconst aFn = obj => {\n  key: obj.value;\n};\n```\n\nIndeed the above snippet could be translated into ES5 this way:\n\n```js\nvar aFn = function(obj) {\n  // Defines a label named `key`\n  key: obj.value; // Gets `obj.value`\n  // Implicit returns `undefined`\n};\n```\n\nKeep in mind that in this context, a brace is to start a statement body, not an\nobject. So you will need this:\n\n```js\nconst aFn = obj => {\n  return { key: obj.value };\n};\n```\n\nBut wait, there is a trick: a stupid couple of parenthesis.\n\n```js\nconst aFn = obj => ({ key: obj.value }); // It works!\n```\n\n## Conclusion\n\nTake a look to the [compatibility\ntable](https://kangax.github.io/compat-table/es6/#test-arrow_functions). You\nwill see that arrow functions are already supported by most browsers but you\nmight need [Babel](http://babeljs.io) to use it today.\n\nYou will probably use this more and more. Even if `function` keyword is not\ndead, arrow functions `=>` are probably going to be a thing !\n","__filename":"en/articles/js/es2015/arrow-functions.md","__url":"/en/articles/js/es2015/arrow-functions/","__resourceUrl":"/en/articles/js/es2015/arrow-functions/index.html","__dataUrl":"/en/articles/js/es2015/arrow-functions/index.html.653d974ed4932c7a2f16fe14cd25a6a7.json"}